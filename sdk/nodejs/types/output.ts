// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface FusionAuthApiKeyPermissionsEndpoint {
    /**
     * HTTP DELETE Verb.
     */
    delete?: boolean;
    endpoint: string;
    /**
     * HTTP GET Verb.
     */
    get?: boolean;
    /**
     * HTTP PATCH Verb
     */
    patch?: boolean;
    /**
     * HTTP POST Verb
     */
    post?: boolean;
    /**
     * HTTP PUT Verb
     */
    put?: boolean;
}

export interface FusionAuthApplicationAccessControlConfiguration {
    /**
     * The Id of the IP Access Control List limiting access to this application.
     */
    uiIpAccessControlListId?: string;
}

export interface FusionAuthApplicationCleanSpeakConfiguration {
    /**
     * An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.
     */
    applicationIds?: string[];
    usernameModeration?: outputs.FusionAuthApplicationCleanSpeakConfigurationUsernameModeration;
}

export interface FusionAuthApplicationCleanSpeakConfigurationUsernameModeration {
    /**
     * The Id of the CleanSpeak application that usernames are sent to for moderation.
     */
    applicationId?: string;
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
}

export interface FusionAuthApplicationEmailConfiguration {
    /**
     * The Id of the Email Template used to send emails to users when their email address is updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    emailUpdateTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users to verify that their email address is valid. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    emailVerificationTemplateId?: string;
    /**
     * The Id of the Email Template used to verify user emails. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    emailVerifiedTemplateId?: string;
    /**
     * The Id of the Email Template that is used when a user is sent a forgot password email. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    forgotPasswordTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    loginIdInUseOnCreateTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when another user attempts to update an existing account to use their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    loginIdInUseOnUpdateTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when they log in on a new device. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    loginNewDeviceTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a suspicious login occurs. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    loginSuspiciousTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been reset. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    passwordResetSuccessTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when their password has been updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    passwordUpdateTemplateId?: string;
    /**
     * The Id of the Passwordless Email Template, sent to users when they start a passwordless login. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    passwordlessEmailTemplateId?: string;
    /**
     * The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    setPasswordEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a MFA method has been added to their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    twoFactorMethodAddTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a MFA method has been removed from their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
     */
    twoFactorMethodRemoveTemplateId?: string;
}

export interface FusionAuthApplicationFormConfiguration {
    /**
     * The unique Id of the form to use for the Add and Edit User Registration form when used in the FusionAuth admin UI.
     */
    adminRegistrationFormId?: string;
    /**
     * The unique Id of the form to to enable authenticated users to manage their profile on the account page.
     */
    selfServiceFormId?: string;
}

export interface FusionAuthApplicationJwtConfiguration {
    /**
     * The Id of the signing key used to sign the access token.
     */
    accessTokenId?: string;
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    /**
     * The Id of the signing key used to sign the Id token.
     */
    idTokenKeyId?: string;
    /**
     * The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT.
     */
    refreshTokenTtlMinutes?: number;
    /**
     * The length of time in seconds the JWT will live before it is expired and no longer valid.
     */
    ttlSeconds?: number;
}

export interface FusionAuthApplicationLambdaConfiguration {
    /**
     * The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API.
     */
    accessTokenPopulateId?: string;
    /**
     * The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request.
     */
    idTokenPopulateId?: string;
    /**
     * The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request.
     */
    samlv2PopulateId?: string;
}

export interface FusionAuthApplicationLoginConfiguration {
    /**
     * Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.
     */
    allowTokenRefresh?: boolean;
    /**
     * Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offlineAccess scope is requested.
     */
    generateRefreshTokens?: boolean;
    /**
     * Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.
     */
    requireAuthentication?: boolean;
}

export interface FusionAuthApplicationMultiFactorConfiguration {
    /**
     * The Id of the email template that is used when notifying a user to complete a multi-factor authentication request.
     */
    emailTemplateId?: string;
    /**
     * The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
     */
    smsTemplateId?: string;
}

export interface FusionAuthApplicationOauthConfiguration {
    /**
     * An array of URLs that are the authorized origins for FusionAuth OAuth.
     */
    authorizedOriginUrls?: string[];
    /**
     * An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
     */
    authorizedRedirectUrls?: string[];
    /**
     * Determines whether wildcard expressions will be allowed in the authorizedRedirectUrls and authorized_origin_urls.
     */
    authorizedUrlValidationPolicy?: string;
    /**
     * Determines the client authentication requirements for the OAuth 2.0 Token endpoint.
     */
    clientAuthenticationPolicy?: string;
    clientId: string;
    /**
     * The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored.
     */
    clientSecret: string;
    /**
     * Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
     */
    debug?: boolean;
    /**
     * The device verification URL to be used with the Device Code grant type, this field is required when deviceCode is enabled.
     */
    deviceVerificationUrl?: string;
    /**
     * The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.
     */
    enabledGrants?: string[];
    /**
     * Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offlineAccess scope is requested.
     */
    generateRefreshTokens?: boolean;
    /**
     * Behavior when /oauth2/logout is called.
     */
    logoutBehavior?: string;
    /**
     * The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
     */
    logoutUrl?: string;
    /**
     * Determines the PKCE requirements when using the authorization code grant.
     */
    proofKeyForCodeExchangePolicy?: string;
    /**
     * Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The clientId and clientSecret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data.
     *
     * @deprecated In version 1.28.0 and beyond, client authentication can be managed via oauth_configuration.client_authentication_policy.
     */
    requireClientAuthentication?: boolean;
    /**
     * When enabled the user will be required to be registered, or complete registration before redirecting to the configured callback in the authorization code grant or the implicit grant. This configuration does not currently apply to any other grant.
     */
    requireRegistration?: boolean;
}

export interface FusionAuthApplicationRegistrationConfiguration {
    birthDate?: outputs.FusionAuthApplicationRegistrationConfigurationBirthDate;
    confirmPassword?: boolean;
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    firstName?: outputs.FusionAuthApplicationRegistrationConfigurationFirstName;
    /**
     * The Id of an associated Form when using advanced registration configuration type. This field is required when application.registrationConfiguration.type is set to advanced.
     */
    formId?: string;
    fullName?: outputs.FusionAuthApplicationRegistrationConfigurationFullName;
    lastName?: outputs.FusionAuthApplicationRegistrationConfigurationLastName;
    /**
     * The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique.
     */
    loginIdType?: string;
    middleName?: outputs.FusionAuthApplicationRegistrationConfigurationMiddleName;
    mobilePhone?: outputs.FusionAuthApplicationRegistrationConfigurationMobilePhone;
    /**
     * The type of registration flow.
     */
    type?: string;
}

export interface FusionAuthApplicationRegistrationConfigurationBirthDate {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationConfigurationFirstName {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationConfigurationFullName {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationConfigurationLastName {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationConfigurationMiddleName {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationConfigurationMobilePhone {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    required?: boolean;
}

export interface FusionAuthApplicationRegistrationDeletePolicy {
    /**
     * Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days.
     */
    unverifiedEnabled?: boolean;
    /**
     * The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0.
     */
    unverifiedNumberOfDaysToRetain?: number;
}

export interface FusionAuthApplicationSamlv2Configuration {
    /**
     * The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response.
     */
    audience?: string;
    /**
     * An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
     */
    authorizedRedirectUrls: string[];
    /**
     * The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML.
     *
     * @deprecated In version 1.20.0 and beyond, Callback URLs can be managed via authorized_redirect_urls.
     */
    callbackUrl?: string;
    /**
     * Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
     */
    debug?: boolean;
    /**
     * The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
     */
    defaultVerificationKeyId?: string;
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    /**
     * The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login.
     */
    issuer: string;
    /**
     * The unique Id of the Key used to sign the SAML Single Logout response.
     */
    keyId?: string;
    logout?: outputs.FusionAuthApplicationSamlv2ConfigurationLogout;
    /**
     * The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
     */
    logoutUrl?: string;
    /**
     * If set to true, will force verification through the key store.
     */
    requiredSignedRequests?: boolean;
    /**
     * The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
     */
    xmlSignatureCanonicalizationMethod?: string;
    /**
     * The location to place the XML signature when signing a successful SAML response.
     */
    xmlSignatureLocation?: string;
}

export interface FusionAuthApplicationSamlv2ConfigurationLogout {
    /**
     * This configuration is functionally equivalent to the Logout Behavior found in the OAuth2 configuration.
     */
    behavior?: string;
    /**
     * The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
     */
    defaultVerificationKeyId?: string;
    /**
     * The unique Id of the Key used to sign the SAML Single Logout response.
     */
    keyId?: string;
    /**
     * Set this parameter equal to true to require the SAML v2 Service Provider to sign the Logout request. When this value is true all Logout requests missing a signature will be rejected.
     */
    requireSignedRequests?: boolean;
    singleLogout?: outputs.FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout;
    /**
     * The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
     */
    xmlSignatureCanonicalizationMethod?: string;
}

export interface FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout {
    /**
     * Whether or not SAML Single Logout for this SAML IdP is enabled.
     */
    enabled?: boolean;
    /**
     * The unique Id of the Key used to sign the SAML Single Logout response.
     */
    keyId?: string;
    /**
     * The URL at which you want to receive the LogoutRequest from FusionAuth.
     */
    url?: string;
    /**
     * The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
     */
    xmlSignatureCanonicalizationMethod?: string;
}

export interface FusionAuthEntityTypeJwtConfiguration {
    /**
     * The unique ID of the signing key used to sign the access token. Required when
     * enabled is set to true.
     */
    accessTokenKeyId?: string;
    /**
     * Indicates if this application is using the JWT configuration defined here or the global JWT
     * configuration defined by the Tenant. If this is false the signing algorithm configured in the Tenant will be used.
     * If true the signing algorithm defined in this application will be used.
     */
    enabled?: boolean;
    /**
     * The length of time in seconds the JWT will live before it is expired and no
     * longer valid. Required when enabled is set to true.
     */
    timeToLiveInSeconds?: number;
}

export interface FusionAuthFormFieldValidator {
    /**
     * Determines if user input should be validated.
     */
    enabled?: boolean;
    /**
     * A regular expression used to validate user input. Must be a valid regular expression pattern.
     */
    expression?: string;
}

export interface FusionAuthFormStep {
    /**
     * An ordered list of Form Field Ids assigned to this step.
     */
    fields: string[];
}

export interface FusionAuthIdpAppleApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
     */
    keyId?: string;
    /**
     * The top-level space separated scope that you are requesting from Apple.
     */
    scope?: string;
    /**
     * The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
     */
    servicesId?: string;
    /**
     * The Apple App ID Prefix, or Team ID found in your Apple Developer Account which has been configured for Sign in with Apple.
     */
    teamId?: string;
}

export interface FusionAuthIdpAppleTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpExternalJwtApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
}

export interface FusionAuthIdpExternalJwtTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpFacebookApplicationConfiguration {
    /**
     * The top-level Facebook `appId` for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
     */
    appId?: string;
    /**
     * ID of the FusionAuth Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * The top-level client secret, also known as 'App Secret', to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
     */
    clientSecret?: string;
    /**
     * Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level fields that you are requesting from Facebook.
     * Field values are documented at [Facebook Graph API](https://developers.facebook.com/docs/graph-api/using-graph-api/)
     */
    fields?: string;
    /**
     * The top-level permissions that your application is asking of the user’s Facebook account.
     * Permission values are documented at [Facebook Login API](https://developers.facebook.com/docs/permissions/reference)
     */
    permissions?: string;
}

export interface FusionAuthIdpFacebookTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpGoogleApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account.
     */
    clientId?: string;
    /**
     * The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account.
     */
    clientSecret?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from Google.
     */
    scope?: string;
}

export interface FusionAuthIdpGoogleTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpLinkedInApplicationConfiguration {
    /**
     * ID of the FusionAuth Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * The top-level LinkedIn client id for your Application. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
     */
    clientId?: string;
    /**
     * The top-level client secret to use with the LinkedIn Identity Provider when retrieving the long-lived token. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
     */
    clientSecret?: string;
    /**
     * Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from LinkedIn.
     */
    scope?: string;
}

export interface FusionAuthIdpLinkedInTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpOpenIdConnectApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
     */
    buttonImageUrl?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level client id for your Application.
     */
    oauth2ClientId?: string;
    /**
     * The top-level client secret to use with the OpenID Connect identity provider.
     */
    oauth2ClientSecret?: string;
    /**
     * The top-level scope that you are requesting from the OpenID Connect identity provider.
     */
    oauth2Scope?: string;
}

export interface FusionAuthIdpOpenIdConnectTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpPsnApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * The top-level Sony PlayStation Network client id for your Application. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
     */
    clientId?: string;
    /**
     * The top-level client secret to use with the Sony PlayStation Network Identity Provider when retrieving the long-lived token. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
     */
    clientSecret?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from Sony PlayStation Network.
     */
    scope?: string;
}

export interface FusionAuthIdpPsnTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration {
    applicationId?: string;
    createRegistration?: boolean;
    enabled?: boolean;
}

export interface FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration {
    limitUserLinkCountEnabled?: boolean;
    limitUserLinkCountMaximumLinks?: number;
    tenantId?: string;
}

export interface FusionAuthIdpSamlv2ApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
     */
    buttonImageUrl?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
}

export interface FusionAuthIdpSamlv2TenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpSteamApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * The top-level Steam client id for your Application. This value is retrieved from the Steam developer website when you setup your Steam developer account.
     */
    clientId?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from Steam.
     */
    scope?: string;
    /**
     * The top-level web API key to use with the Steam Identity Provider when retrieving the player summary info. This value is retrieved from the Steam developer website when you setup your Steam developer account.
     */
    webApiKey?: string;
}

export interface FusionAuthIdpSteamTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpTwitchApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
     */
    clientId?: string;
    /**
     * The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
     */
    clientSecret?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from Xbox.
     */
    scope?: string;
}

export interface FusionAuthIdpTwitchTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthIdpXBoxApplicationConfiguration {
    /**
     * ID of the Application to apply this configuration to.
     */
    applicationId?: string;
    /**
     * The top-level button text to use on the FusionAuth login page for this Identity Provider.
     */
    buttonText?: string;
    /**
     * TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
     */
    clientId?: string;
    /**
     * The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
     */
    clientSecret?: string;
    /**
     * Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
     */
    createRegistration?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    enabled?: boolean;
    /**
     * The top-level scope that you are requesting from Xbox.
     */
    scope?: string;
}

export interface FusionAuthIdpXBoxTenantConfiguration {
    /**
     * When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
     */
    limitUserLinkCountEnabled?: boolean;
    /**
     * Determines if this provider is enabled. If it is false then it will be disabled globally.
     */
    limitUserLinkCountMaximumLinks?: number;
    /**
     * The unique Id of the tenant that this configuration applies to.
     */
    tenantId?: string;
}

export interface FusionAuthSystemConfigurationAuditLogConfiguration {
    delete?: outputs.FusionAuthSystemConfigurationAuditLogConfigurationDelete;
}

export interface FusionAuthSystemConfigurationAuditLogConfigurationDelete {
    /**
     * Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
     */
    enabled?: boolean;
    /**
     * The number of days to retain login records.
     */
    numberOfDaysToRetain?: number;
}

export interface FusionAuthSystemConfigurationCorsConfiguration {
    /**
     * The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials.
     */
    allowCredentials?: boolean;
    /**
     * The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers.
     */
    allowedHeaders: string[];
    /**
     * The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods.
     */
    allowedMethods: string[];
    /**
     * The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified.
     */
    allowedOrigins?: string[];
    /**
     * Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
     */
    enabled?: boolean;
    /**
     * The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers.
     */
    exposedHeaders: string[];
    /**
     * The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age.
     */
    preflightMaxAgeInSeconds?: number;
}

export interface FusionAuthSystemConfigurationEventLogConfiguration {
    /**
     * The number of events to retain. Once the the number of event logs exceeds this configured value they will be deleted starting with the oldest event logs.
     */
    numberToRetain?: number;
}

export interface FusionAuthSystemConfigurationLoginRecordConfiguration {
    delete?: outputs.FusionAuthSystemConfigurationLoginRecordConfigurationDelete;
}

export interface FusionAuthSystemConfigurationLoginRecordConfigurationDelete {
    /**
     * Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
     */
    enabled?: boolean;
    /**
     * The number of days to retain login records.
     */
    numberOfDaysToRetain?: number;
}

export interface FusionAuthSystemConfigurationUiConfiguration {
    /**
     * A hexadecimal color to override the default menu color in the user interface.
     */
    headerColor?: string;
    /**
     * A URL of a logo to override the default FusionAuth logo in the user interface.
     */
    logoUrl?: string;
    /**
     * A hexadecimal color to override the default menu font color in the user interface.
     */
    menuFontColor?: string;
}

export interface FusionAuthTenantAccessControlConfiguration {
    /**
     * The Id of the IP Access Control List limiting access to all applications in this tenant.
     */
    uiIpAccessControlListId?: string;
}

export interface FusionAuthTenantCaptchaConfiguration {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The secret key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
     */
    secretKey?: string;
    /**
     * The site key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
     */
    siteKey?: string;
    /**
     * The numeric threshold which separates a passing score from a failing one. This value only applies if using either the Google v3 or HCaptcha Enterprise method, otherwise this value is ignored.
     */
    threshold?: number;
}

export interface FusionAuthTenantConnectorPolicy {
    /**
     * The identifier of the Connector to which this policy refers.
     */
    connectorId?: string;
    /**
     * A list of email domains to which this connector should apply. A value of ["*"] indicates this connector applies to all users.
     */
    domains?: string[];
    /**
     * If true, the user’s data will be migrated to FusionAuth at first successful authentication; subsequent authentications will occur against the FusionAuth datastore. If false, the Connector’s source will be treated as authoritative.
     */
    migrate?: boolean;
}

export interface FusionAuthTenantEmailConfiguration {
    /**
     * The additional SMTP headers to be added to each outgoing email. Each SMTP header consists of a name and a value.
     */
    additionalHeaders?: {[key: string]: any};
    /**
     * The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>).
     */
    defaultFromEmail: string;
    /**
     * The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>).
     */
    defaultFromName?: string;
    /**
     * The Id of the Email Template that is used when a user is sent a forgot password email.
     */
    emailUpdateEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to verify user emails.
     */
    emailVerifiedEmailTemplateId?: string;
    /**
     * The Id of the Email Template that is used when a user is sent a forgot password email.
     */
    forgotPasswordEmailTemplateId?: string;
    /**
     * The host name of the SMTP server that FusionAuth will use.
     */
    host: string;
    /**
     * When set to true, this allows email to be verified as a result of completing a similar email based workflow such as change password. When seto false, the user must explicitly complete the email verification workflow even if the user has already completed a similar email workflow such as change password.
     */
    implicitEmailVerificationAllowed?: boolean;
    /**
     * The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
     */
    loginIdInUseOnCreateEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
     */
    loginIdInUseOnUpdateEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when they log in on a new device.
     */
    loginNewDeviceEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a suspicious login occurs.
     */
    loginSuspiciousEmailTemplateId?: string;
    /**
     * An optional password FusionAuth will use to authenticate with the SMTP server.
     */
    password?: string;
    /**
     * The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password habeen reset.
     */
    passwordResetSuccessEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been rese
     */
    passwordUpdateEmailTemplateId?: string;
    /**
     * The Id of the Passwordless Email Template.
     */
    passwordlessEmailTemplateId?: string;
    /**
     * The port of the SMTP server that FusionAuth will use.
     */
    port: number;
    /**
     * Additional Email Configuration in a properties file formatted String.
     */
    properties?: string;
    /**
     * The type of security protocol FusionAuth will use when connecting to the SMTP server.
     */
    security?: string;
    /**
     * The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password.
     */
    setPasswordEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a MFA method has been added to their account.
     */
    twoFactorMethodAddEmailTemplateId?: string;
    /**
     * The Id of the Email Template used to send emails to users when a MFA method has been removed from their account.
     */
    twoFactorMethodRemoveEmailTemplateId?: string;
    unverified: outputs.FusionAuthTenantEmailConfigurationUnverified;
    /**
     * An optional username FusionAuth will to authenticate with the SMTP server.
     */
    username?: string;
    /**
     * The Id of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address ivalid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required.
     */
    verificationEmailTemplateId?: string;
    /**
     * The process by which the user will verify their email address. Possible values are `ClickableLink` or `FormField`.
     */
    verificationStrategy?: string;
    /**
     * Whether the user’s email addresses are verified when the registers with your application.
     */
    verifyEmail?: boolean;
    /**
     * Whether the user’s email addresses are verified when the user changes them.
     */
    verifyEmailWhenChanged?: boolean;
}

export interface FusionAuthTenantEmailConfigurationUnverified {
    /**
     * When this value is set to true, the user is allowed to change their email address when they are gated because they haven’t verified their email address.
     */
    allowEmailChangeWhenGated?: boolean;
    /**
     * = (Optional) The behavior when detecting breaches at time of user login
     */
    behavior?: string;
}

export interface FusionAuthTenantEventConfiguration {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The event type
     */
    event?: string;
    /**
     * The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks.
     */
    transactionType?: string;
}

export interface FusionAuthTenantExternalIdentifierConfiguration {
    /**
     * The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.
     */
    authorizationGrantIdTimeToLiveInSeconds: number;
    changePasswordIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator;
    /**
     * The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
     */
    changePasswordIdTimeToLiveInSeconds: number;
    /**
     * The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
     */
    deviceCodeTimeToLiveInSeconds: number;
    deviceUserCodeIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator;
    emailVerificationIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator;
    /**
     * The time in seconds until a email verification Id is no longer valid and cannot be used by the Verify Email API. Value must be greater than 0.
     */
    emailVerificationIdTimeToLiveInSeconds: number;
    emailVerificationOneTimeCodeGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator;
    /**
     * The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
     */
    externalAuthenticationIdTimeToLiveInSeconds: number;
    /**
     * The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0.
     */
    oneTimePasswordTimeToLiveInSeconds: number;
    passwordlessLoginGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator;
    /**
     * The time in seconds until a passwordless code is no longer valid and cannot be used by the Passwordless API. Value must be greater than 0.
     */
    passwordlessLoginTimeToLiveInSeconds: number;
    /**
     * The number of seconds before the pending account link identifier is no longer valid to complete an account link request. Value must be greater than 0.
     */
    pendingAccountLinkTimeToLiveInSeconds?: number;
    registrationVerificationIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator;
    /**
     * The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0.
     */
    registrationVerificationIdTimeToLiveInSeconds: number;
    registrationVerificationOneTimeCodeGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator;
    /**
     * The time in seconds that a SAML AuthN request will be eligible for use to authenticate with FusionAuth.
     */
    samlV2AuthnRequestIdTtlSeconds?: number;
    setupPasswordIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator;
    /**
     * The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
     */
    setupPasswordIdTimeToLiveInSeconds: number;
    /**
     * The number of seconds before the Trust Token is no longer valid to complete a request that requires trust. Value must be greater than 0.
     */
    trustTokenTimeToLiveInSeconds?: number;
    /**
     * The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0.
     */
    twoFactorIdTimeToLiveInSeconds: number;
    twoFactorOneTimeCodeIdGenerator: outputs.FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator;
    /**
     * The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0.
     */
    twoFactorTrustIdTimeToLiveInSeconds: number;
}

export interface FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type?: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type?: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type: string;
}

export interface FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator {
    /**
     * TThe length of the secure generator used for generating the the two factor code Id.
     */
    length: number;
    /**
     * The type of the secure generator used for generating the two factor one time code Id.
     */
    type?: string;
}

export interface FusionAuthTenantFailedAuthenticationConfiguration {
    /**
     * The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0.
     */
    actionDuration?: number;
    /**
     * The unit of time associated with a duration.
     */
    actionDurationUnit?: string;
    /**
     * The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.
     */
    resetCountInSeconds?: number;
    /**
     * The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0.
     */
    tooManyAttempts?: number;
    /**
     * The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts.
     */
    userActionId?: string;
}

export interface FusionAuthTenantFamilyConfiguration {
    /**
     * Whether to allow child registrations.
     */
    allowChildRegistrations?: boolean;
    /**
     * The unique Id of the email template to use when confirming a child.
     */
    confirmChildEmailTemplateId?: string;
    /**
     * Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days.
     */
    deleteOrphanedAccounts?: boolean;
    /**
     * The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0.
     */
    deleteOrphanedAccountsDays?: number;
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The unique Id of the email template to use when a family request is made.
     */
    familyRequestEmailTemplateId?: string;
    /**
     * The maximum age of a child. Value must be greater than 0.
     */
    maximumChildAge?: number;
    /**
     * The minimum age to be an owner. Value must be greater than 0.
     */
    minimumOwnerAge?: number;
    /**
     * Whether a parent email is required.
     */
    parentEmailRequired?: boolean;
    /**
     * The unique Id of the email template to use for parent registration.
     */
    parentRegistrationEmailTemplateId?: string;
}

export interface FusionAuthTenantFormConfiguration {
    /**
     * The unique Id of the form to use for the Add and Edit User form when used in the FusionAuth admin UI.
     */
    adminUserFormId: string;
}

export interface FusionAuthTenantJwtConfiguration {
    /**
     * The unique id of the signing key used to sign the access token. Required prior to `1.30.0`.
     */
    accessTokenKeyId?: string;
    /**
     * The unique id of the signing key used to sign the Id token. Required prior to `1.30.0`.
     */
    idTokenKeyId?: string;
    /**
     * The refresh token expiration policy.
     */
    refreshTokenExpirationPolicy?: string;
    /**
     * When enabled, the refresh token will be revoked when a user action, such as locking an account based on a number of failed login attempts, prevents user login.
     */
    refreshTokenRevocationPolicyOnLoginPrevented?: boolean;
    /**
     * When enabled, the refresh token will be revoked when a user changes their password."
     */
    refreshTokenRevocationPolicyOnPasswordChange?: boolean;
    /**
     * The length of time in minutes a Refresh Token is valid from the time it was issued. Value must be greater than 0.
     */
    refreshTokenTimeToLiveInMinutes: number;
    /**
     * The refresh token usage policy.
     */
    refreshTokenUsagePolicy?: string;
    /**
     * The length of time in seconds this JWT is valid from the time it was issued. Value must be greater than 0.
     */
    timeToLiveInSeconds: number;
}

export interface FusionAuthTenantLoginConfiguration {
    /**
     * Indicates whether to require an API key for the Login API when an `applicationId` is not provided. When an `applicationId` is provided to the Login API call, the application configuration will take precedence. In almost all cases, you will want to this to be `true`.
     */
    requireAuthentication: boolean;
}

export interface FusionAuthTenantMaximumPasswordAge {
    /**
     * The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. Required when systemConfiguration.maximumPasswordAge.enabled is set to true.
     */
    days?: number;
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
}

export interface FusionAuthTenantMinimumPasswordAge {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. Required when systemConfiguration.minimumPasswordAge.enabled is set to true.
     */
    seconds?: number;
}

export interface FusionAuthTenantMultiFactorConfiguration {
    authenticator: outputs.FusionAuthTenantMultiFactorConfigurationAuthenticator;
    email: outputs.FusionAuthTenantMultiFactorConfigurationEmail;
    /**
     * When set to `Enabled` and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When set to `Disabled`, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login.
     */
    loginPolicy?: string;
    sms: outputs.FusionAuthTenantMultiFactorConfigurationSms;
}

export interface FusionAuthTenantMultiFactorConfigurationAuthenticator {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
}

export interface FusionAuthTenantMultiFactorConfigurationEmail {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
     */
    templateId?: string;
}

export interface FusionAuthTenantMultiFactorConfigurationSms {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The messenger that is used to deliver a SMS multi-factor authentication request.
     */
    messengerId?: string;
    /**
     * The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
     */
    templateId?: string;
}

export interface FusionAuthTenantOauthConfiguration {
    /**
     * The Id of a lambda that will be called to populate the JWT during a client credentials grant. **Note:** A paid edition of FusionAuth is required to utilize client credentials grant.
     */
    clientCredentialsAccessTokenPopulateLambdaId?: string;
}

export interface FusionAuthTenantPasswordEncryptionConfiguration {
    /**
     * The default method for encrypting the User’s password.
     */
    encryptionScheme?: string;
    /**
     * The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation.
     */
    encryptionSchemeFactor?: number;
    /**
     * When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import.
     */
    modifyEncryptionSchemeOnLogin?: boolean;
}

export interface FusionAuthTenantPasswordValidationRules {
    breachDetection: outputs.FusionAuthTenantPasswordValidationRulesBreachDetection;
    /**
     * The maximum length of a password when a new user is created or a user requests a password change.
     */
    maxLength?: number;
    /**
     * The minimum length of a password when a new user is created or a user requests a password change.
     */
    minLength?: number;
    rememberPreviousPasswords?: outputs.FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords;
    /**
     * Whether to force the user to use at least one non-alphanumeric character.
     */
    requireNonAlpha?: boolean;
    /**
     * Whether to force the user to use at least one number.
     */
    requireNumber?: boolean;
    /**
     * Whether to force the user to use at least one uppercase and one lowercase character.
     */
    requiredMixedCase?: boolean;
    /**
     * When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
     */
    validateOnLogin?: boolean;
}

export interface FusionAuthTenantPasswordValidationRulesBreachDetection {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The level of severity where Reactor will consider a breach.
     */
    matchMode?: string;
    /**
     * The Id of the email template to use when notifying user of breached password. Required if tenant.passwordValidationRules.breachDetection.onLogin is set to NotifyUser.
     */
    notifyUserEmailTemplateId?: string;
    /**
     * The behavior when detecting breaches at time of user login
     */
    onLogin?: string;
}

export interface FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords {
    /**
     * The number of previous passwords to remember. Value must be greater than 0.
     */
    count?: number;
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
}

export interface FusionAuthTenantUserDeletePolicy {
    /**
     * Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
     */
    unverifiedEnabled?: boolean;
    unverifiedNumberOfDaysToRetain?: number;
}

export interface FusionAuthTenantUsernameConfiguration {
    /**
     * Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
     */
    unique?: outputs.FusionAuthTenantUsernameConfigurationUnique;
}

export interface FusionAuthTenantUsernameConfigurationUnique {
    /**
     * When true, FusionAuth will handle username collisions by generating a random suffix.
     */
    enabled?: boolean;
    /**
     * The maximum number of digits to use when building a unique suffix for a username. A number will be randomly selected and will be 1 or more digits up to this configured value in length. For example, if this value is 5, the suffix will be a number between 00001 and 99999, inclusive.
     */
    numberOfDigits?: number;
    /**
     * A single character to use as a separator from the requested username and a unique suffix that is added when a duplicate username is detected. This value can be a single non-alphanumeric ASCII character.
     */
    separator?: string;
    /**
     * When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
     */
    strategy?: string;
}

export interface FusionAuthUserActionOption {
    /**
     * A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language.
     */
    localizedNames?: {[key: string]: any};
    /**
     * The name of this User Action Option.
     */
    name: string;
}

export interface FusionAuthUserTwoFactorMethod {
    /**
     * The algorithm used by the TOTP authenticator. With the current implementation, this will always be HmacSHA1.
     */
    authenticatorAlgorithm: string;
    /**
     * The length of code generated by the TOTP. With the current implementation, this will always be 6.
     */
    authenticatorCodeLength: number;
    /**
     * The time-step size in seconds. With the current implementation, this will always be 30.
     */
    authenticatorTimeStep: number;
    /**
     * The value of the email address for this method.
     */
    email?: string;
    /**
     * The type of this method. There will also be an object with the same value containing additional information about this method.
     */
    method?: string;
    /**
     * The value of the mobile phone for this method.
     */
    mobilePhone?: string;
    /**
     * A base64 encoded secret
     */
    secret?: string;
    twoFactorMethodId: string;
}

export interface FusionAuthWebhookEventsEnabled {
    /**
     * When an audit log is created
     */
    auditLogCreate?: boolean;
    /**
     * When an event log is created
     */
    eventLogCreate?: boolean;
    /**
     * When a JWT RSA Public / Private keypair may have been changed
     */
    jwtPublicKeyUpdate?: boolean;
    /**
     * When an access token is refreshed using a refresh token
     */
    jwtRefresh?: boolean;
    /**
     * When a JWT Refresh Token is revoked
     */
    jwtRefreshTokenRevoke?: boolean;
    /**
     * When kickstart has successfully completed
     */
    kickstartSuccess?: boolean;
    /**
     * When a user action is triggered
     */
    userAction?: boolean;
    /**
     * When multiple users are created in bulk (i.e. during an import)
     */
    userBulkCreate?: boolean;
    /**
     * When a user is created
     */
    userCreate?: boolean;
    /**
     * When a user create transaction has completed
     */
    userCreateComplete?: boolean;
    /**
     * When a user is deactivated
     */
    userDeactivate?: boolean;
    /**
     * When a user is deleted
     */
    userDelete?: boolean;
    /**
     * When a user delete transaction has completed
     */
    userDeleteComplete?: boolean;
    /**
     * When a user updates their email address
     */
    userEmailUpdate?: boolean;
    /**
     * When a user verifies their email address
     */
    userEmailVerified?: boolean;
    /**
     * When a user is linked to an identity provider
     */
    userIdentityProviderLink?: boolean;
    /**
     * When a link to an identity provider is removed
     */
    userIdentityProviderUnlink?: boolean;
    /**
     * When a user fails a login request
     */
    userLoginFailed?: boolean;
    /**
     * When a request to create a user with a login Id (email or username) which is already in use has been received
     */
    userLoginIdDuplicateCreate?: boolean;
    /**
     * When a request to update a user and change their login Id (email or username) to one that is already in use has been received
     */
    userLoginIdDuplicateUpdate?: boolean;
    /**
     * When a user begins a login request with a new device
     */
    userLoginNewDevice?: boolean;
    /**
     * When a user completes a login request
     */
    userLoginSuccess?: boolean;
    /**
     * When a user logs in and is considered to be a potential threat
     */
    userLoginSuspicious?: boolean;
    /**
     * When Reactor detects a user is using a potentially breached password (requires an activated license)
     */
    userPasswordBreach?: boolean;
    /**
     * When a forgot password email has been sent to a user
     */
    userPasswordResetSend?: boolean;
    /**
     * When the process to reset a user password has started
     */
    userPasswordResetStart?: boolean;
    /**
     * When a user has successfully reset their password
     */
    userPasswordResetSuccess?: boolean;
    /**
     * When a user has updated their password
     */
    userPasswordUpdate?: boolean;
    /**
     * When a user is reactivated
     */
    userReactivate?: boolean;
    /**
     * When a user registration is created
     */
    userRegistrationCreate?: boolean;
    /**
     * When a user registration create transaction has completed
     */
    userRegistrationCreateComplete?: boolean;
    /**
     * When a user registration is deleted
     */
    userRegistrationDelete?: boolean;
    /**
     * When a user registration delete transaction has completed
     */
    userRegistrationDeleteComplete?: boolean;
    /**
     * When a user registration is updated
     */
    userRegistrationUpdate?: boolean;
    /**
     * When a user registration update transaction has completed
     */
    userRegistrationUpdateComplete?: boolean;
    /**
     * When a user completes registration verification
     */
    userRegistrationVerified?: boolean;
    /**
     * When a user has added a two-factor method
     */
    userTwoFactorMethodAdd?: boolean;
    /**
     * When a user has removed a two-factor method
     */
    userTwoFactorMethodRemove?: boolean;
    /**
     * When a user is updated
     */
    userUpdate?: boolean;
    /**
     * When a user update transaction has completed
     */
    userUpdateComplete?: boolean;
}

export interface GetFormFieldValidator {
    /**
     * Determines if user input should be validated.
     */
    enabled?: boolean;
    /**
     * A regular expression used to validate user input. Must be a valid regular expression pattern.
     */
    expression?: string;
}

export interface GetFormStep {
    fields: string[];
}

