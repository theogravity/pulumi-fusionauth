# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'FusionAuthApiKeyPermissionsEndpointArgs',
    'FusionAuthApplicationAccessControlConfigurationArgs',
    'FusionAuthApplicationCleanSpeakConfigurationArgs',
    'FusionAuthApplicationCleanSpeakConfigurationUsernameModerationArgs',
    'FusionAuthApplicationEmailConfigurationArgs',
    'FusionAuthApplicationFormConfigurationArgs',
    'FusionAuthApplicationJwtConfigurationArgs',
    'FusionAuthApplicationLambdaConfigurationArgs',
    'FusionAuthApplicationLoginConfigurationArgs',
    'FusionAuthApplicationMultiFactorConfigurationArgs',
    'FusionAuthApplicationOauthConfigurationArgs',
    'FusionAuthApplicationRegistrationConfigurationArgs',
    'FusionAuthApplicationRegistrationConfigurationBirthDateArgs',
    'FusionAuthApplicationRegistrationConfigurationFirstNameArgs',
    'FusionAuthApplicationRegistrationConfigurationFullNameArgs',
    'FusionAuthApplicationRegistrationConfigurationLastNameArgs',
    'FusionAuthApplicationRegistrationConfigurationMiddleNameArgs',
    'FusionAuthApplicationRegistrationConfigurationMobilePhoneArgs',
    'FusionAuthApplicationRegistrationDeletePolicyArgs',
    'FusionAuthApplicationSamlv2ConfigurationArgs',
    'FusionAuthApplicationSamlv2ConfigurationLogoutArgs',
    'FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogoutArgs',
    'FusionAuthEntityTypeJwtConfigurationArgs',
    'FusionAuthFormFieldValidatorArgs',
    'FusionAuthFormStepArgs',
    'FusionAuthIdpAppleApplicationConfigurationArgs',
    'FusionAuthIdpAppleTenantConfigurationArgs',
    'FusionAuthIdpExternalJwtApplicationConfigurationArgs',
    'FusionAuthIdpExternalJwtTenantConfigurationArgs',
    'FusionAuthIdpFacebookApplicationConfigurationArgs',
    'FusionAuthIdpFacebookTenantConfigurationArgs',
    'FusionAuthIdpGoogleApplicationConfigurationArgs',
    'FusionAuthIdpGoogleTenantConfigurationArgs',
    'FusionAuthIdpLinkedInApplicationConfigurationArgs',
    'FusionAuthIdpLinkedInTenantConfigurationArgs',
    'FusionAuthIdpOpenIdConnectApplicationConfigurationArgs',
    'FusionAuthIdpOpenIdConnectTenantConfigurationArgs',
    'FusionAuthIdpPsnApplicationConfigurationArgs',
    'FusionAuthIdpPsnTenantConfigurationArgs',
    'FusionAuthIdpSamlV2IdpInitiatedApplicationConfigurationArgs',
    'FusionAuthIdpSamlV2IdpInitiatedTenantConfigurationArgs',
    'FusionAuthIdpSamlv2ApplicationConfigurationArgs',
    'FusionAuthIdpSamlv2TenantConfigurationArgs',
    'FusionAuthIdpSteamApplicationConfigurationArgs',
    'FusionAuthIdpSteamTenantConfigurationArgs',
    'FusionAuthIdpTwitchApplicationConfigurationArgs',
    'FusionAuthIdpTwitchTenantConfigurationArgs',
    'FusionAuthIdpXBoxApplicationConfigurationArgs',
    'FusionAuthIdpXBoxTenantConfigurationArgs',
    'FusionAuthSystemConfigurationAuditLogConfigurationArgs',
    'FusionAuthSystemConfigurationAuditLogConfigurationDeleteArgs',
    'FusionAuthSystemConfigurationCorsConfigurationArgs',
    'FusionAuthSystemConfigurationEventLogConfigurationArgs',
    'FusionAuthSystemConfigurationLoginRecordConfigurationArgs',
    'FusionAuthSystemConfigurationLoginRecordConfigurationDeleteArgs',
    'FusionAuthSystemConfigurationUiConfigurationArgs',
    'FusionAuthTenantAccessControlConfigurationArgs',
    'FusionAuthTenantCaptchaConfigurationArgs',
    'FusionAuthTenantConnectorPolicyArgs',
    'FusionAuthTenantEmailConfigurationArgs',
    'FusionAuthTenantEmailConfigurationUnverifiedArgs',
    'FusionAuthTenantEventConfigurationArgs',
    'FusionAuthTenantExternalIdentifierConfigurationArgs',
    'FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGeneratorArgs',
    'FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGeneratorArgs',
    'FusionAuthTenantFailedAuthenticationConfigurationArgs',
    'FusionAuthTenantFamilyConfigurationArgs',
    'FusionAuthTenantFormConfigurationArgs',
    'FusionAuthTenantJwtConfigurationArgs',
    'FusionAuthTenantLoginConfigurationArgs',
    'FusionAuthTenantMaximumPasswordAgeArgs',
    'FusionAuthTenantMinimumPasswordAgeArgs',
    'FusionAuthTenantMultiFactorConfigurationArgs',
    'FusionAuthTenantMultiFactorConfigurationAuthenticatorArgs',
    'FusionAuthTenantMultiFactorConfigurationEmailArgs',
    'FusionAuthTenantMultiFactorConfigurationSmsArgs',
    'FusionAuthTenantOauthConfigurationArgs',
    'FusionAuthTenantPasswordEncryptionConfigurationArgs',
    'FusionAuthTenantPasswordValidationRulesArgs',
    'FusionAuthTenantPasswordValidationRulesBreachDetectionArgs',
    'FusionAuthTenantPasswordValidationRulesRememberPreviousPasswordsArgs',
    'FusionAuthTenantRateLimitConfigurationArgs',
    'FusionAuthTenantRateLimitConfigurationFailedLoginArgs',
    'FusionAuthTenantRateLimitConfigurationForgotPasswordArgs',
    'FusionAuthTenantRateLimitConfigurationSendEmailVerificationArgs',
    'FusionAuthTenantRateLimitConfigurationSendPasswordlessArgs',
    'FusionAuthTenantRateLimitConfigurationSendRegistrationVerificationArgs',
    'FusionAuthTenantRateLimitConfigurationSendTwoFactorArgs',
    'FusionAuthTenantRegistrationConfigurationArgs',
    'FusionAuthTenantUserDeletePolicyArgs',
    'FusionAuthTenantUsernameConfigurationArgs',
    'FusionAuthTenantUsernameConfigurationUniqueArgs',
    'FusionAuthUserActionOptionArgs',
    'FusionAuthUserTwoFactorMethodArgs',
    'FusionAuthWebhookEventsEnabledArgs',
    'GetFormFieldValidatorArgs',
    'GetFormStepArgs',
]

@pulumi.input_type
class FusionAuthApiKeyPermissionsEndpointArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 delete: Optional[pulumi.Input[bool]] = None,
                 get: Optional[pulumi.Input[bool]] = None,
                 patch: Optional[pulumi.Input[bool]] = None,
                 post: Optional[pulumi.Input[bool]] = None,
                 put: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] delete: HTTP DELETE Verb.
        :param pulumi.Input[bool] get: HTTP GET Verb.
        :param pulumi.Input[bool] patch: HTTP PATCH Verb
        :param pulumi.Input[bool] post: HTTP POST Verb
        :param pulumi.Input[bool] put: HTTP PUT Verb
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if get is not None:
            pulumi.set(__self__, "get", get)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if put is not None:
            pulumi.set(__self__, "put", put)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        HTTP DELETE Verb.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def get(self) -> Optional[pulumi.Input[bool]]:
        """
        HTTP GET Verb.
        """
        return pulumi.get(self, "get")

    @get.setter
    def get(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "get", value)

    @property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input[bool]]:
        """
        HTTP PATCH Verb
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "patch", value)

    @property
    @pulumi.getter
    def post(self) -> Optional[pulumi.Input[bool]]:
        """
        HTTP POST Verb
        """
        return pulumi.get(self, "post")

    @post.setter
    def post(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "post", value)

    @property
    @pulumi.getter
    def put(self) -> Optional[pulumi.Input[bool]]:
        """
        HTTP PUT Verb
        """
        return pulumi.get(self, "put")

    @put.setter
    def put(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "put", value)


@pulumi.input_type
class FusionAuthApplicationAccessControlConfigurationArgs:
    def __init__(__self__, *,
                 ui_ip_access_control_list_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ui_ip_access_control_list_id: The Id of the IP Access Control List limiting access to this application.
        """
        if ui_ip_access_control_list_id is not None:
            pulumi.set(__self__, "ui_ip_access_control_list_id", ui_ip_access_control_list_id)

    @property
    @pulumi.getter(name="uiIpAccessControlListId")
    def ui_ip_access_control_list_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the IP Access Control List limiting access to this application.
        """
        return pulumi.get(self, "ui_ip_access_control_list_id")

    @ui_ip_access_control_list_id.setter
    def ui_ip_access_control_list_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_ip_access_control_list_id", value)


@pulumi.input_type
class FusionAuthApplicationCleanSpeakConfigurationArgs:
    def __init__(__self__, *,
                 application_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 username_moderation: Optional[pulumi.Input['FusionAuthApplicationCleanSpeakConfigurationUsernameModerationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_ids: An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.
        """
        if application_ids is not None:
            pulumi.set(__self__, "application_ids", application_ids)
        if username_moderation is not None:
            pulumi.set(__self__, "username_moderation", username_moderation)

    @property
    @pulumi.getter(name="applicationIds")
    def application_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.
        """
        return pulumi.get(self, "application_ids")

    @application_ids.setter
    def application_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_ids", value)

    @property
    @pulumi.getter(name="usernameModeration")
    def username_moderation(self) -> Optional[pulumi.Input['FusionAuthApplicationCleanSpeakConfigurationUsernameModerationArgs']]:
        return pulumi.get(self, "username_moderation")

    @username_moderation.setter
    def username_moderation(self, value: Optional[pulumi.Input['FusionAuthApplicationCleanSpeakConfigurationUsernameModerationArgs']]):
        pulumi.set(self, "username_moderation", value)


@pulumi.input_type
class FusionAuthApplicationCleanSpeakConfigurationUsernameModerationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] application_id: The Id of the CleanSpeak application that usernames are sent to for moderation.
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the CleanSpeak application that usernames are sent to for moderation.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthApplicationEmailConfigurationArgs:
    def __init__(__self__, *,
                 email_update_template_id: Optional[pulumi.Input[str]] = None,
                 email_verification_template_id: Optional[pulumi.Input[str]] = None,
                 email_verified_template_id: Optional[pulumi.Input[str]] = None,
                 forgot_password_template_id: Optional[pulumi.Input[str]] = None,
                 login_id_in_use_on_create_template_id: Optional[pulumi.Input[str]] = None,
                 login_id_in_use_on_update_template_id: Optional[pulumi.Input[str]] = None,
                 login_new_device_template_id: Optional[pulumi.Input[str]] = None,
                 login_suspicious_template_id: Optional[pulumi.Input[str]] = None,
                 password_reset_success_template_id: Optional[pulumi.Input[str]] = None,
                 password_update_template_id: Optional[pulumi.Input[str]] = None,
                 passwordless_email_template_id: Optional[pulumi.Input[str]] = None,
                 set_password_email_template_id: Optional[pulumi.Input[str]] = None,
                 two_factor_method_add_template_id: Optional[pulumi.Input[str]] = None,
                 two_factor_method_remove_template_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email_update_template_id: The Id of the Email Template used to send emails to users when their email address is updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] email_verification_template_id: The Id of the Email Template used to send emails to users to verify that their email address is valid. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] email_verified_template_id: The Id of the Email Template used to verify user emails. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] forgot_password_template_id: The Id of the Email Template that is used when a user is sent a forgot password email. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] login_id_in_use_on_create_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] login_id_in_use_on_update_template_id: The Id of the Email Template used to send emails to users when another user attempts to update an existing account to use their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] login_new_device_template_id: The Id of the Email Template used to send emails to users when they log in on a new device. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] login_suspicious_template_id: The Id of the Email Template used to send emails to users when a suspicious login occurs. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] password_reset_success_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been reset. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] password_update_template_id: The Id of the Email Template used to send emails to users when their password has been updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] passwordless_email_template_id: The Id of the Passwordless Email Template, sent to users when they start a passwordless login. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] set_password_email_template_id: The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] two_factor_method_add_template_id: The Id of the Email Template used to send emails to users when a MFA method has been added to their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param pulumi.Input[str] two_factor_method_remove_template_id: The Id of the Email Template used to send emails to users when a MFA method has been removed from their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        if email_update_template_id is not None:
            pulumi.set(__self__, "email_update_template_id", email_update_template_id)
        if email_verification_template_id is not None:
            pulumi.set(__self__, "email_verification_template_id", email_verification_template_id)
        if email_verified_template_id is not None:
            pulumi.set(__self__, "email_verified_template_id", email_verified_template_id)
        if forgot_password_template_id is not None:
            pulumi.set(__self__, "forgot_password_template_id", forgot_password_template_id)
        if login_id_in_use_on_create_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_create_template_id", login_id_in_use_on_create_template_id)
        if login_id_in_use_on_update_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_update_template_id", login_id_in_use_on_update_template_id)
        if login_new_device_template_id is not None:
            pulumi.set(__self__, "login_new_device_template_id", login_new_device_template_id)
        if login_suspicious_template_id is not None:
            pulumi.set(__self__, "login_suspicious_template_id", login_suspicious_template_id)
        if password_reset_success_template_id is not None:
            pulumi.set(__self__, "password_reset_success_template_id", password_reset_success_template_id)
        if password_update_template_id is not None:
            pulumi.set(__self__, "password_update_template_id", password_update_template_id)
        if passwordless_email_template_id is not None:
            pulumi.set(__self__, "passwordless_email_template_id", passwordless_email_template_id)
        if set_password_email_template_id is not None:
            pulumi.set(__self__, "set_password_email_template_id", set_password_email_template_id)
        if two_factor_method_add_template_id is not None:
            pulumi.set(__self__, "two_factor_method_add_template_id", two_factor_method_add_template_id)
        if two_factor_method_remove_template_id is not None:
            pulumi.set(__self__, "two_factor_method_remove_template_id", two_factor_method_remove_template_id)

    @property
    @pulumi.getter(name="emailUpdateTemplateId")
    def email_update_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when their email address is updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_update_template_id")

    @email_update_template_id.setter
    def email_update_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_update_template_id", value)

    @property
    @pulumi.getter(name="emailVerificationTemplateId")
    def email_verification_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users to verify that their email address is valid. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_verification_template_id")

    @email_verification_template_id.setter
    def email_verification_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_verification_template_id", value)

    @property
    @pulumi.getter(name="emailVerifiedTemplateId")
    def email_verified_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to verify user emails. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_verified_template_id")

    @email_verified_template_id.setter
    def email_verified_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_verified_template_id", value)

    @property
    @pulumi.getter(name="forgotPasswordTemplateId")
    def forgot_password_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "forgot_password_template_id")

    @forgot_password_template_id.setter
    def forgot_password_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forgot_password_template_id", value)

    @property
    @pulumi.getter(name="loginIdInUseOnCreateTemplateId")
    def login_id_in_use_on_create_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_id_in_use_on_create_template_id")

    @login_id_in_use_on_create_template_id.setter
    def login_id_in_use_on_create_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_id_in_use_on_create_template_id", value)

    @property
    @pulumi.getter(name="loginIdInUseOnUpdateTemplateId")
    def login_id_in_use_on_update_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to update an existing account to use their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_id_in_use_on_update_template_id")

    @login_id_in_use_on_update_template_id.setter
    def login_id_in_use_on_update_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_id_in_use_on_update_template_id", value)

    @property
    @pulumi.getter(name="loginNewDeviceTemplateId")
    def login_new_device_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when they log in on a new device. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_new_device_template_id")

    @login_new_device_template_id.setter
    def login_new_device_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_new_device_template_id", value)

    @property
    @pulumi.getter(name="loginSuspiciousTemplateId")
    def login_suspicious_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a suspicious login occurs. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_suspicious_template_id")

    @login_suspicious_template_id.setter
    def login_suspicious_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_suspicious_template_id", value)

    @property
    @pulumi.getter(name="passwordResetSuccessTemplateId")
    def password_reset_success_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been reset. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "password_reset_success_template_id")

    @password_reset_success_template_id.setter
    def password_reset_success_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_reset_success_template_id", value)

    @property
    @pulumi.getter(name="passwordUpdateTemplateId")
    def password_update_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when their password has been updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "password_update_template_id")

    @password_update_template_id.setter
    def password_update_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_update_template_id", value)

    @property
    @pulumi.getter(name="passwordlessEmailTemplateId")
    def passwordless_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Passwordless Email Template, sent to users when they start a passwordless login. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "passwordless_email_template_id")

    @passwordless_email_template_id.setter
    def passwordless_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passwordless_email_template_id", value)

    @property
    @pulumi.getter(name="setPasswordEmailTemplateId")
    def set_password_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "set_password_email_template_id")

    @set_password_email_template_id.setter
    def set_password_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_password_email_template_id", value)

    @property
    @pulumi.getter(name="twoFactorMethodAddTemplateId")
    def two_factor_method_add_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been added to their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "two_factor_method_add_template_id")

    @two_factor_method_add_template_id.setter
    def two_factor_method_add_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "two_factor_method_add_template_id", value)

    @property
    @pulumi.getter(name="twoFactorMethodRemoveTemplateId")
    def two_factor_method_remove_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been removed from their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "two_factor_method_remove_template_id")

    @two_factor_method_remove_template_id.setter
    def two_factor_method_remove_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "two_factor_method_remove_template_id", value)


@pulumi.input_type
class FusionAuthApplicationFormConfigurationArgs:
    def __init__(__self__, *,
                 admin_registration_form_id: Optional[pulumi.Input[str]] = None,
                 self_service_form_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_registration_form_id: The unique Id of the form to use for the Add and Edit User Registration form when used in the FusionAuth admin UI.
        :param pulumi.Input[str] self_service_form_id: The unique Id of the form to to enable authenticated users to manage their profile on the account page.
        """
        if admin_registration_form_id is not None:
            pulumi.set(__self__, "admin_registration_form_id", admin_registration_form_id)
        if self_service_form_id is not None:
            pulumi.set(__self__, "self_service_form_id", self_service_form_id)

    @property
    @pulumi.getter(name="adminRegistrationFormId")
    def admin_registration_form_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the form to use for the Add and Edit User Registration form when used in the FusionAuth admin UI.
        """
        return pulumi.get(self, "admin_registration_form_id")

    @admin_registration_form_id.setter
    def admin_registration_form_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_registration_form_id", value)

    @property
    @pulumi.getter(name="selfServiceFormId")
    def self_service_form_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the form to to enable authenticated users to manage their profile on the account page.
        """
        return pulumi.get(self, "self_service_form_id")

    @self_service_form_id.setter
    def self_service_form_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "self_service_form_id", value)


@pulumi.input_type
class FusionAuthApplicationJwtConfigurationArgs:
    def __init__(__self__, *,
                 access_token_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id_token_key_id: Optional[pulumi.Input[str]] = None,
                 refresh_token_ttl_minutes: Optional[pulumi.Input[int]] = None,
                 ttl_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_token_id: The Id of the signing key used to sign the access token.
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param pulumi.Input[str] id_token_key_id: The Id of the signing key used to sign the Id token.
        :param pulumi.Input[int] refresh_token_ttl_minutes: The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT.
        :param pulumi.Input[int] ttl_seconds: The length of time in seconds the JWT will live before it is expired and no longer valid.
        """
        if access_token_id is not None:
            pulumi.set(__self__, "access_token_id", access_token_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id_token_key_id is not None:
            pulumi.set(__self__, "id_token_key_id", id_token_key_id)
        if refresh_token_ttl_minutes is not None:
            pulumi.set(__self__, "refresh_token_ttl_minutes", refresh_token_ttl_minutes)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @property
    @pulumi.getter(name="accessTokenId")
    def access_token_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the signing key used to sign the access token.
        """
        return pulumi.get(self, "access_token_id")

    @access_token_id.setter
    def access_token_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idTokenKeyId")
    def id_token_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the signing key used to sign the Id token.
        """
        return pulumi.get(self, "id_token_key_id")

    @id_token_key_id.setter
    def id_token_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id_token_key_id", value)

    @property
    @pulumi.getter(name="refreshTokenTtlMinutes")
    def refresh_token_ttl_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT.
        """
        return pulumi.get(self, "refresh_token_ttl_minutes")

    @refresh_token_ttl_minutes.setter
    def refresh_token_ttl_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_token_ttl_minutes", value)

    @property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time in seconds the JWT will live before it is expired and no longer valid.
        """
        return pulumi.get(self, "ttl_seconds")

    @ttl_seconds.setter
    def ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl_seconds", value)


@pulumi.input_type
class FusionAuthApplicationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 access_token_populate_id: Optional[pulumi.Input[str]] = None,
                 id_token_populate_id: Optional[pulumi.Input[str]] = None,
                 samlv2_populate_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token_populate_id: The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API.
        :param pulumi.Input[str] id_token_populate_id: The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request.
        :param pulumi.Input[str] samlv2_populate_id: The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request.
        """
        if access_token_populate_id is not None:
            pulumi.set(__self__, "access_token_populate_id", access_token_populate_id)
        if id_token_populate_id is not None:
            pulumi.set(__self__, "id_token_populate_id", id_token_populate_id)
        if samlv2_populate_id is not None:
            pulumi.set(__self__, "samlv2_populate_id", samlv2_populate_id)

    @property
    @pulumi.getter(name="accessTokenPopulateId")
    def access_token_populate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API.
        """
        return pulumi.get(self, "access_token_populate_id")

    @access_token_populate_id.setter
    def access_token_populate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_populate_id", value)

    @property
    @pulumi.getter(name="idTokenPopulateId")
    def id_token_populate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request.
        """
        return pulumi.get(self, "id_token_populate_id")

    @id_token_populate_id.setter
    def id_token_populate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id_token_populate_id", value)

    @property
    @pulumi.getter(name="samlv2PopulateId")
    def samlv2_populate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request.
        """
        return pulumi.get(self, "samlv2_populate_id")

    @samlv2_populate_id.setter
    def samlv2_populate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samlv2_populate_id", value)


@pulumi.input_type
class FusionAuthApplicationLoginConfigurationArgs:
    def __init__(__self__, *,
                 allow_token_refresh: Optional[pulumi.Input[bool]] = None,
                 generate_refresh_tokens: Optional[pulumi.Input[bool]] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_token_refresh: Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.
        :param pulumi.Input[bool] generate_refresh_tokens: Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        :param pulumi.Input[bool] require_authentication: Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.
        """
        if allow_token_refresh is not None:
            pulumi.set(__self__, "allow_token_refresh", allow_token_refresh)
        if generate_refresh_tokens is not None:
            pulumi.set(__self__, "generate_refresh_tokens", generate_refresh_tokens)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)

    @property
    @pulumi.getter(name="allowTokenRefresh")
    def allow_token_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.
        """
        return pulumi.get(self, "allow_token_refresh")

    @allow_token_refresh.setter
    def allow_token_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_token_refresh", value)

    @property
    @pulumi.getter(name="generateRefreshTokens")
    def generate_refresh_tokens(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        """
        return pulumi.get(self, "generate_refresh_tokens")

    @generate_refresh_tokens.setter
    def generate_refresh_tokens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_refresh_tokens", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)


@pulumi.input_type
class FusionAuthApplicationMultiFactorConfigurationArgs:
    def __init__(__self__, *,
                 email_template_id: Optional[pulumi.Input[str]] = None,
                 login_policy: Optional[pulumi.Input[str]] = None,
                 sms_template_id: Optional[pulumi.Input[str]] = None,
                 trust_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email_template_id: The Id of the email template that is used when notifying a user to complete a multi-factor authentication request.
        :param pulumi.Input[str] login_policy: When enabled and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When disabled, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When required, the user will be required to complete a two-factor challenge during login. Possible values are `Enabled`, `Disabled` or `Required`.
        :param pulumi.Input[str] sms_template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        :param pulumi.Input[str] trust_policy: When `multi_factor_configuration.login_policy` is set to `Enabled`, this trust policy is utilized when determining if a user must complete a two-factor challenge during login. Possible values are `Any`, `This` or `None`.
        """
        if email_template_id is not None:
            pulumi.set(__self__, "email_template_id", email_template_id)
        if login_policy is not None:
            pulumi.set(__self__, "login_policy", login_policy)
        if sms_template_id is not None:
            pulumi.set(__self__, "sms_template_id", sms_template_id)
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="emailTemplateId")
    def email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the email template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "email_template_id")

    @email_template_id.setter
    def email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_template_id", value)

    @property
    @pulumi.getter(name="loginPolicy")
    def login_policy(self) -> Optional[pulumi.Input[str]]:
        """
        When enabled and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When disabled, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When required, the user will be required to complete a two-factor challenge during login. Possible values are `Enabled`, `Disabled` or `Required`.
        """
        return pulumi.get(self, "login_policy")

    @login_policy.setter
    def login_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_policy", value)

    @property
    @pulumi.getter(name="smsTemplateId")
    def sms_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "sms_template_id")

    @sms_template_id.setter
    def sms_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sms_template_id", value)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[pulumi.Input[str]]:
        """
        When `multi_factor_configuration.login_policy` is set to `Enabled`, this trust policy is utilized when determining if a user must complete a two-factor challenge during login. Possible values are `Any`, `This` or `None`.
        """
        return pulumi.get(self, "trust_policy")

    @trust_policy.setter
    def trust_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trust_policy", value)


@pulumi.input_type
class FusionAuthApplicationOauthConfigurationArgs:
    def __init__(__self__, *,
                 authorized_origin_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 authorized_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 authorized_url_validation_policy: Optional[pulumi.Input[str]] = None,
                 client_authentication_policy: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 debug: Optional[pulumi.Input[bool]] = None,
                 device_verification_url: Optional[pulumi.Input[str]] = None,
                 enabled_grants: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 generate_refresh_tokens: Optional[pulumi.Input[bool]] = None,
                 logout_behavior: Optional[pulumi.Input[str]] = None,
                 logout_url: Optional[pulumi.Input[str]] = None,
                 proof_key_for_code_exchange_policy: Optional[pulumi.Input[str]] = None,
                 require_client_authentication: Optional[pulumi.Input[bool]] = None,
                 require_registration: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_origin_urls: An array of URLs that are the authorized origins for FusionAuth OAuth.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_redirect_urls: An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        :param pulumi.Input[str] authorized_url_validation_policy: Determines whether wildcard expressions will be allowed in the authorized_redirect_urls and authorized_origin_urls.
        :param pulumi.Input[str] client_authentication_policy: Determines the client authentication requirements for the OAuth 2.0 Token endpoint.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored.
        :param pulumi.Input[bool] debug: Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        :param pulumi.Input[str] device_verification_url: The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enabled_grants: The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.
        :param pulumi.Input[bool] generate_refresh_tokens: Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        :param pulumi.Input[str] logout_behavior: Behavior when /oauth2/logout is called.
        :param pulumi.Input[str] logout_url: The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        :param pulumi.Input[str] proof_key_for_code_exchange_policy: Determines the PKCE requirements when using the authorization code grant.
        :param pulumi.Input[bool] require_client_authentication: Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data.
        :param pulumi.Input[bool] require_registration: When enabled the user will be required to be registered, or complete registration before redirecting to the configured callback in the authorization code grant or the implicit grant. This configuration does not currently apply to any other grant.
        """
        if authorized_origin_urls is not None:
            pulumi.set(__self__, "authorized_origin_urls", authorized_origin_urls)
        if authorized_redirect_urls is not None:
            pulumi.set(__self__, "authorized_redirect_urls", authorized_redirect_urls)
        if authorized_url_validation_policy is not None:
            pulumi.set(__self__, "authorized_url_validation_policy", authorized_url_validation_policy)
        if client_authentication_policy is not None:
            pulumi.set(__self__, "client_authentication_policy", client_authentication_policy)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if device_verification_url is not None:
            pulumi.set(__self__, "device_verification_url", device_verification_url)
        if enabled_grants is not None:
            pulumi.set(__self__, "enabled_grants", enabled_grants)
        if generate_refresh_tokens is not None:
            pulumi.set(__self__, "generate_refresh_tokens", generate_refresh_tokens)
        if logout_behavior is not None:
            pulumi.set(__self__, "logout_behavior", logout_behavior)
        if logout_url is not None:
            pulumi.set(__self__, "logout_url", logout_url)
        if proof_key_for_code_exchange_policy is not None:
            pulumi.set(__self__, "proof_key_for_code_exchange_policy", proof_key_for_code_exchange_policy)
        if require_client_authentication is not None:
            warnings.warn("""In version 1.28.0 and beyond, client authentication can be managed via oauth_configuration.client_authentication_policy.""", DeprecationWarning)
            pulumi.log.warn("""require_client_authentication is deprecated: In version 1.28.0 and beyond, client authentication can be managed via oauth_configuration.client_authentication_policy.""")
        if require_client_authentication is not None:
            pulumi.set(__self__, "require_client_authentication", require_client_authentication)
        if require_registration is not None:
            pulumi.set(__self__, "require_registration", require_registration)

    @property
    @pulumi.getter(name="authorizedOriginUrls")
    def authorized_origin_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of URLs that are the authorized origins for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_origin_urls")

    @authorized_origin_urls.setter
    def authorized_origin_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "authorized_origin_urls", value)

    @property
    @pulumi.getter(name="authorizedRedirectUrls")
    def authorized_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_redirect_urls")

    @authorized_redirect_urls.setter
    def authorized_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "authorized_redirect_urls", value)

    @property
    @pulumi.getter(name="authorizedUrlValidationPolicy")
    def authorized_url_validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether wildcard expressions will be allowed in the authorized_redirect_urls and authorized_origin_urls.
        """
        return pulumi.get(self, "authorized_url_validation_policy")

    @authorized_url_validation_policy.setter
    def authorized_url_validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorized_url_validation_policy", value)

    @property
    @pulumi.getter(name="clientAuthenticationPolicy")
    def client_authentication_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the client authentication requirements for the OAuth 2.0 Token endpoint.
        """
        return pulumi.get(self, "client_authentication_policy")

    @client_authentication_policy.setter
    def client_authentication_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_authentication_policy", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="deviceVerificationUrl")
    def device_verification_url(self) -> Optional[pulumi.Input[str]]:
        """
        The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled.
        """
        return pulumi.get(self, "device_verification_url")

    @device_verification_url.setter
    def device_verification_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_verification_url", value)

    @property
    @pulumi.getter(name="enabledGrants")
    def enabled_grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.
        """
        return pulumi.get(self, "enabled_grants")

    @enabled_grants.setter
    def enabled_grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enabled_grants", value)

    @property
    @pulumi.getter(name="generateRefreshTokens")
    def generate_refresh_tokens(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        """
        return pulumi.get(self, "generate_refresh_tokens")

    @generate_refresh_tokens.setter
    def generate_refresh_tokens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_refresh_tokens", value)

    @property
    @pulumi.getter(name="logoutBehavior")
    def logout_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Behavior when /oauth2/logout is called.
        """
        return pulumi.get(self, "logout_behavior")

    @logout_behavior.setter
    def logout_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_behavior", value)

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        """
        return pulumi.get(self, "logout_url")

    @logout_url.setter
    def logout_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_url", value)

    @property
    @pulumi.getter(name="proofKeyForCodeExchangePolicy")
    def proof_key_for_code_exchange_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the PKCE requirements when using the authorization code grant.
        """
        return pulumi.get(self, "proof_key_for_code_exchange_policy")

    @proof_key_for_code_exchange_policy.setter
    def proof_key_for_code_exchange_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proof_key_for_code_exchange_policy", value)

    @property
    @pulumi.getter(name="requireClientAuthentication")
    def require_client_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data.
        """
        return pulumi.get(self, "require_client_authentication")

    @require_client_authentication.setter
    def require_client_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_client_authentication", value)

    @property
    @pulumi.getter(name="requireRegistration")
    def require_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled the user will be required to be registered, or complete registration before redirecting to the configured callback in the authorization code grant or the implicit grant. This configuration does not currently apply to any other grant.
        """
        return pulumi.get(self, "require_registration")

    @require_registration.setter
    def require_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_registration", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationArgs:
    def __init__(__self__, *,
                 birth_date: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationBirthDateArgs']] = None,
                 confirm_password: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 first_name: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFirstNameArgs']] = None,
                 form_id: Optional[pulumi.Input[str]] = None,
                 full_name: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFullNameArgs']] = None,
                 last_name: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationLastNameArgs']] = None,
                 login_id_type: Optional[pulumi.Input[str]] = None,
                 middle_name: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMiddleNameArgs']] = None,
                 mobile_phone: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMobilePhoneArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param pulumi.Input[str] form_id: The Id of an associated Form when using advanced registration configuration type. This field is required when application.registrationConfiguration.type is set to advanced.
        :param pulumi.Input[str] login_id_type: The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique.
        :param pulumi.Input[str] type: The type of registration flow.
        """
        if birth_date is not None:
            pulumi.set(__self__, "birth_date", birth_date)
        if confirm_password is not None:
            pulumi.set(__self__, "confirm_password", confirm_password)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if form_id is not None:
            pulumi.set(__self__, "form_id", form_id)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if login_id_type is not None:
            pulumi.set(__self__, "login_id_type", login_id_type)
        if middle_name is not None:
            pulumi.set(__self__, "middle_name", middle_name)
        if mobile_phone is not None:
            pulumi.set(__self__, "mobile_phone", mobile_phone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="birthDate")
    def birth_date(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationBirthDateArgs']]:
        return pulumi.get(self, "birth_date")

    @birth_date.setter
    def birth_date(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationBirthDateArgs']]):
        pulumi.set(self, "birth_date", value)

    @property
    @pulumi.getter(name="confirmPassword")
    def confirm_password(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "confirm_password")

    @confirm_password.setter
    def confirm_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "confirm_password", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFirstNameArgs']]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFirstNameArgs']]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="formId")
    def form_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of an associated Form when using advanced registration configuration type. This field is required when application.registrationConfiguration.type is set to advanced.
        """
        return pulumi.get(self, "form_id")

    @form_id.setter
    def form_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "form_id", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFullNameArgs']]:
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationFullNameArgs']]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationLastNameArgs']]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationLastNameArgs']]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter(name="loginIdType")
    def login_id_type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique.
        """
        return pulumi.get(self, "login_id_type")

    @login_id_type.setter
    def login_id_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_id_type", value)

    @property
    @pulumi.getter(name="middleName")
    def middle_name(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMiddleNameArgs']]:
        return pulumi.get(self, "middle_name")

    @middle_name.setter
    def middle_name(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMiddleNameArgs']]):
        pulumi.set(self, "middle_name", value)

    @property
    @pulumi.getter(name="mobilePhone")
    def mobile_phone(self) -> Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMobilePhoneArgs']]:
        return pulumi.get(self, "mobile_phone")

    @mobile_phone.setter
    def mobile_phone(self, value: Optional[pulumi.Input['FusionAuthApplicationRegistrationConfigurationMobilePhoneArgs']]):
        pulumi.set(self, "mobile_phone", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of registration flow.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationBirthDateArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationFirstNameArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationFullNameArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationLastNameArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationMiddleNameArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationConfigurationMobilePhoneArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class FusionAuthApplicationRegistrationDeletePolicyArgs:
    def __init__(__self__, *,
                 unverified_enabled: Optional[pulumi.Input[bool]] = None,
                 unverified_number_of_days_to_retain: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] unverified_enabled: Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days.
        :param pulumi.Input[int] unverified_number_of_days_to_retain: The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0.
        """
        if unverified_enabled is not None:
            pulumi.set(__self__, "unverified_enabled", unverified_enabled)
        if unverified_number_of_days_to_retain is not None:
            pulumi.set(__self__, "unverified_number_of_days_to_retain", unverified_number_of_days_to_retain)

    @property
    @pulumi.getter(name="unverifiedEnabled")
    def unverified_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unverified_enabled")

    @unverified_enabled.setter
    def unverified_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unverified_enabled", value)

    @property
    @pulumi.getter(name="unverifiedNumberOfDaysToRetain")
    def unverified_number_of_days_to_retain(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0.
        """
        return pulumi.get(self, "unverified_number_of_days_to_retain")

    @unverified_number_of_days_to_retain.setter
    def unverified_number_of_days_to_retain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unverified_number_of_days_to_retain", value)


@pulumi.input_type
class FusionAuthApplicationSamlv2ConfigurationArgs:
    def __init__(__self__, *,
                 authorized_redirect_urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 issuer: pulumi.Input[str],
                 audience: Optional[pulumi.Input[str]] = None,
                 callback_url: Optional[pulumi.Input[str]] = None,
                 debug: Optional[pulumi.Input[bool]] = None,
                 default_verification_key_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 logout: Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutArgs']] = None,
                 logout_url: Optional[pulumi.Input[str]] = None,
                 required_signed_requests: Optional[pulumi.Input[bool]] = None,
                 xml_signature_canonicalization_method: Optional[pulumi.Input[str]] = None,
                 xml_signature_location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_redirect_urls: An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        :param pulumi.Input[str] issuer: The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login.
        :param pulumi.Input[str] audience: The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response.
        :param pulumi.Input[str] callback_url: The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML.
        :param pulumi.Input[bool] debug: Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        :param pulumi.Input[str] default_verification_key_id: The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param pulumi.Input[str] key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param pulumi.Input[str] logout_url: The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        :param pulumi.Input[bool] required_signed_requests: If set to true, will force verification through the key store.
        :param pulumi.Input[str] xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        :param pulumi.Input[str] xml_signature_location: The location to place the XML signature when signing a successful SAML response.
        """
        pulumi.set(__self__, "authorized_redirect_urls", authorized_redirect_urls)
        pulumi.set(__self__, "issuer", issuer)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if callback_url is not None:
            warnings.warn("""In version 1.20.0 and beyond, Callback URLs can be managed via authorized_redirect_urls.""", DeprecationWarning)
            pulumi.log.warn("""callback_url is deprecated: In version 1.20.0 and beyond, Callback URLs can be managed via authorized_redirect_urls.""")
        if callback_url is not None:
            pulumi.set(__self__, "callback_url", callback_url)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if default_verification_key_id is not None:
            pulumi.set(__self__, "default_verification_key_id", default_verification_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if logout is not None:
            pulumi.set(__self__, "logout", logout)
        if logout_url is not None:
            pulumi.set(__self__, "logout_url", logout_url)
        if required_signed_requests is not None:
            pulumi.set(__self__, "required_signed_requests", required_signed_requests)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)
        if xml_signature_location is not None:
            pulumi.set(__self__, "xml_signature_location", xml_signature_location)

    @property
    @pulumi.getter(name="authorizedRedirectUrls")
    def authorized_redirect_urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_redirect_urls")

    @authorized_redirect_urls.setter
    def authorized_redirect_urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "authorized_redirect_urls", value)

    @property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[str]:
        """
        The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[str]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML.
        """
        return pulumi.get(self, "callback_url")

    @callback_url.setter
    def callback_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "callback_url", value)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="defaultVerificationKeyId")
    def default_verification_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        """
        return pulumi.get(self, "default_verification_key_id")

    @default_verification_key_id.setter
    def default_verification_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_verification_key_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def logout(self) -> Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutArgs']]:
        return pulumi.get(self, "logout")

    @logout.setter
    def logout(self, value: Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutArgs']]):
        pulumi.set(self, "logout", value)

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        """
        return pulumi.get(self, "logout_url")

    @logout_url.setter
    def logout_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_url", value)

    @property
    @pulumi.getter(name="requiredSignedRequests")
    def required_signed_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, will force verification through the key store.
        """
        return pulumi.get(self, "required_signed_requests")

    @required_signed_requests.setter
    def required_signed_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_signed_requests", value)

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[pulumi.Input[str]]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")

    @xml_signature_canonicalization_method.setter
    def xml_signature_canonicalization_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "xml_signature_canonicalization_method", value)

    @property
    @pulumi.getter(name="xmlSignatureLocation")
    def xml_signature_location(self) -> Optional[pulumi.Input[str]]:
        """
        The location to place the XML signature when signing a successful SAML response.
        """
        return pulumi.get(self, "xml_signature_location")

    @xml_signature_location.setter
    def xml_signature_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "xml_signature_location", value)


@pulumi.input_type
class FusionAuthApplicationSamlv2ConfigurationLogoutArgs:
    def __init__(__self__, *,
                 behavior: Optional[pulumi.Input[str]] = None,
                 default_verification_key_id: Optional[pulumi.Input[str]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 require_signed_requests: Optional[pulumi.Input[bool]] = None,
                 single_logout: Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogoutArgs']] = None,
                 xml_signature_canonicalization_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] behavior: This configuration is functionally equivalent to the Logout Behavior found in the OAuth2 configuration.
        :param pulumi.Input[str] default_verification_key_id: The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        :param pulumi.Input[str] key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param pulumi.Input[bool] require_signed_requests: Set this parameter equal to true to require the SAML v2 Service Provider to sign the Logout request. When this value is true all Logout requests missing a signature will be rejected.
        :param pulumi.Input[str] xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if default_verification_key_id is not None:
            pulumi.set(__self__, "default_verification_key_id", default_verification_key_id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if require_signed_requests is not None:
            pulumi.set(__self__, "require_signed_requests", require_signed_requests)
        if single_logout is not None:
            pulumi.set(__self__, "single_logout", single_logout)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input[str]]:
        """
        This configuration is functionally equivalent to the Logout Behavior found in the OAuth2 configuration.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter(name="defaultVerificationKeyId")
    def default_verification_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        """
        return pulumi.get(self, "default_verification_key_id")

    @default_verification_key_id.setter
    def default_verification_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_verification_key_id", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="requireSignedRequests")
    def require_signed_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this parameter equal to true to require the SAML v2 Service Provider to sign the Logout request. When this value is true all Logout requests missing a signature will be rejected.
        """
        return pulumi.get(self, "require_signed_requests")

    @require_signed_requests.setter
    def require_signed_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_signed_requests", value)

    @property
    @pulumi.getter(name="singleLogout")
    def single_logout(self) -> Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogoutArgs']]:
        return pulumi.get(self, "single_logout")

    @single_logout.setter
    def single_logout(self, value: Optional[pulumi.Input['FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogoutArgs']]):
        pulumi.set(self, "single_logout", value)

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[pulumi.Input[str]]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")

    @xml_signature_canonicalization_method.setter
    def xml_signature_canonicalization_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "xml_signature_canonicalization_method", value)


@pulumi.input_type
class FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogoutArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 xml_signature_canonicalization_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param pulumi.Input[str] key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param pulumi.Input[str] url: The URL at which you want to receive the LogoutRequest from FusionAuth.
        :param pulumi.Input[str] xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL at which you want to receive the LogoutRequest from FusionAuth.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[pulumi.Input[str]]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")

    @xml_signature_canonicalization_method.setter
    def xml_signature_canonicalization_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "xml_signature_canonicalization_method", value)


@pulumi.input_type
class FusionAuthEntityTypeJwtConfigurationArgs:
    def __init__(__self__, *,
                 access_token_key_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 time_to_live_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_token_key_id: The unique ID of the signing key used to sign the access token. Required when
               enabled is set to true.
        :param pulumi.Input[bool] enabled: Indicates if this application is using the JWT configuration defined here or the global JWT
               configuration defined by the Tenant. If this is false the signing algorithm configured in the Tenant will be used.
               If true the signing algorithm defined in this application will be used.
        :param pulumi.Input[int] time_to_live_in_seconds: The length of time in seconds the JWT will live before it is expired and no
               longer valid. Required when enabled is set to true.
        """
        if access_token_key_id is not None:
            pulumi.set(__self__, "access_token_key_id", access_token_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_to_live_in_seconds is not None:
            pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)

    @property
    @pulumi.getter(name="accessTokenKeyId")
    def access_token_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID of the signing key used to sign the access token. Required when
        enabled is set to true.
        """
        return pulumi.get(self, "access_token_key_id")

    @access_token_key_id.setter
    def access_token_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_key_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if this application is using the JWT configuration defined here or the global JWT
        configuration defined by the Tenant. If this is false the signing algorithm configured in the Tenant will be used.
        If true the signing algorithm defined in this application will be used.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time in seconds the JWT will live before it is expired and no
        longer valid. Required when enabled is set to true.
        """
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_to_live_in_seconds", value)


@pulumi.input_type
class FusionAuthFormFieldValidatorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Determines if user input should be validated.
        :param pulumi.Input[str] expression: A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if user input should be validated.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class FusionAuthFormStepArgs:
    def __init__(__self__, *,
                 fields: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fields: An ordered list of Form Field Ids assigned to this step.
        """
        pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An ordered list of Form Field Ids assigned to this step.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "fields", value)


@pulumi.input_type
class FusionAuthIdpAppleApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_id: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 services_id: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] key_id: The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        :param pulumi.Input[str] scope: The top-level space separated scope that you are requesting from Apple.
        :param pulumi.Input[str] services_id: The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        :param pulumi.Input[str] team_id: The Apple App ID Prefix, or Team ID found in your Apple Developer Account which has been configured for Sign in with Apple.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if services_id is not None:
            pulumi.set(__self__, "services_id", services_id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level space separated scope that you are requesting from Apple.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="servicesId")
    def services_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        """
        return pulumi.get(self, "services_id")

    @services_id.setter
    def services_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_id", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Apple App ID Prefix, or Team ID found in your Apple Developer Account which has been configured for Sign in with Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)


@pulumi.input_type
class FusionAuthIdpAppleTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpExternalJwtApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthIdpExternalJwtTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpFacebookApplicationConfigurationArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fields: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] app_id: The top-level Facebook `appId` for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        :param pulumi.Input[str] application_id: ID of the FusionAuth Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_secret: The top-level client secret, also known as 'App Secret', to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        :param pulumi.Input[bool] create_registration: Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] fields: The top-level fields that you are requesting from Facebook.
               Field values are documented at [Facebook Graph API](https://developers.facebook.com/docs/graph-api/using-graph-api/)
        :param pulumi.Input[str] permissions: The top-level permissions that your application is asking of the user’s Facebook account.
               Permission values are documented at [Facebook Login API](https://developers.facebook.com/docs/permissions/reference)
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level Facebook `appId` for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the FusionAuth Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret, also known as 'App Secret', to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level fields that you are requesting from Facebook.
        Field values are documented at [Facebook Graph API](https://developers.facebook.com/docs/graph-api/using-graph-api/)
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level permissions that your application is asking of the user’s Facebook account.
        Permission values are documented at [Facebook Login API](https://developers.facebook.com/docs/permissions/reference)
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class FusionAuthIdpFacebookTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpGoogleApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account.
        :param pulumi.Input[str] client_secret: The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from Google.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from Google.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class FusionAuthIdpGoogleTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpLinkedInApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the FusionAuth Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: The top-level LinkedIn client id for your Application. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        :param pulumi.Input[str] client_secret: The top-level client secret to use with the LinkedIn Identity Provider when retrieving the long-lived token. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        :param pulumi.Input[bool] create_registration: Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from LinkedIn.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the FusionAuth Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level LinkedIn client id for your Application. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the LinkedIn Identity Provider when retrieving the long-lived token. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from LinkedIn.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class FusionAuthIdpLinkedInTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpOpenIdConnectApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_image_url: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 oauth2_client_id: Optional[pulumi.Input[str]] = None,
                 oauth2_client_secret: Optional[pulumi.Input[str]] = None,
                 oauth2_scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_image_url: The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] oauth2_client_id: The top-level client id for your Application.
        :param pulumi.Input[str] oauth2_client_secret: The top-level client secret to use with the OpenID Connect identity provider.
        :param pulumi.Input[str] oauth2_scope: The top-level scope that you are requesting from the OpenID Connect identity provider.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_image_url is not None:
            pulumi.set(__self__, "button_image_url", button_image_url)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if oauth2_client_id is not None:
            pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        if oauth2_client_secret is not None:
            pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        if oauth2_scope is not None:
            pulumi.set(__self__, "oauth2_scope", oauth2_scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonImageUrl")
    def button_image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_image_url")

    @button_image_url.setter
    def button_image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_image_url", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client id for your Application.
        """
        return pulumi.get(self, "oauth2_client_id")

    @oauth2_client_id.setter
    def oauth2_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth2_client_id", value)

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the OpenID Connect identity provider.
        """
        return pulumi.get(self, "oauth2_client_secret")

    @oauth2_client_secret.setter
    def oauth2_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth2_client_secret", value)

    @property
    @pulumi.getter(name="oauth2Scope")
    def oauth2_scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from the OpenID Connect identity provider.
        """
        return pulumi.get(self, "oauth2_scope")

    @oauth2_scope.setter
    def oauth2_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth2_scope", value)


@pulumi.input_type
class FusionAuthIdpOpenIdConnectTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpPsnApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: The top-level Sony PlayStation Network client id for your Application. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        :param pulumi.Input[str] client_secret: The top-level client secret to use with the Sony PlayStation Network Identity Provider when retrieving the long-lived token. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from Sony PlayStation Network.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level Sony PlayStation Network client id for your Application. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the Sony PlayStation Network Identity Provider when retrieving the long-lived token. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from Sony PlayStation Network.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class FusionAuthIdpPsnTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpSamlV2IdpInitiatedApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthIdpSamlV2IdpInitiatedTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpSamlv2ApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_image_url: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_image_url: The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_image_url is not None:
            pulumi.set(__self__, "button_image_url", button_image_url)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonImageUrl")
    def button_image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_image_url")

    @button_image_url.setter
    def button_image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_image_url", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthIdpSamlv2TenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpSteamApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 web_api_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: The top-level Steam client id for your Application. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from Steam.
        :param pulumi.Input[str] web_api_key: The top-level web API key to use with the Steam Identity Provider when retrieving the player summary info. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if web_api_key is not None:
            pulumi.set(__self__, "web_api_key", web_api_key)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level Steam client id for your Application. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from Steam.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="webApiKey")
    def web_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level web API key to use with the Steam Identity Provider when retrieving the player summary info. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        return pulumi.get(self, "web_api_key")

    @web_api_key.setter
    def web_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_api_key", value)


@pulumi.input_type
class FusionAuthIdpSteamTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpTwitchApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param pulumi.Input[str] client_secret: The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from Xbox.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from Xbox.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class FusionAuthIdpTwitchTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthIdpXBoxApplicationConfigurationArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 button_text: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 create_registration: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] application_id: ID of the Application to apply this configuration to.
        :param pulumi.Input[str] button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param pulumi.Input[str] client_id: TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param pulumi.Input[str] client_secret: The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param pulumi.Input[bool] create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param pulumi.Input[bool] enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] scope: The top-level scope that you are requesting from Xbox.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @button_text.setter
    def button_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @create_registration.setter
    def create_registration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_registration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level scope that you are requesting from Xbox.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class FusionAuthIdpXBoxTenantConfigurationArgs:
    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[pulumi.Input[bool]] = None,
                 limit_user_link_count_maximum_links: Optional[pulumi.Input[int]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param pulumi.Input[int] limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param pulumi.Input[str] tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @limit_user_link_count_enabled.setter
    def limit_user_link_count_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_user_link_count_enabled", value)

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[pulumi.Input[int]]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @limit_user_link_count_maximum_links.setter
    def limit_user_link_count_maximum_links(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_user_link_count_maximum_links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FusionAuthSystemConfigurationAuditLogConfigurationArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input['FusionAuthSystemConfigurationAuditLogConfigurationDeleteArgs']] = None):
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['FusionAuthSystemConfigurationAuditLogConfigurationDeleteArgs']]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['FusionAuthSystemConfigurationAuditLogConfigurationDeleteArgs']]):
        pulumi.set(self, "delete", value)


@pulumi.input_type
class FusionAuthSystemConfigurationAuditLogConfigurationDeleteArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 number_of_days_to_retain: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param pulumi.Input[int] number_of_days_to_retain: The number of days to retain login records.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_days_to_retain is not None:
            pulumi.set(__self__, "number_of_days_to_retain", number_of_days_to_retain)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="numberOfDaysToRetain")
    def number_of_days_to_retain(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days to retain login records.
        """
        return pulumi.get(self, "number_of_days_to_retain")

    @number_of_days_to_retain.setter
    def number_of_days_to_retain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_days_to_retain", value)


@pulumi.input_type
class FusionAuthSystemConfigurationCorsConfigurationArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preflight_max_age_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified.
        :param pulumi.Input[bool] enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exposed_headers: The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers.
        :param pulumi.Input[int] preflight_max_age_in_seconds: The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if preflight_max_age_in_seconds is not None:
            pulumi.set(__self__, "preflight_max_age_in_seconds", preflight_max_age_in_seconds)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="preflightMaxAgeInSeconds")
    def preflight_max_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age.
        """
        return pulumi.get(self, "preflight_max_age_in_seconds")

    @preflight_max_age_in_seconds.setter
    def preflight_max_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preflight_max_age_in_seconds", value)


@pulumi.input_type
class FusionAuthSystemConfigurationEventLogConfigurationArgs:
    def __init__(__self__, *,
                 number_to_retain: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] number_to_retain: The number of events to retain. Once the the number of event logs exceeds this configured value they will be deleted starting with the oldest event logs.
        """
        if number_to_retain is not None:
            pulumi.set(__self__, "number_to_retain", number_to_retain)

    @property
    @pulumi.getter(name="numberToRetain")
    def number_to_retain(self) -> Optional[pulumi.Input[int]]:
        """
        The number of events to retain. Once the the number of event logs exceeds this configured value they will be deleted starting with the oldest event logs.
        """
        return pulumi.get(self, "number_to_retain")

    @number_to_retain.setter
    def number_to_retain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_to_retain", value)


@pulumi.input_type
class FusionAuthSystemConfigurationLoginRecordConfigurationArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input['FusionAuthSystemConfigurationLoginRecordConfigurationDeleteArgs']] = None):
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['FusionAuthSystemConfigurationLoginRecordConfigurationDeleteArgs']]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['FusionAuthSystemConfigurationLoginRecordConfigurationDeleteArgs']]):
        pulumi.set(self, "delete", value)


@pulumi.input_type
class FusionAuthSystemConfigurationLoginRecordConfigurationDeleteArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 number_of_days_to_retain: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param pulumi.Input[int] number_of_days_to_retain: The number of days to retain login records.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_days_to_retain is not None:
            pulumi.set(__self__, "number_of_days_to_retain", number_of_days_to_retain)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="numberOfDaysToRetain")
    def number_of_days_to_retain(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days to retain login records.
        """
        return pulumi.get(self, "number_of_days_to_retain")

    @number_of_days_to_retain.setter
    def number_of_days_to_retain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_days_to_retain", value)


@pulumi.input_type
class FusionAuthSystemConfigurationUiConfigurationArgs:
    def __init__(__self__, *,
                 header_color: Optional[pulumi.Input[str]] = None,
                 logo_url: Optional[pulumi.Input[str]] = None,
                 menu_font_color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_color: A hexadecimal color to override the default menu color in the user interface.
        :param pulumi.Input[str] logo_url: A URL of a logo to override the default FusionAuth logo in the user interface.
        :param pulumi.Input[str] menu_font_color: A hexadecimal color to override the default menu font color in the user interface.
        """
        if header_color is not None:
            pulumi.set(__self__, "header_color", header_color)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)
        if menu_font_color is not None:
            pulumi.set(__self__, "menu_font_color", menu_font_color)

    @property
    @pulumi.getter(name="headerColor")
    def header_color(self) -> Optional[pulumi.Input[str]]:
        """
        A hexadecimal color to override the default menu color in the user interface.
        """
        return pulumi.get(self, "header_color")

    @header_color.setter
    def header_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_color", value)

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL of a logo to override the default FusionAuth logo in the user interface.
        """
        return pulumi.get(self, "logo_url")

    @logo_url.setter
    def logo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_url", value)

    @property
    @pulumi.getter(name="menuFontColor")
    def menu_font_color(self) -> Optional[pulumi.Input[str]]:
        """
        A hexadecimal color to override the default menu font color in the user interface.
        """
        return pulumi.get(self, "menu_font_color")

    @menu_font_color.setter
    def menu_font_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "menu_font_color", value)


@pulumi.input_type
class FusionAuthTenantAccessControlConfigurationArgs:
    def __init__(__self__, *,
                 ui_ip_access_control_list_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ui_ip_access_control_list_id: The Id of the IP Access Control List limiting access to all applications in this tenant.
        """
        if ui_ip_access_control_list_id is not None:
            pulumi.set(__self__, "ui_ip_access_control_list_id", ui_ip_access_control_list_id)

    @property
    @pulumi.getter(name="uiIpAccessControlListId")
    def ui_ip_access_control_list_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the IP Access Control List limiting access to all applications in this tenant.
        """
        return pulumi.get(self, "ui_ip_access_control_list_id")

    @ui_ip_access_control_list_id.setter
    def ui_ip_access_control_list_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_ip_access_control_list_id", value)


@pulumi.input_type
class FusionAuthTenantCaptchaConfigurationArgs:
    def __init__(__self__, *,
                 captcha_method: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 site_key: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] captcha_method: The type of captcha method to use. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] secret_key: The secret key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param pulumi.Input[str] site_key: The site key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param pulumi.Input[float] threshold: The numeric threshold which separates a passing score from a failing one. This value only applies if using either the Google v3 or HCaptcha Enterprise method, otherwise this value is ignored.
        """
        if captcha_method is not None:
            pulumi.set(__self__, "captcha_method", captcha_method)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if site_key is not None:
            pulumi.set(__self__, "site_key", site_key)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="captchaMethod")
    def captcha_method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of captcha method to use. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "captcha_method")

    @captcha_method.setter
    def captcha_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_method", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> Optional[pulumi.Input[str]]:
        """
        The site key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site_key", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The numeric threshold which separates a passing score from a failing one. This value only applies if using either the Google v3 or HCaptcha Enterprise method, otherwise this value is ignored.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class FusionAuthTenantConnectorPolicyArgs:
    def __init__(__self__, *,
                 connector_id: Optional[pulumi.Input[str]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 migrate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] connector_id: The identifier of the Connector to which this policy refers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: A list of email domains to which this connector should apply. A value of ["*"] indicates this connector applies to all users.
        :param pulumi.Input[bool] migrate: If true, the user’s data will be migrated to FusionAuth at first successful authentication; subsequent authentications will occur against the FusionAuth datastore. If false, the Connector’s source will be treated as authoritative.
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the Connector to which this policy refers.
        """
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of email domains to which this connector should apply. A value of ["*"] indicates this connector applies to all users.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def migrate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the user’s data will be migrated to FusionAuth at first successful authentication; subsequent authentications will occur against the FusionAuth datastore. If false, the Connector’s source will be treated as authoritative.
        """
        return pulumi.get(self, "migrate")

    @migrate.setter
    def migrate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "migrate", value)


@pulumi.input_type
class FusionAuthTenantEmailConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 port: pulumi.Input[int],
                 additional_headers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 default_from_email: Optional[pulumi.Input[str]] = None,
                 default_from_name: Optional[pulumi.Input[str]] = None,
                 email_update_email_template_id: Optional[pulumi.Input[str]] = None,
                 email_verified_email_template_id: Optional[pulumi.Input[str]] = None,
                 forgot_password_email_template_id: Optional[pulumi.Input[str]] = None,
                 implicit_email_verification_allowed: Optional[pulumi.Input[bool]] = None,
                 login_id_in_use_on_create_email_template_id: Optional[pulumi.Input[str]] = None,
                 login_id_in_use_on_update_email_template_id: Optional[pulumi.Input[str]] = None,
                 login_new_device_email_template_id: Optional[pulumi.Input[str]] = None,
                 login_suspicious_email_template_id: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 password_reset_success_email_template_id: Optional[pulumi.Input[str]] = None,
                 password_update_email_template_id: Optional[pulumi.Input[str]] = None,
                 passwordless_email_template_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[str]] = None,
                 security: Optional[pulumi.Input[str]] = None,
                 set_password_email_template_id: Optional[pulumi.Input[str]] = None,
                 two_factor_method_add_email_template_id: Optional[pulumi.Input[str]] = None,
                 two_factor_method_remove_email_template_id: Optional[pulumi.Input[str]] = None,
                 unverified: Optional[pulumi.Input['FusionAuthTenantEmailConfigurationUnverifiedArgs']] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 verification_email_template_id: Optional[pulumi.Input[str]] = None,
                 verification_strategy: Optional[pulumi.Input[str]] = None,
                 verify_email: Optional[pulumi.Input[bool]] = None,
                 verify_email_when_changed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] host: The host name of the SMTP server that FusionAuth will use.
        :param pulumi.Input[int] port: The port of the SMTP server that FusionAuth will use.
        :param pulumi.Input[Mapping[str, Any]] additional_headers: The additional SMTP headers to be added to each outgoing email. Each SMTP header consists of a name and a value.
        :param pulumi.Input[str] default_from_email: The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>).
        :param pulumi.Input[str] default_from_name: The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>).
        :param pulumi.Input[str] email_update_email_template_id: The Id of the Email Template that is used when a user is sent a forgot password email.
        :param pulumi.Input[str] email_verified_email_template_id: The Id of the Email Template used to verify user emails.
        :param pulumi.Input[str] forgot_password_email_template_id: The Id of the Email Template that is used when a user is sent a forgot password email.
        :param pulumi.Input[bool] implicit_email_verification_allowed: When set to true, this allows email to be verified as a result of completing a similar email based workflow such as change password. When seto false, the user must explicitly complete the email verification workflow even if the user has already completed a similar email workflow such as change password.
        :param pulumi.Input[str] login_id_in_use_on_create_email_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        :param pulumi.Input[str] login_id_in_use_on_update_email_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        :param pulumi.Input[str] login_new_device_email_template_id: The Id of the Email Template used to send emails to users when they log in on a new device.
        :param pulumi.Input[str] login_suspicious_email_template_id: The Id of the Email Template used to send emails to users when a suspicious login occurs.
        :param pulumi.Input[str] password: An optional password FusionAuth will use to authenticate with the SMTP server.
        :param pulumi.Input[str] password_reset_success_email_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password habeen reset.
        :param pulumi.Input[str] password_update_email_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been rese
        :param pulumi.Input[str] passwordless_email_template_id: The Id of the Passwordless Email Template.
        :param pulumi.Input[str] properties: Additional Email Configuration in a properties file formatted String.
        :param pulumi.Input[str] security: The type of security protocol FusionAuth will use when connecting to the SMTP server.
        :param pulumi.Input[str] set_password_email_template_id: The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password.
        :param pulumi.Input[str] two_factor_method_add_email_template_id: The Id of the Email Template used to send emails to users when a MFA method has been added to their account.
        :param pulumi.Input[str] two_factor_method_remove_email_template_id: The Id of the Email Template used to send emails to users when a MFA method has been removed from their account.
        :param pulumi.Input[str] username: An optional username FusionAuth will to authenticate with the SMTP server.
        :param pulumi.Input[str] verification_email_template_id: The Id of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address ivalid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required.
        :param pulumi.Input[str] verification_strategy: The process by which the user will verify their email address. Possible values are `ClickableLink` or `FormField`.
        :param pulumi.Input[bool] verify_email: Whether the user’s email addresses are verified when the registers with your application.
        :param pulumi.Input[bool] verify_email_when_changed: Whether the user’s email addresses are verified when the user changes them.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if default_from_email is not None:
            pulumi.set(__self__, "default_from_email", default_from_email)
        if default_from_name is not None:
            pulumi.set(__self__, "default_from_name", default_from_name)
        if email_update_email_template_id is not None:
            pulumi.set(__self__, "email_update_email_template_id", email_update_email_template_id)
        if email_verified_email_template_id is not None:
            pulumi.set(__self__, "email_verified_email_template_id", email_verified_email_template_id)
        if forgot_password_email_template_id is not None:
            pulumi.set(__self__, "forgot_password_email_template_id", forgot_password_email_template_id)
        if implicit_email_verification_allowed is not None:
            pulumi.set(__self__, "implicit_email_verification_allowed", implicit_email_verification_allowed)
        if login_id_in_use_on_create_email_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_create_email_template_id", login_id_in_use_on_create_email_template_id)
        if login_id_in_use_on_update_email_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_update_email_template_id", login_id_in_use_on_update_email_template_id)
        if login_new_device_email_template_id is not None:
            pulumi.set(__self__, "login_new_device_email_template_id", login_new_device_email_template_id)
        if login_suspicious_email_template_id is not None:
            pulumi.set(__self__, "login_suspicious_email_template_id", login_suspicious_email_template_id)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if password_reset_success_email_template_id is not None:
            pulumi.set(__self__, "password_reset_success_email_template_id", password_reset_success_email_template_id)
        if password_update_email_template_id is not None:
            pulumi.set(__self__, "password_update_email_template_id", password_update_email_template_id)
        if passwordless_email_template_id is not None:
            pulumi.set(__self__, "passwordless_email_template_id", passwordless_email_template_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if set_password_email_template_id is not None:
            pulumi.set(__self__, "set_password_email_template_id", set_password_email_template_id)
        if two_factor_method_add_email_template_id is not None:
            pulumi.set(__self__, "two_factor_method_add_email_template_id", two_factor_method_add_email_template_id)
        if two_factor_method_remove_email_template_id is not None:
            pulumi.set(__self__, "two_factor_method_remove_email_template_id", two_factor_method_remove_email_template_id)
        if unverified is not None:
            pulumi.set(__self__, "unverified", unverified)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if verification_email_template_id is not None:
            pulumi.set(__self__, "verification_email_template_id", verification_email_template_id)
        if verification_strategy is not None:
            pulumi.set(__self__, "verification_strategy", verification_strategy)
        if verify_email is not None:
            pulumi.set(__self__, "verify_email", verify_email)
        if verify_email_when_changed is not None:
            pulumi.set(__self__, "verify_email_when_changed", verify_email_when_changed)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host name of the SMTP server that FusionAuth will use.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port of the SMTP server that FusionAuth will use.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The additional SMTP headers to be added to each outgoing email. Each SMTP header consists of a name and a value.
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="defaultFromEmail")
    def default_from_email(self) -> Optional[pulumi.Input[str]]:
        """
        The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>).
        """
        return pulumi.get(self, "default_from_email")

    @default_from_email.setter
    def default_from_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_from_email", value)

    @property
    @pulumi.getter(name="defaultFromName")
    def default_from_name(self) -> Optional[pulumi.Input[str]]:
        """
        The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>).
        """
        return pulumi.get(self, "default_from_name")

    @default_from_name.setter
    def default_from_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_from_name", value)

    @property
    @pulumi.getter(name="emailUpdateEmailTemplateId")
    def email_update_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email.
        """
        return pulumi.get(self, "email_update_email_template_id")

    @email_update_email_template_id.setter
    def email_update_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_update_email_template_id", value)

    @property
    @pulumi.getter(name="emailVerifiedEmailTemplateId")
    def email_verified_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to verify user emails.
        """
        return pulumi.get(self, "email_verified_email_template_id")

    @email_verified_email_template_id.setter
    def email_verified_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_verified_email_template_id", value)

    @property
    @pulumi.getter(name="forgotPasswordEmailTemplateId")
    def forgot_password_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email.
        """
        return pulumi.get(self, "forgot_password_email_template_id")

    @forgot_password_email_template_id.setter
    def forgot_password_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forgot_password_email_template_id", value)

    @property
    @pulumi.getter(name="implicitEmailVerificationAllowed")
    def implicit_email_verification_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, this allows email to be verified as a result of completing a similar email based workflow such as change password. When seto false, the user must explicitly complete the email verification workflow even if the user has already completed a similar email workflow such as change password.
        """
        return pulumi.get(self, "implicit_email_verification_allowed")

    @implicit_email_verification_allowed.setter
    def implicit_email_verification_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "implicit_email_verification_allowed", value)

    @property
    @pulumi.getter(name="loginIdInUseOnCreateEmailTemplateId")
    def login_id_in_use_on_create_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        """
        return pulumi.get(self, "login_id_in_use_on_create_email_template_id")

    @login_id_in_use_on_create_email_template_id.setter
    def login_id_in_use_on_create_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_id_in_use_on_create_email_template_id", value)

    @property
    @pulumi.getter(name="loginIdInUseOnUpdateEmailTemplateId")
    def login_id_in_use_on_update_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        """
        return pulumi.get(self, "login_id_in_use_on_update_email_template_id")

    @login_id_in_use_on_update_email_template_id.setter
    def login_id_in_use_on_update_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_id_in_use_on_update_email_template_id", value)

    @property
    @pulumi.getter(name="loginNewDeviceEmailTemplateId")
    def login_new_device_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when they log in on a new device.
        """
        return pulumi.get(self, "login_new_device_email_template_id")

    @login_new_device_email_template_id.setter
    def login_new_device_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_new_device_email_template_id", value)

    @property
    @pulumi.getter(name="loginSuspiciousEmailTemplateId")
    def login_suspicious_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a suspicious login occurs.
        """
        return pulumi.get(self, "login_suspicious_email_template_id")

    @login_suspicious_email_template_id.setter
    def login_suspicious_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_suspicious_email_template_id", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        An optional password FusionAuth will use to authenticate with the SMTP server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="passwordResetSuccessEmailTemplateId")
    def password_reset_success_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password habeen reset.
        """
        return pulumi.get(self, "password_reset_success_email_template_id")

    @password_reset_success_email_template_id.setter
    def password_reset_success_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_reset_success_email_template_id", value)

    @property
    @pulumi.getter(name="passwordUpdateEmailTemplateId")
    def password_update_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been rese
        """
        return pulumi.get(self, "password_update_email_template_id")

    @password_update_email_template_id.setter
    def password_update_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_update_email_template_id", value)

    @property
    @pulumi.getter(name="passwordlessEmailTemplateId")
    def passwordless_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Passwordless Email Template.
        """
        return pulumi.get(self, "passwordless_email_template_id")

    @passwordless_email_template_id.setter
    def passwordless_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passwordless_email_template_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[str]]:
        """
        Additional Email Configuration in a properties file formatted String.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input[str]]:
        """
        The type of security protocol FusionAuth will use when connecting to the SMTP server.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter(name="setPasswordEmailTemplateId")
    def set_password_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password.
        """
        return pulumi.get(self, "set_password_email_template_id")

    @set_password_email_template_id.setter
    def set_password_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_password_email_template_id", value)

    @property
    @pulumi.getter(name="twoFactorMethodAddEmailTemplateId")
    def two_factor_method_add_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been added to their account.
        """
        return pulumi.get(self, "two_factor_method_add_email_template_id")

    @two_factor_method_add_email_template_id.setter
    def two_factor_method_add_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "two_factor_method_add_email_template_id", value)

    @property
    @pulumi.getter(name="twoFactorMethodRemoveEmailTemplateId")
    def two_factor_method_remove_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been removed from their account.
        """
        return pulumi.get(self, "two_factor_method_remove_email_template_id")

    @two_factor_method_remove_email_template_id.setter
    def two_factor_method_remove_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "two_factor_method_remove_email_template_id", value)

    @property
    @pulumi.getter
    def unverified(self) -> Optional[pulumi.Input['FusionAuthTenantEmailConfigurationUnverifiedArgs']]:
        return pulumi.get(self, "unverified")

    @unverified.setter
    def unverified(self, value: Optional[pulumi.Input['FusionAuthTenantEmailConfigurationUnverifiedArgs']]):
        pulumi.set(self, "unverified", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        An optional username FusionAuth will to authenticate with the SMTP server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="verificationEmailTemplateId")
    def verification_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address ivalid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required.
        """
        return pulumi.get(self, "verification_email_template_id")

    @verification_email_template_id.setter
    def verification_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verification_email_template_id", value)

    @property
    @pulumi.getter(name="verificationStrategy")
    def verification_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The process by which the user will verify their email address. Possible values are `ClickableLink` or `FormField`.
        """
        return pulumi.get(self, "verification_strategy")

    @verification_strategy.setter
    def verification_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verification_strategy", value)

    @property
    @pulumi.getter(name="verifyEmail")
    def verify_email(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the user’s email addresses are verified when the registers with your application.
        """
        return pulumi.get(self, "verify_email")

    @verify_email.setter
    def verify_email(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_email", value)

    @property
    @pulumi.getter(name="verifyEmailWhenChanged")
    def verify_email_when_changed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the user’s email addresses are verified when the user changes them.
        """
        return pulumi.get(self, "verify_email_when_changed")

    @verify_email_when_changed.setter
    def verify_email_when_changed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_email_when_changed", value)


@pulumi.input_type
class FusionAuthTenantEmailConfigurationUnverifiedArgs:
    def __init__(__self__, *,
                 allow_email_change_when_gated: Optional[pulumi.Input[bool]] = None,
                 behavior: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_email_change_when_gated: When this value is set to true, the user is allowed to change their email address when they are gated because they haven’t verified their email address.
        :param pulumi.Input[str] behavior: = (Optional) The behavior when detecting breaches at time of user login
        """
        if allow_email_change_when_gated is not None:
            pulumi.set(__self__, "allow_email_change_when_gated", allow_email_change_when_gated)
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @property
    @pulumi.getter(name="allowEmailChangeWhenGated")
    def allow_email_change_when_gated(self) -> Optional[pulumi.Input[bool]]:
        """
        When this value is set to true, the user is allowed to change their email address when they are gated because they haven’t verified their email address.
        """
        return pulumi.get(self, "allow_email_change_when_gated")

    @allow_email_change_when_gated.setter
    def allow_email_change_when_gated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_email_change_when_gated", value)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input[str]]:
        """
        = (Optional) The behavior when detecting breaches at time of user login
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior", value)


@pulumi.input_type
class FusionAuthTenantEventConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 event: Optional[pulumi.Input[str]] = None,
                 transaction_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] event: The event type
        :param pulumi.Input[str] transaction_type: The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if transaction_type is not None:
            pulumi.set(__self__, "transaction_type", transaction_type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[str]]:
        """
        The event type
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter(name="transactionType")
    def transaction_type(self) -> Optional[pulumi.Input[str]]:
        """
        The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks.
        """
        return pulumi.get(self, "transaction_type")

    @transaction_type.setter
    def transaction_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transaction_type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationArgs:
    def __init__(__self__, *,
                 authorization_grant_id_time_to_live_in_seconds: pulumi.Input[int],
                 change_password_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGeneratorArgs'],
                 change_password_id_time_to_live_in_seconds: pulumi.Input[int],
                 device_code_time_to_live_in_seconds: pulumi.Input[int],
                 device_user_code_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGeneratorArgs'],
                 email_verification_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGeneratorArgs'],
                 email_verification_id_time_to_live_in_seconds: pulumi.Input[int],
                 email_verification_one_time_code_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGeneratorArgs'],
                 external_authentication_id_time_to_live_in_seconds: pulumi.Input[int],
                 one_time_password_time_to_live_in_seconds: pulumi.Input[int],
                 passwordless_login_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGeneratorArgs'],
                 passwordless_login_time_to_live_in_seconds: pulumi.Input[int],
                 registration_verification_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGeneratorArgs'],
                 registration_verification_id_time_to_live_in_seconds: pulumi.Input[int],
                 registration_verification_one_time_code_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGeneratorArgs'],
                 setup_password_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGeneratorArgs'],
                 setup_password_id_time_to_live_in_seconds: pulumi.Input[int],
                 two_factor_id_time_to_live_in_seconds: pulumi.Input[int],
                 two_factor_one_time_code_id_generator: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGeneratorArgs'],
                 two_factor_trust_id_time_to_live_in_seconds: pulumi.Input[int],
                 pending_account_link_time_to_live_in_seconds: Optional[pulumi.Input[int]] = None,
                 saml_v2_authn_request_id_ttl_seconds: Optional[pulumi.Input[int]] = None,
                 trust_token_time_to_live_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] authorization_grant_id_time_to_live_in_seconds: The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.
        :param pulumi.Input[int] change_password_id_time_to_live_in_seconds: The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        :param pulumi.Input[int] device_code_time_to_live_in_seconds: The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        :param pulumi.Input[int] email_verification_id_time_to_live_in_seconds: The time in seconds until a email verification Id is no longer valid and cannot be used by the Verify Email API. Value must be greater than 0.
        :param pulumi.Input[int] external_authentication_id_time_to_live_in_seconds: The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        :param pulumi.Input[int] one_time_password_time_to_live_in_seconds: The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0.
        :param pulumi.Input[int] passwordless_login_time_to_live_in_seconds: The time in seconds until a passwordless code is no longer valid and cannot be used by the Passwordless API. Value must be greater than 0.
        :param pulumi.Input[int] registration_verification_id_time_to_live_in_seconds: The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0.
        :param pulumi.Input[int] setup_password_id_time_to_live_in_seconds: The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        :param pulumi.Input[int] two_factor_id_time_to_live_in_seconds: The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0.
        :param pulumi.Input[int] two_factor_trust_id_time_to_live_in_seconds: The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0.
        :param pulumi.Input[int] pending_account_link_time_to_live_in_seconds: The number of seconds before the pending account link identifier is no longer valid to complete an account link request. Value must be greater than 0.
        :param pulumi.Input[int] saml_v2_authn_request_id_ttl_seconds: The time in seconds that a SAML AuthN request will be eligible for use to authenticate with FusionAuth.
        :param pulumi.Input[int] trust_token_time_to_live_in_seconds: The number of seconds before the Trust Token is no longer valid to complete a request that requires trust. Value must be greater than 0.
        """
        pulumi.set(__self__, "authorization_grant_id_time_to_live_in_seconds", authorization_grant_id_time_to_live_in_seconds)
        pulumi.set(__self__, "change_password_id_generator", change_password_id_generator)
        pulumi.set(__self__, "change_password_id_time_to_live_in_seconds", change_password_id_time_to_live_in_seconds)
        pulumi.set(__self__, "device_code_time_to_live_in_seconds", device_code_time_to_live_in_seconds)
        pulumi.set(__self__, "device_user_code_id_generator", device_user_code_id_generator)
        pulumi.set(__self__, "email_verification_id_generator", email_verification_id_generator)
        pulumi.set(__self__, "email_verification_id_time_to_live_in_seconds", email_verification_id_time_to_live_in_seconds)
        pulumi.set(__self__, "email_verification_one_time_code_generator", email_verification_one_time_code_generator)
        pulumi.set(__self__, "external_authentication_id_time_to_live_in_seconds", external_authentication_id_time_to_live_in_seconds)
        pulumi.set(__self__, "one_time_password_time_to_live_in_seconds", one_time_password_time_to_live_in_seconds)
        pulumi.set(__self__, "passwordless_login_generator", passwordless_login_generator)
        pulumi.set(__self__, "passwordless_login_time_to_live_in_seconds", passwordless_login_time_to_live_in_seconds)
        pulumi.set(__self__, "registration_verification_id_generator", registration_verification_id_generator)
        pulumi.set(__self__, "registration_verification_id_time_to_live_in_seconds", registration_verification_id_time_to_live_in_seconds)
        pulumi.set(__self__, "registration_verification_one_time_code_generator", registration_verification_one_time_code_generator)
        pulumi.set(__self__, "setup_password_id_generator", setup_password_id_generator)
        pulumi.set(__self__, "setup_password_id_time_to_live_in_seconds", setup_password_id_time_to_live_in_seconds)
        pulumi.set(__self__, "two_factor_id_time_to_live_in_seconds", two_factor_id_time_to_live_in_seconds)
        pulumi.set(__self__, "two_factor_one_time_code_id_generator", two_factor_one_time_code_id_generator)
        pulumi.set(__self__, "two_factor_trust_id_time_to_live_in_seconds", two_factor_trust_id_time_to_live_in_seconds)
        if pending_account_link_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "pending_account_link_time_to_live_in_seconds", pending_account_link_time_to_live_in_seconds)
        if saml_v2_authn_request_id_ttl_seconds is not None:
            pulumi.set(__self__, "saml_v2_authn_request_id_ttl_seconds", saml_v2_authn_request_id_ttl_seconds)
        if trust_token_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "trust_token_time_to_live_in_seconds", trust_token_time_to_live_in_seconds)

    @property
    @pulumi.getter(name="authorizationGrantIdTimeToLiveInSeconds")
    def authorization_grant_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.
        """
        return pulumi.get(self, "authorization_grant_id_time_to_live_in_seconds")

    @authorization_grant_id_time_to_live_in_seconds.setter
    def authorization_grant_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "authorization_grant_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="changePasswordIdGenerator")
    def change_password_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGeneratorArgs']:
        return pulumi.get(self, "change_password_id_generator")

    @change_password_id_generator.setter
    def change_password_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGeneratorArgs']):
        pulumi.set(self, "change_password_id_generator", value)

    @property
    @pulumi.getter(name="changePasswordIdTimeToLiveInSeconds")
    def change_password_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        """
        return pulumi.get(self, "change_password_id_time_to_live_in_seconds")

    @change_password_id_time_to_live_in_seconds.setter
    def change_password_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "change_password_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="deviceCodeTimeToLiveInSeconds")
    def device_code_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        """
        return pulumi.get(self, "device_code_time_to_live_in_seconds")

    @device_code_time_to_live_in_seconds.setter
    def device_code_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "device_code_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="deviceUserCodeIdGenerator")
    def device_user_code_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGeneratorArgs']:
        return pulumi.get(self, "device_user_code_id_generator")

    @device_user_code_id_generator.setter
    def device_user_code_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGeneratorArgs']):
        pulumi.set(self, "device_user_code_id_generator", value)

    @property
    @pulumi.getter(name="emailVerificationIdGenerator")
    def email_verification_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGeneratorArgs']:
        return pulumi.get(self, "email_verification_id_generator")

    @email_verification_id_generator.setter
    def email_verification_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGeneratorArgs']):
        pulumi.set(self, "email_verification_id_generator", value)

    @property
    @pulumi.getter(name="emailVerificationIdTimeToLiveInSeconds")
    def email_verification_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a email verification Id is no longer valid and cannot be used by the Verify Email API. Value must be greater than 0.
        """
        return pulumi.get(self, "email_verification_id_time_to_live_in_seconds")

    @email_verification_id_time_to_live_in_seconds.setter
    def email_verification_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "email_verification_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="emailVerificationOneTimeCodeGenerator")
    def email_verification_one_time_code_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGeneratorArgs']:
        return pulumi.get(self, "email_verification_one_time_code_generator")

    @email_verification_one_time_code_generator.setter
    def email_verification_one_time_code_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGeneratorArgs']):
        pulumi.set(self, "email_verification_one_time_code_generator", value)

    @property
    @pulumi.getter(name="externalAuthenticationIdTimeToLiveInSeconds")
    def external_authentication_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        """
        return pulumi.get(self, "external_authentication_id_time_to_live_in_seconds")

    @external_authentication_id_time_to_live_in_seconds.setter
    def external_authentication_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "external_authentication_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="oneTimePasswordTimeToLiveInSeconds")
    def one_time_password_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0.
        """
        return pulumi.get(self, "one_time_password_time_to_live_in_seconds")

    @one_time_password_time_to_live_in_seconds.setter
    def one_time_password_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "one_time_password_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="passwordlessLoginGenerator")
    def passwordless_login_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGeneratorArgs']:
        return pulumi.get(self, "passwordless_login_generator")

    @passwordless_login_generator.setter
    def passwordless_login_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGeneratorArgs']):
        pulumi.set(self, "passwordless_login_generator", value)

    @property
    @pulumi.getter(name="passwordlessLoginTimeToLiveInSeconds")
    def passwordless_login_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a passwordless code is no longer valid and cannot be used by the Passwordless API. Value must be greater than 0.
        """
        return pulumi.get(self, "passwordless_login_time_to_live_in_seconds")

    @passwordless_login_time_to_live_in_seconds.setter
    def passwordless_login_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "passwordless_login_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="registrationVerificationIdGenerator")
    def registration_verification_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGeneratorArgs']:
        return pulumi.get(self, "registration_verification_id_generator")

    @registration_verification_id_generator.setter
    def registration_verification_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGeneratorArgs']):
        pulumi.set(self, "registration_verification_id_generator", value)

    @property
    @pulumi.getter(name="registrationVerificationIdTimeToLiveInSeconds")
    def registration_verification_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0.
        """
        return pulumi.get(self, "registration_verification_id_time_to_live_in_seconds")

    @registration_verification_id_time_to_live_in_seconds.setter
    def registration_verification_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "registration_verification_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="registrationVerificationOneTimeCodeGenerator")
    def registration_verification_one_time_code_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGeneratorArgs']:
        return pulumi.get(self, "registration_verification_one_time_code_generator")

    @registration_verification_one_time_code_generator.setter
    def registration_verification_one_time_code_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGeneratorArgs']):
        pulumi.set(self, "registration_verification_one_time_code_generator", value)

    @property
    @pulumi.getter(name="setupPasswordIdGenerator")
    def setup_password_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGeneratorArgs']:
        return pulumi.get(self, "setup_password_id_generator")

    @setup_password_id_generator.setter
    def setup_password_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGeneratorArgs']):
        pulumi.set(self, "setup_password_id_generator", value)

    @property
    @pulumi.getter(name="setupPasswordIdTimeToLiveInSeconds")
    def setup_password_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        """
        return pulumi.get(self, "setup_password_id_time_to_live_in_seconds")

    @setup_password_id_time_to_live_in_seconds.setter
    def setup_password_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "setup_password_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="twoFactorIdTimeToLiveInSeconds")
    def two_factor_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0.
        """
        return pulumi.get(self, "two_factor_id_time_to_live_in_seconds")

    @two_factor_id_time_to_live_in_seconds.setter
    def two_factor_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "two_factor_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="twoFactorOneTimeCodeIdGenerator")
    def two_factor_one_time_code_id_generator(self) -> pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGeneratorArgs']:
        return pulumi.get(self, "two_factor_one_time_code_id_generator")

    @two_factor_one_time_code_id_generator.setter
    def two_factor_one_time_code_id_generator(self, value: pulumi.Input['FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGeneratorArgs']):
        pulumi.set(self, "two_factor_one_time_code_id_generator", value)

    @property
    @pulumi.getter(name="twoFactorTrustIdTimeToLiveInSeconds")
    def two_factor_trust_id_time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0.
        """
        return pulumi.get(self, "two_factor_trust_id_time_to_live_in_seconds")

    @two_factor_trust_id_time_to_live_in_seconds.setter
    def two_factor_trust_id_time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "two_factor_trust_id_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="pendingAccountLinkTimeToLiveInSeconds")
    def pending_account_link_time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds before the pending account link identifier is no longer valid to complete an account link request. Value must be greater than 0.
        """
        return pulumi.get(self, "pending_account_link_time_to_live_in_seconds")

    @pending_account_link_time_to_live_in_seconds.setter
    def pending_account_link_time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pending_account_link_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="samlV2AuthnRequestIdTtlSeconds")
    def saml_v2_authn_request_id_ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds that a SAML AuthN request will be eligible for use to authenticate with FusionAuth.
        """
        return pulumi.get(self, "saml_v2_authn_request_id_ttl_seconds")

    @saml_v2_authn_request_id_ttl_seconds.setter
    def saml_v2_authn_request_id_ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "saml_v2_authn_request_id_ttl_seconds", value)

    @property
    @pulumi.getter(name="trustTokenTimeToLiveInSeconds")
    def trust_token_time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds before the Trust Token is no longer valid to complete a request that requires trust. Value must be greater than 0.
        """
        return pulumi.get(self, "trust_token_time_to_live_in_seconds")

    @trust_token_time_to_live_in_seconds.setter
    def trust_token_time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "trust_token_time_to_live_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGeneratorArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[int],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] length: TThe length of the secure generator used for generating the the two factor code Id.
        :param pulumi.Input[str] type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FusionAuthTenantFailedAuthenticationConfigurationArgs:
    def __init__(__self__, *,
                 action_cancel_policy_on_password_reset: Optional[pulumi.Input[bool]] = None,
                 action_duration: Optional[pulumi.Input[int]] = None,
                 action_duration_unit: Optional[pulumi.Input[str]] = None,
                 email_user: Optional[pulumi.Input[bool]] = None,
                 reset_count_in_seconds: Optional[pulumi.Input[int]] = None,
                 too_many_attempts: Optional[pulumi.Input[int]] = None,
                 user_action_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] action_cancel_policy_on_password_reset: Indicates whether you want the user to be able to self-service unlock their account prior to the action duration by completing a password reset workflow.
        :param pulumi.Input[int] action_duration: The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0.
        :param pulumi.Input[str] action_duration_unit: The unit of time associated with a duration.
        :param pulumi.Input[bool] email_user: Indicates you would like to email the user when the user’s account is locked due to this action being taken. This requires the User Action specified by the tenant.failedAuthenticationConfiguration.userActionId to also be configured for email. If the User Action is not configured to be able to email the user, this configuration will be ignored.
        :param pulumi.Input[int] reset_count_in_seconds: The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.
        :param pulumi.Input[int] too_many_attempts: The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0.
        :param pulumi.Input[str] user_action_id: The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts.
        """
        if action_cancel_policy_on_password_reset is not None:
            pulumi.set(__self__, "action_cancel_policy_on_password_reset", action_cancel_policy_on_password_reset)
        if action_duration is not None:
            pulumi.set(__self__, "action_duration", action_duration)
        if action_duration_unit is not None:
            pulumi.set(__self__, "action_duration_unit", action_duration_unit)
        if email_user is not None:
            pulumi.set(__self__, "email_user", email_user)
        if reset_count_in_seconds is not None:
            pulumi.set(__self__, "reset_count_in_seconds", reset_count_in_seconds)
        if too_many_attempts is not None:
            pulumi.set(__self__, "too_many_attempts", too_many_attempts)
        if user_action_id is not None:
            pulumi.set(__self__, "user_action_id", user_action_id)

    @property
    @pulumi.getter(name="actionCancelPolicyOnPasswordReset")
    def action_cancel_policy_on_password_reset(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether you want the user to be able to self-service unlock their account prior to the action duration by completing a password reset workflow.
        """
        return pulumi.get(self, "action_cancel_policy_on_password_reset")

    @action_cancel_policy_on_password_reset.setter
    def action_cancel_policy_on_password_reset(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_cancel_policy_on_password_reset", value)

    @property
    @pulumi.getter(name="actionDuration")
    def action_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0.
        """
        return pulumi.get(self, "action_duration")

    @action_duration.setter
    def action_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "action_duration", value)

    @property
    @pulumi.getter(name="actionDurationUnit")
    def action_duration_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit of time associated with a duration.
        """
        return pulumi.get(self, "action_duration_unit")

    @action_duration_unit.setter
    def action_duration_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_duration_unit", value)

    @property
    @pulumi.getter(name="emailUser")
    def email_user(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates you would like to email the user when the user’s account is locked due to this action being taken. This requires the User Action specified by the tenant.failedAuthenticationConfiguration.userActionId to also be configured for email. If the User Action is not configured to be able to email the user, this configuration will be ignored.
        """
        return pulumi.get(self, "email_user")

    @email_user.setter
    def email_user(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_user", value)

    @property
    @pulumi.getter(name="resetCountInSeconds")
    def reset_count_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.
        """
        return pulumi.get(self, "reset_count_in_seconds")

    @reset_count_in_seconds.setter
    def reset_count_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reset_count_in_seconds", value)

    @property
    @pulumi.getter(name="tooManyAttempts")
    def too_many_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0.
        """
        return pulumi.get(self, "too_many_attempts")

    @too_many_attempts.setter
    def too_many_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "too_many_attempts", value)

    @property
    @pulumi.getter(name="userActionId")
    def user_action_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts.
        """
        return pulumi.get(self, "user_action_id")

    @user_action_id.setter
    def user_action_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_action_id", value)


@pulumi.input_type
class FusionAuthTenantFamilyConfigurationArgs:
    def __init__(__self__, *,
                 allow_child_registrations: Optional[pulumi.Input[bool]] = None,
                 confirm_child_email_template_id: Optional[pulumi.Input[str]] = None,
                 delete_orphaned_accounts: Optional[pulumi.Input[bool]] = None,
                 delete_orphaned_accounts_days: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 family_request_email_template_id: Optional[pulumi.Input[str]] = None,
                 maximum_child_age: Optional[pulumi.Input[int]] = None,
                 minimum_owner_age: Optional[pulumi.Input[int]] = None,
                 parent_email_required: Optional[pulumi.Input[bool]] = None,
                 parent_registration_email_template_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_child_registrations: Whether to allow child registrations.
        :param pulumi.Input[str] confirm_child_email_template_id: The unique Id of the email template to use when confirming a child.
        :param pulumi.Input[bool] delete_orphaned_accounts: Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days.
        :param pulumi.Input[int] delete_orphaned_accounts_days: The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0.
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] family_request_email_template_id: The unique Id of the email template to use when a family request is made.
        :param pulumi.Input[int] maximum_child_age: The maximum age of a child. Value must be greater than 0.
        :param pulumi.Input[int] minimum_owner_age: The minimum age to be an owner. Value must be greater than 0.
        :param pulumi.Input[bool] parent_email_required: Whether a parent email is required.
        :param pulumi.Input[str] parent_registration_email_template_id: The unique Id of the email template to use for parent registration.
        """
        if allow_child_registrations is not None:
            pulumi.set(__self__, "allow_child_registrations", allow_child_registrations)
        if confirm_child_email_template_id is not None:
            pulumi.set(__self__, "confirm_child_email_template_id", confirm_child_email_template_id)
        if delete_orphaned_accounts is not None:
            pulumi.set(__self__, "delete_orphaned_accounts", delete_orphaned_accounts)
        if delete_orphaned_accounts_days is not None:
            pulumi.set(__self__, "delete_orphaned_accounts_days", delete_orphaned_accounts_days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if family_request_email_template_id is not None:
            pulumi.set(__self__, "family_request_email_template_id", family_request_email_template_id)
        if maximum_child_age is not None:
            pulumi.set(__self__, "maximum_child_age", maximum_child_age)
        if minimum_owner_age is not None:
            pulumi.set(__self__, "minimum_owner_age", minimum_owner_age)
        if parent_email_required is not None:
            pulumi.set(__self__, "parent_email_required", parent_email_required)
        if parent_registration_email_template_id is not None:
            pulumi.set(__self__, "parent_registration_email_template_id", parent_registration_email_template_id)

    @property
    @pulumi.getter(name="allowChildRegistrations")
    def allow_child_registrations(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow child registrations.
        """
        return pulumi.get(self, "allow_child_registrations")

    @allow_child_registrations.setter
    def allow_child_registrations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_child_registrations", value)

    @property
    @pulumi.getter(name="confirmChildEmailTemplateId")
    def confirm_child_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the email template to use when confirming a child.
        """
        return pulumi.get(self, "confirm_child_email_template_id")

    @confirm_child_email_template_id.setter
    def confirm_child_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confirm_child_email_template_id", value)

    @property
    @pulumi.getter(name="deleteOrphanedAccounts")
    def delete_orphaned_accounts(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days.
        """
        return pulumi.get(self, "delete_orphaned_accounts")

    @delete_orphaned_accounts.setter
    def delete_orphaned_accounts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_orphaned_accounts", value)

    @property
    @pulumi.getter(name="deleteOrphanedAccountsDays")
    def delete_orphaned_accounts_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0.
        """
        return pulumi.get(self, "delete_orphaned_accounts_days")

    @delete_orphaned_accounts_days.setter
    def delete_orphaned_accounts_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delete_orphaned_accounts_days", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="familyRequestEmailTemplateId")
    def family_request_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the email template to use when a family request is made.
        """
        return pulumi.get(self, "family_request_email_template_id")

    @family_request_email_template_id.setter
    def family_request_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family_request_email_template_id", value)

    @property
    @pulumi.getter(name="maximumChildAge")
    def maximum_child_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum age of a child. Value must be greater than 0.
        """
        return pulumi.get(self, "maximum_child_age")

    @maximum_child_age.setter
    def maximum_child_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_child_age", value)

    @property
    @pulumi.getter(name="minimumOwnerAge")
    def minimum_owner_age(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum age to be an owner. Value must be greater than 0.
        """
        return pulumi.get(self, "minimum_owner_age")

    @minimum_owner_age.setter
    def minimum_owner_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_owner_age", value)

    @property
    @pulumi.getter(name="parentEmailRequired")
    def parent_email_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a parent email is required.
        """
        return pulumi.get(self, "parent_email_required")

    @parent_email_required.setter
    def parent_email_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parent_email_required", value)

    @property
    @pulumi.getter(name="parentRegistrationEmailTemplateId")
    def parent_registration_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the email template to use for parent registration.
        """
        return pulumi.get(self, "parent_registration_email_template_id")

    @parent_registration_email_template_id.setter
    def parent_registration_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_registration_email_template_id", value)


@pulumi.input_type
class FusionAuthTenantFormConfigurationArgs:
    def __init__(__self__, *,
                 admin_user_form_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_user_form_id: The unique Id of the form to use for the Add and Edit User form when used in the FusionAuth admin UI.
        """
        if admin_user_form_id is not None:
            pulumi.set(__self__, "admin_user_form_id", admin_user_form_id)

    @property
    @pulumi.getter(name="adminUserFormId")
    def admin_user_form_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique Id of the form to use for the Add and Edit User form when used in the FusionAuth admin UI.
        """
        return pulumi.get(self, "admin_user_form_id")

    @admin_user_form_id.setter
    def admin_user_form_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_user_form_id", value)


@pulumi.input_type
class FusionAuthTenantJwtConfigurationArgs:
    def __init__(__self__, *,
                 refresh_token_time_to_live_in_minutes: pulumi.Input[int],
                 time_to_live_in_seconds: pulumi.Input[int],
                 access_token_key_id: Optional[pulumi.Input[str]] = None,
                 id_token_key_id: Optional[pulumi.Input[str]] = None,
                 refresh_token_expiration_policy: Optional[pulumi.Input[str]] = None,
                 refresh_token_revocation_policy_on_login_prevented: Optional[pulumi.Input[bool]] = None,
                 refresh_token_revocation_policy_on_password_change: Optional[pulumi.Input[bool]] = None,
                 refresh_token_usage_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] refresh_token_time_to_live_in_minutes: The length of time in minutes a Refresh Token is valid from the time it was issued. Value must be greater than 0.
        :param pulumi.Input[int] time_to_live_in_seconds: The length of time in seconds this JWT is valid from the time it was issued. Value must be greater than 0.
        :param pulumi.Input[str] access_token_key_id: The unique id of the signing key used to sign the access token. Required prior to `1.30.0`.
        :param pulumi.Input[str] id_token_key_id: The unique id of the signing key used to sign the Id token. Required prior to `1.30.0`.
        :param pulumi.Input[str] refresh_token_expiration_policy: The refresh token expiration policy.
        :param pulumi.Input[bool] refresh_token_revocation_policy_on_login_prevented: When enabled, the refresh token will be revoked when a user action, such as locking an account based on a number of failed login attempts, prevents user login.
        :param pulumi.Input[bool] refresh_token_revocation_policy_on_password_change: When enabled, the refresh token will be revoked when a user changes their password."
        :param pulumi.Input[str] refresh_token_usage_policy: The refresh token usage policy.
        """
        pulumi.set(__self__, "refresh_token_time_to_live_in_minutes", refresh_token_time_to_live_in_minutes)
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        if access_token_key_id is not None:
            pulumi.set(__self__, "access_token_key_id", access_token_key_id)
        if id_token_key_id is not None:
            pulumi.set(__self__, "id_token_key_id", id_token_key_id)
        if refresh_token_expiration_policy is not None:
            pulumi.set(__self__, "refresh_token_expiration_policy", refresh_token_expiration_policy)
        if refresh_token_revocation_policy_on_login_prevented is not None:
            pulumi.set(__self__, "refresh_token_revocation_policy_on_login_prevented", refresh_token_revocation_policy_on_login_prevented)
        if refresh_token_revocation_policy_on_password_change is not None:
            pulumi.set(__self__, "refresh_token_revocation_policy_on_password_change", refresh_token_revocation_policy_on_password_change)
        if refresh_token_usage_policy is not None:
            pulumi.set(__self__, "refresh_token_usage_policy", refresh_token_usage_policy)

    @property
    @pulumi.getter(name="refreshTokenTimeToLiveInMinutes")
    def refresh_token_time_to_live_in_minutes(self) -> pulumi.Input[int]:
        """
        The length of time in minutes a Refresh Token is valid from the time it was issued. Value must be greater than 0.
        """
        return pulumi.get(self, "refresh_token_time_to_live_in_minutes")

    @refresh_token_time_to_live_in_minutes.setter
    def refresh_token_time_to_live_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "refresh_token_time_to_live_in_minutes", value)

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        The length of time in seconds this JWT is valid from the time it was issued. Value must be greater than 0.
        """
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="accessTokenKeyId")
    def access_token_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id of the signing key used to sign the access token. Required prior to `1.30.0`.
        """
        return pulumi.get(self, "access_token_key_id")

    @access_token_key_id.setter
    def access_token_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_key_id", value)

    @property
    @pulumi.getter(name="idTokenKeyId")
    def id_token_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id of the signing key used to sign the Id token. Required prior to `1.30.0`.
        """
        return pulumi.get(self, "id_token_key_id")

    @id_token_key_id.setter
    def id_token_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id_token_key_id", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationPolicy")
    def refresh_token_expiration_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The refresh token expiration policy.
        """
        return pulumi.get(self, "refresh_token_expiration_policy")

    @refresh_token_expiration_policy.setter
    def refresh_token_expiration_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token_expiration_policy", value)

    @property
    @pulumi.getter(name="refreshTokenRevocationPolicyOnLoginPrevented")
    def refresh_token_revocation_policy_on_login_prevented(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the refresh token will be revoked when a user action, such as locking an account based on a number of failed login attempts, prevents user login.
        """
        return pulumi.get(self, "refresh_token_revocation_policy_on_login_prevented")

    @refresh_token_revocation_policy_on_login_prevented.setter
    def refresh_token_revocation_policy_on_login_prevented(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "refresh_token_revocation_policy_on_login_prevented", value)

    @property
    @pulumi.getter(name="refreshTokenRevocationPolicyOnPasswordChange")
    def refresh_token_revocation_policy_on_password_change(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, the refresh token will be revoked when a user changes their password."
        """
        return pulumi.get(self, "refresh_token_revocation_policy_on_password_change")

    @refresh_token_revocation_policy_on_password_change.setter
    def refresh_token_revocation_policy_on_password_change(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "refresh_token_revocation_policy_on_password_change", value)

    @property
    @pulumi.getter(name="refreshTokenUsagePolicy")
    def refresh_token_usage_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The refresh token usage policy.
        """
        return pulumi.get(self, "refresh_token_usage_policy")

    @refresh_token_usage_policy.setter
    def refresh_token_usage_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token_usage_policy", value)


@pulumi.input_type
class FusionAuthTenantLoginConfigurationArgs:
    def __init__(__self__, *,
                 require_authentication: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] require_authentication: Indicates whether to require an API key for the Login API when an `applicationId` is not provided. When an `applicationId` is provided to the Login API call, the application configuration will take precedence. In almost all cases, you will want to this to be `true`.
        """
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to require an API key for the Login API when an `applicationId` is not provided. When an `applicationId` is provided to the Login API call, the application configuration will take precedence. In almost all cases, you will want to this to be `true`.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)


@pulumi.input_type
class FusionAuthTenantMaximumPasswordAgeArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] days: The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. Required when systemConfiguration.maximumPasswordAge.enabled is set to true.
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. Required when systemConfiguration.maximumPasswordAge.enabled is set to true.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthTenantMinimumPasswordAgeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] seconds: The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. Required when systemConfiguration.minimumPasswordAge.enabled is set to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. Required when systemConfiguration.minimumPasswordAge.enabled is set to true.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


@pulumi.input_type
class FusionAuthTenantMultiFactorConfigurationArgs:
    def __init__(__self__, *,
                 authenticator: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationAuthenticatorArgs']] = None,
                 email: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationEmailArgs']] = None,
                 login_policy: Optional[pulumi.Input[str]] = None,
                 sms: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationSmsArgs']] = None):
        """
        :param pulumi.Input[str] login_policy: When set to `Enabled` and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When set to `Disabled`, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When the login policy is to `Required`, a two-factor challenge will be required during login. If a user does not have configured two-factor methods, they will not be able to log in.
        """
        if authenticator is not None:
            pulumi.set(__self__, "authenticator", authenticator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if login_policy is not None:
            pulumi.set(__self__, "login_policy", login_policy)
        if sms is not None:
            pulumi.set(__self__, "sms", sms)

    @property
    @pulumi.getter
    def authenticator(self) -> Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationAuthenticatorArgs']]:
        return pulumi.get(self, "authenticator")

    @authenticator.setter
    def authenticator(self, value: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationAuthenticatorArgs']]):
        pulumi.set(self, "authenticator", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="loginPolicy")
    def login_policy(self) -> Optional[pulumi.Input[str]]:
        """
        When set to `Enabled` and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When set to `Disabled`, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When the login policy is to `Required`, a two-factor challenge will be required during login. If a user does not have configured two-factor methods, they will not be able to log in.
        """
        return pulumi.get(self, "login_policy")

    @login_policy.setter
    def login_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_policy", value)

    @property
    @pulumi.getter
    def sms(self) -> Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationSmsArgs']]:
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: Optional[pulumi.Input['FusionAuthTenantMultiFactorConfigurationSmsArgs']]):
        pulumi.set(self, "sms", value)


@pulumi.input_type
class FusionAuthTenantMultiFactorConfigurationAuthenticatorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthTenantMultiFactorConfigurationEmailArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 template_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_id", value)


@pulumi.input_type
class FusionAuthTenantMultiFactorConfigurationSmsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 messenger_id: Optional[pulumi.Input[str]] = None,
                 template_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] messenger_id: The messenger that is used to deliver a SMS multi-factor authentication request.
        :param pulumi.Input[str] template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if messenger_id is not None:
            pulumi.set(__self__, "messenger_id", messenger_id)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="messengerId")
    def messenger_id(self) -> Optional[pulumi.Input[str]]:
        """
        The messenger that is used to deliver a SMS multi-factor authentication request.
        """
        return pulumi.get(self, "messenger_id")

    @messenger_id.setter
    def messenger_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "messenger_id", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_id", value)


@pulumi.input_type
class FusionAuthTenantOauthConfigurationArgs:
    def __init__(__self__, *,
                 client_credentials_access_token_populate_lambda_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_credentials_access_token_populate_lambda_id: The Id of a lambda that will be called to populate the JWT during a client credentials grant. **Note:** A paid edition of FusionAuth is required to utilize client credentials grant.
        """
        if client_credentials_access_token_populate_lambda_id is not None:
            pulumi.set(__self__, "client_credentials_access_token_populate_lambda_id", client_credentials_access_token_populate_lambda_id)

    @property
    @pulumi.getter(name="clientCredentialsAccessTokenPopulateLambdaId")
    def client_credentials_access_token_populate_lambda_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of a lambda that will be called to populate the JWT during a client credentials grant. **Note:** A paid edition of FusionAuth is required to utilize client credentials grant.
        """
        return pulumi.get(self, "client_credentials_access_token_populate_lambda_id")

    @client_credentials_access_token_populate_lambda_id.setter
    def client_credentials_access_token_populate_lambda_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credentials_access_token_populate_lambda_id", value)


@pulumi.input_type
class FusionAuthTenantPasswordEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_scheme: Optional[pulumi.Input[str]] = None,
                 encryption_scheme_factor: Optional[pulumi.Input[int]] = None,
                 modify_encryption_scheme_on_login: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] encryption_scheme: The default method for encrypting the User’s password.
        :param pulumi.Input[int] encryption_scheme_factor: The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation.
        :param pulumi.Input[bool] modify_encryption_scheme_on_login: When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import.
        """
        if encryption_scheme is not None:
            pulumi.set(__self__, "encryption_scheme", encryption_scheme)
        if encryption_scheme_factor is not None:
            pulumi.set(__self__, "encryption_scheme_factor", encryption_scheme_factor)
        if modify_encryption_scheme_on_login is not None:
            pulumi.set(__self__, "modify_encryption_scheme_on_login", modify_encryption_scheme_on_login)

    @property
    @pulumi.getter(name="encryptionScheme")
    def encryption_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        The default method for encrypting the User’s password.
        """
        return pulumi.get(self, "encryption_scheme")

    @encryption_scheme.setter
    def encryption_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_scheme", value)

    @property
    @pulumi.getter(name="encryptionSchemeFactor")
    def encryption_scheme_factor(self) -> Optional[pulumi.Input[int]]:
        """
        The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation.
        """
        return pulumi.get(self, "encryption_scheme_factor")

    @encryption_scheme_factor.setter
    def encryption_scheme_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "encryption_scheme_factor", value)

    @property
    @pulumi.getter(name="modifyEncryptionSchemeOnLogin")
    def modify_encryption_scheme_on_login(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import.
        """
        return pulumi.get(self, "modify_encryption_scheme_on_login")

    @modify_encryption_scheme_on_login.setter
    def modify_encryption_scheme_on_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "modify_encryption_scheme_on_login", value)


@pulumi.input_type
class FusionAuthTenantPasswordValidationRulesArgs:
    def __init__(__self__, *,
                 breach_detection: Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesBreachDetectionArgs']] = None,
                 max_length: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 remember_previous_passwords: Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesRememberPreviousPasswordsArgs']] = None,
                 require_non_alpha: Optional[pulumi.Input[bool]] = None,
                 require_number: Optional[pulumi.Input[bool]] = None,
                 required_mixed_case: Optional[pulumi.Input[bool]] = None,
                 validate_on_login: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] max_length: The maximum length of a password when a new user is created or a user requests a password change.
        :param pulumi.Input[int] min_length: The minimum length of a password when a new user is created or a user requests a password change.
        :param pulumi.Input[bool] require_non_alpha: Whether to force the user to use at least one non-alphanumeric character.
        :param pulumi.Input[bool] require_number: Whether to force the user to use at least one number.
        :param pulumi.Input[bool] required_mixed_case: Whether to force the user to use at least one uppercase and one lowercase character.
        :param pulumi.Input[bool] validate_on_login: When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        if breach_detection is not None:
            pulumi.set(__self__, "breach_detection", breach_detection)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if remember_previous_passwords is not None:
            pulumi.set(__self__, "remember_previous_passwords", remember_previous_passwords)
        if require_non_alpha is not None:
            pulumi.set(__self__, "require_non_alpha", require_non_alpha)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if required_mixed_case is not None:
            pulumi.set(__self__, "required_mixed_case", required_mixed_case)
        if validate_on_login is not None:
            pulumi.set(__self__, "validate_on_login", validate_on_login)

    @property
    @pulumi.getter(name="breachDetection")
    def breach_detection(self) -> Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesBreachDetectionArgs']]:
        return pulumi.get(self, "breach_detection")

    @breach_detection.setter
    def breach_detection(self, value: Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesBreachDetectionArgs']]):
        pulumi.set(self, "breach_detection", value)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a password when a new user is created or a user requests a password change.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of a password when a new user is created or a user requests a password change.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="rememberPreviousPasswords")
    def remember_previous_passwords(self) -> Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesRememberPreviousPasswordsArgs']]:
        return pulumi.get(self, "remember_previous_passwords")

    @remember_previous_passwords.setter
    def remember_previous_passwords(self, value: Optional[pulumi.Input['FusionAuthTenantPasswordValidationRulesRememberPreviousPasswordsArgs']]):
        pulumi.set(self, "remember_previous_passwords", value)

    @property
    @pulumi.getter(name="requireNonAlpha")
    def require_non_alpha(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to force the user to use at least one non-alphanumeric character.
        """
        return pulumi.get(self, "require_non_alpha")

    @require_non_alpha.setter
    def require_non_alpha(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_non_alpha", value)

    @property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to force the user to use at least one number.
        """
        return pulumi.get(self, "require_number")

    @require_number.setter
    def require_number(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_number", value)

    @property
    @pulumi.getter(name="requiredMixedCase")
    def required_mixed_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to force the user to use at least one uppercase and one lowercase character.
        """
        return pulumi.get(self, "required_mixed_case")

    @required_mixed_case.setter
    def required_mixed_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_mixed_case", value)

    @property
    @pulumi.getter(name="validateOnLogin")
    def validate_on_login(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        return pulumi.get(self, "validate_on_login")

    @validate_on_login.setter
    def validate_on_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_on_login", value)


@pulumi.input_type
class FusionAuthTenantPasswordValidationRulesBreachDetectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 match_mode: Optional[pulumi.Input[str]] = None,
                 notify_user_email_template_id: Optional[pulumi.Input[str]] = None,
                 on_login: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[str] match_mode: The level of severity where Reactor will consider a breach.
        :param pulumi.Input[str] notify_user_email_template_id: The Id of the email template to use when notifying user of breached password. Required if tenant.passwordValidationRules.breachDetection.onLogin is set to NotifyUser.
        :param pulumi.Input[str] on_login: The behavior when detecting breaches at time of user login
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_mode is not None:
            pulumi.set(__self__, "match_mode", match_mode)
        if notify_user_email_template_id is not None:
            pulumi.set(__self__, "notify_user_email_template_id", notify_user_email_template_id)
        if on_login is not None:
            pulumi.set(__self__, "on_login", on_login)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="matchMode")
    def match_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The level of severity where Reactor will consider a breach.
        """
        return pulumi.get(self, "match_mode")

    @match_mode.setter
    def match_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_mode", value)

    @property
    @pulumi.getter(name="notifyUserEmailTemplateId")
    def notify_user_email_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Id of the email template to use when notifying user of breached password. Required if tenant.passwordValidationRules.breachDetection.onLogin is set to NotifyUser.
        """
        return pulumi.get(self, "notify_user_email_template_id")

    @notify_user_email_template_id.setter
    def notify_user_email_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_user_email_template_id", value)

    @property
    @pulumi.getter(name="onLogin")
    def on_login(self) -> Optional[pulumi.Input[str]]:
        """
        The behavior when detecting breaches at time of user login
        """
        return pulumi.get(self, "on_login")

    @on_login.setter
    def on_login(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_login", value)


@pulumi.input_type
class FusionAuthTenantPasswordValidationRulesRememberPreviousPasswordsArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] count: The number of previous passwords to remember. Value must be greater than 0.
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of previous passwords to remember. Value must be greater than 0.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationArgs:
    def __init__(__self__, *,
                 failed_login: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationFailedLoginArgs']] = None,
                 forgot_password: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationForgotPasswordArgs']] = None,
                 send_email_verification: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendEmailVerificationArgs']] = None,
                 send_passwordless: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendPasswordlessArgs']] = None,
                 send_registration_verification: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendRegistrationVerificationArgs']] = None,
                 send_two_factor: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendTwoFactorArgs']] = None):
        if failed_login is not None:
            pulumi.set(__self__, "failed_login", failed_login)
        if forgot_password is not None:
            pulumi.set(__self__, "forgot_password", forgot_password)
        if send_email_verification is not None:
            pulumi.set(__self__, "send_email_verification", send_email_verification)
        if send_passwordless is not None:
            pulumi.set(__self__, "send_passwordless", send_passwordless)
        if send_registration_verification is not None:
            pulumi.set(__self__, "send_registration_verification", send_registration_verification)
        if send_two_factor is not None:
            pulumi.set(__self__, "send_two_factor", send_two_factor)

    @property
    @pulumi.getter(name="failedLogin")
    def failed_login(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationFailedLoginArgs']]:
        return pulumi.get(self, "failed_login")

    @failed_login.setter
    def failed_login(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationFailedLoginArgs']]):
        pulumi.set(self, "failed_login", value)

    @property
    @pulumi.getter(name="forgotPassword")
    def forgot_password(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationForgotPasswordArgs']]:
        return pulumi.get(self, "forgot_password")

    @forgot_password.setter
    def forgot_password(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationForgotPasswordArgs']]):
        pulumi.set(self, "forgot_password", value)

    @property
    @pulumi.getter(name="sendEmailVerification")
    def send_email_verification(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendEmailVerificationArgs']]:
        return pulumi.get(self, "send_email_verification")

    @send_email_verification.setter
    def send_email_verification(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendEmailVerificationArgs']]):
        pulumi.set(self, "send_email_verification", value)

    @property
    @pulumi.getter(name="sendPasswordless")
    def send_passwordless(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendPasswordlessArgs']]:
        return pulumi.get(self, "send_passwordless")

    @send_passwordless.setter
    def send_passwordless(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendPasswordlessArgs']]):
        pulumi.set(self, "send_passwordless", value)

    @property
    @pulumi.getter(name="sendRegistrationVerification")
    def send_registration_verification(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendRegistrationVerificationArgs']]:
        return pulumi.get(self, "send_registration_verification")

    @send_registration_verification.setter
    def send_registration_verification(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendRegistrationVerificationArgs']]):
        pulumi.set(self, "send_registration_verification", value)

    @property
    @pulumi.getter(name="sendTwoFactor")
    def send_two_factor(self) -> Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendTwoFactorArgs']]:
        return pulumi.get(self, "send_two_factor")

    @send_two_factor.setter
    def send_two_factor(self, value: Optional[pulumi.Input['FusionAuthTenantRateLimitConfigurationSendTwoFactorArgs']]):
        pulumi.set(self, "send_two_factor", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationFailedLoginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationForgotPasswordArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationSendEmailVerificationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationSendPasswordlessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationSendRegistrationVerificationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRateLimitConfigurationSendTwoFactorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 time_period_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param pulumi.Input[int] time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")

    @time_period_in_seconds.setter
    def time_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_period_in_seconds", value)


@pulumi.input_type
class FusionAuthTenantRegistrationConfigurationArgs:
    def __init__(__self__, *,
                 blocked_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_domains: A list of unique domains that are not allowed to register when self service is enabled.
        """
        if blocked_domains is not None:
            pulumi.set(__self__, "blocked_domains", blocked_domains)

    @property
    @pulumi.getter(name="blockedDomains")
    def blocked_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of unique domains that are not allowed to register when self service is enabled.
        """
        return pulumi.get(self, "blocked_domains")

    @blocked_domains.setter
    def blocked_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocked_domains", value)


@pulumi.input_type
class FusionAuthTenantUserDeletePolicyArgs:
    def __init__(__self__, *,
                 unverified_enabled: Optional[pulumi.Input[bool]] = None,
                 unverified_number_of_days_to_retain: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] unverified_enabled: Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        if unverified_enabled is not None:
            pulumi.set(__self__, "unverified_enabled", unverified_enabled)
        if unverified_number_of_days_to_retain is not None:
            pulumi.set(__self__, "unverified_number_of_days_to_retain", unverified_number_of_days_to_retain)

    @property
    @pulumi.getter(name="unverifiedEnabled")
    def unverified_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unverified_enabled")

    @unverified_enabled.setter
    def unverified_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unverified_enabled", value)

    @property
    @pulumi.getter(name="unverifiedNumberOfDaysToRetain")
    def unverified_number_of_days_to_retain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unverified_number_of_days_to_retain")

    @unverified_number_of_days_to_retain.setter
    def unverified_number_of_days_to_retain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unverified_number_of_days_to_retain", value)


@pulumi.input_type
class FusionAuthTenantUsernameConfigurationArgs:
    def __init__(__self__, *,
                 unique: Optional[pulumi.Input['FusionAuthTenantUsernameConfigurationUniqueArgs']] = None):
        """
        :param pulumi.Input['FusionAuthTenantUsernameConfigurationUniqueArgs'] unique: Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        if unique is not None:
            pulumi.set(__self__, "unique", unique)

    @property
    @pulumi.getter
    def unique(self) -> Optional[pulumi.Input['FusionAuthTenantUsernameConfigurationUniqueArgs']]:
        """
        Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unique")

    @unique.setter
    def unique(self, value: Optional[pulumi.Input['FusionAuthTenantUsernameConfigurationUniqueArgs']]):
        pulumi.set(self, "unique", value)


@pulumi.input_type
class FusionAuthTenantUsernameConfigurationUniqueArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 number_of_digits: Optional[pulumi.Input[int]] = None,
                 separator: Optional[pulumi.Input[str]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param pulumi.Input[int] number_of_digits: The maximum number of digits to use when building a unique suffix for a username. A number will be randomly selected and will be 1 or more digits up to this configured value in length. For example, if this value is 5, the suffix will be a number between 00001 and 99999, inclusive.
        :param pulumi.Input[str] separator: A single character to use as a separator from the requested username and a unique suffix that is added when a duplicate username is detected. This value can be a single non-alphanumeric ASCII character.
        :param pulumi.Input[str] strategy: When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_digits is not None:
            pulumi.set(__self__, "number_of_digits", number_of_digits)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="numberOfDigits")
    def number_of_digits(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of digits to use when building a unique suffix for a username. A number will be randomly selected and will be 1 or more digits up to this configured value in length. For example, if this value is 5, the suffix will be a number between 00001 and 99999, inclusive.
        """
        return pulumi.get(self, "number_of_digits")

    @number_of_digits.setter
    def number_of_digits(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_digits", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        A single character to use as a separator from the requested username and a unique suffix that is added when a duplicate username is detected. This value can be a single non-alphanumeric ASCII character.
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class FusionAuthUserActionOptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 localized_names: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] name: The name of this User Action Option.
        :param pulumi.Input[Mapping[str, Any]] localized_names: A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language.
        """
        pulumi.set(__self__, "name", name)
        if localized_names is not None:
            pulumi.set(__self__, "localized_names", localized_names)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of this User Action Option.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="localizedNames")
    def localized_names(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language.
        """
        return pulumi.get(self, "localized_names")

    @localized_names.setter
    def localized_names(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "localized_names", value)


@pulumi.input_type
class FusionAuthUserTwoFactorMethodArgs:
    def __init__(__self__, *,
                 authenticator_algorithm: Optional[pulumi.Input[str]] = None,
                 authenticator_code_length: Optional[pulumi.Input[int]] = None,
                 authenticator_time_step: Optional[pulumi.Input[int]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 mobile_phone: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 two_factor_method_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authenticator_algorithm: The algorithm used by the TOTP authenticator. With the current implementation, this will always be HmacSHA1.
        :param pulumi.Input[int] authenticator_code_length: The length of code generated by the TOTP. With the current implementation, this will always be 6.
        :param pulumi.Input[int] authenticator_time_step: The time-step size in seconds. With the current implementation, this will always be 30.
        :param pulumi.Input[str] email: The value of the email address for this method.
        :param pulumi.Input[str] method: The type of this method. There will also be an object with the same value containing additional information about this method.
        :param pulumi.Input[str] mobile_phone: The value of the mobile phone for this method.
        :param pulumi.Input[str] secret: A base64 encoded secret
        """
        if authenticator_algorithm is not None:
            pulumi.set(__self__, "authenticator_algorithm", authenticator_algorithm)
        if authenticator_code_length is not None:
            pulumi.set(__self__, "authenticator_code_length", authenticator_code_length)
        if authenticator_time_step is not None:
            pulumi.set(__self__, "authenticator_time_step", authenticator_time_step)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mobile_phone is not None:
            pulumi.set(__self__, "mobile_phone", mobile_phone)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if two_factor_method_id is not None:
            pulumi.set(__self__, "two_factor_method_id", two_factor_method_id)

    @property
    @pulumi.getter(name="authenticatorAlgorithm")
    def authenticator_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        The algorithm used by the TOTP authenticator. With the current implementation, this will always be HmacSHA1.
        """
        return pulumi.get(self, "authenticator_algorithm")

    @authenticator_algorithm.setter
    def authenticator_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authenticator_algorithm", value)

    @property
    @pulumi.getter(name="authenticatorCodeLength")
    def authenticator_code_length(self) -> Optional[pulumi.Input[int]]:
        """
        The length of code generated by the TOTP. With the current implementation, this will always be 6.
        """
        return pulumi.get(self, "authenticator_code_length")

    @authenticator_code_length.setter
    def authenticator_code_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "authenticator_code_length", value)

    @property
    @pulumi.getter(name="authenticatorTimeStep")
    def authenticator_time_step(self) -> Optional[pulumi.Input[int]]:
        """
        The time-step size in seconds. With the current implementation, this will always be 30.
        """
        return pulumi.get(self, "authenticator_time_step")

    @authenticator_time_step.setter
    def authenticator_time_step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "authenticator_time_step", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the email address for this method.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The type of this method. There will also be an object with the same value containing additional information about this method.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="mobilePhone")
    def mobile_phone(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the mobile phone for this method.
        """
        return pulumi.get(self, "mobile_phone")

    @mobile_phone.setter
    def mobile_phone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mobile_phone", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        A base64 encoded secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="twoFactorMethodId")
    def two_factor_method_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "two_factor_method_id")

    @two_factor_method_id.setter
    def two_factor_method_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "two_factor_method_id", value)


@pulumi.input_type
class FusionAuthWebhookEventsEnabledArgs:
    def __init__(__self__, *,
                 audit_log_create: Optional[pulumi.Input[bool]] = None,
                 event_log_create: Optional[pulumi.Input[bool]] = None,
                 jwt_public_key_update: Optional[pulumi.Input[bool]] = None,
                 jwt_refresh: Optional[pulumi.Input[bool]] = None,
                 jwt_refresh_token_revoke: Optional[pulumi.Input[bool]] = None,
                 kickstart_success: Optional[pulumi.Input[bool]] = None,
                 user_action: Optional[pulumi.Input[bool]] = None,
                 user_bulk_create: Optional[pulumi.Input[bool]] = None,
                 user_create: Optional[pulumi.Input[bool]] = None,
                 user_create_complete: Optional[pulumi.Input[bool]] = None,
                 user_deactivate: Optional[pulumi.Input[bool]] = None,
                 user_delete: Optional[pulumi.Input[bool]] = None,
                 user_delete_complete: Optional[pulumi.Input[bool]] = None,
                 user_email_update: Optional[pulumi.Input[bool]] = None,
                 user_email_verified: Optional[pulumi.Input[bool]] = None,
                 user_identity_provider_link: Optional[pulumi.Input[bool]] = None,
                 user_identity_provider_unlink: Optional[pulumi.Input[bool]] = None,
                 user_login_failed: Optional[pulumi.Input[bool]] = None,
                 user_login_id_duplicate_create: Optional[pulumi.Input[bool]] = None,
                 user_login_id_duplicate_update: Optional[pulumi.Input[bool]] = None,
                 user_login_new_device: Optional[pulumi.Input[bool]] = None,
                 user_login_success: Optional[pulumi.Input[bool]] = None,
                 user_login_suspicious: Optional[pulumi.Input[bool]] = None,
                 user_password_breach: Optional[pulumi.Input[bool]] = None,
                 user_password_reset_send: Optional[pulumi.Input[bool]] = None,
                 user_password_reset_start: Optional[pulumi.Input[bool]] = None,
                 user_password_reset_success: Optional[pulumi.Input[bool]] = None,
                 user_password_update: Optional[pulumi.Input[bool]] = None,
                 user_reactivate: Optional[pulumi.Input[bool]] = None,
                 user_registration_create: Optional[pulumi.Input[bool]] = None,
                 user_registration_create_complete: Optional[pulumi.Input[bool]] = None,
                 user_registration_delete: Optional[pulumi.Input[bool]] = None,
                 user_registration_delete_complete: Optional[pulumi.Input[bool]] = None,
                 user_registration_update: Optional[pulumi.Input[bool]] = None,
                 user_registration_update_complete: Optional[pulumi.Input[bool]] = None,
                 user_registration_verified: Optional[pulumi.Input[bool]] = None,
                 user_two_factor_method_add: Optional[pulumi.Input[bool]] = None,
                 user_two_factor_method_remove: Optional[pulumi.Input[bool]] = None,
                 user_update: Optional[pulumi.Input[bool]] = None,
                 user_update_complete: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] audit_log_create: When an audit log is created
        :param pulumi.Input[bool] event_log_create: When an event log is created
        :param pulumi.Input[bool] jwt_public_key_update: When a JWT RSA Public / Private keypair may have been changed
        :param pulumi.Input[bool] jwt_refresh: When an access token is refreshed using a refresh token
        :param pulumi.Input[bool] jwt_refresh_token_revoke: When a JWT Refresh Token is revoked
        :param pulumi.Input[bool] kickstart_success: When kickstart has successfully completed
        :param pulumi.Input[bool] user_action: When a user action is triggered
        :param pulumi.Input[bool] user_bulk_create: When multiple users are created in bulk (i.e. during an import)
        :param pulumi.Input[bool] user_create: When a user is created
        :param pulumi.Input[bool] user_create_complete: When a user create transaction has completed
        :param pulumi.Input[bool] user_deactivate: When a user is deactivated
        :param pulumi.Input[bool] user_delete: When a user is deleted
        :param pulumi.Input[bool] user_delete_complete: When a user delete transaction has completed
        :param pulumi.Input[bool] user_email_update: When a user updates their email address
        :param pulumi.Input[bool] user_email_verified: When a user verifies their email address
        :param pulumi.Input[bool] user_identity_provider_link: When a user is linked to an identity provider
        :param pulumi.Input[bool] user_identity_provider_unlink: When a link to an identity provider is removed
        :param pulumi.Input[bool] user_login_failed: When a user fails a login request
        :param pulumi.Input[bool] user_login_id_duplicate_create: When a request to create a user with a login Id (email or username) which is already in use has been received
        :param pulumi.Input[bool] user_login_id_duplicate_update: When a request to update a user and change their login Id (email or username) to one that is already in use has been received
        :param pulumi.Input[bool] user_login_new_device: When a user begins a login request with a new device
        :param pulumi.Input[bool] user_login_success: When a user completes a login request
        :param pulumi.Input[bool] user_login_suspicious: When a user logs in and is considered to be a potential threat
        :param pulumi.Input[bool] user_password_breach: When Reactor detects a user is using a potentially breached password (requires an activated license)
        :param pulumi.Input[bool] user_password_reset_send: When a forgot password email has been sent to a user
        :param pulumi.Input[bool] user_password_reset_start: When the process to reset a user password has started
        :param pulumi.Input[bool] user_password_reset_success: When a user has successfully reset their password
        :param pulumi.Input[bool] user_password_update: When a user has updated their password
        :param pulumi.Input[bool] user_reactivate: When a user is reactivated
        :param pulumi.Input[bool] user_registration_create: When a user registration is created
        :param pulumi.Input[bool] user_registration_create_complete: When a user registration create transaction has completed
        :param pulumi.Input[bool] user_registration_delete: When a user registration is deleted
        :param pulumi.Input[bool] user_registration_delete_complete: When a user registration delete transaction has completed
        :param pulumi.Input[bool] user_registration_update: When a user registration is updated
        :param pulumi.Input[bool] user_registration_update_complete: When a user registration update transaction has completed
        :param pulumi.Input[bool] user_registration_verified: When a user completes registration verification
        :param pulumi.Input[bool] user_two_factor_method_add: When a user has added a two-factor method
        :param pulumi.Input[bool] user_two_factor_method_remove: When a user has removed a two-factor method
        :param pulumi.Input[bool] user_update: When a user is updated
        :param pulumi.Input[bool] user_update_complete: When a user update transaction has completed
        """
        if audit_log_create is not None:
            pulumi.set(__self__, "audit_log_create", audit_log_create)
        if event_log_create is not None:
            pulumi.set(__self__, "event_log_create", event_log_create)
        if jwt_public_key_update is not None:
            pulumi.set(__self__, "jwt_public_key_update", jwt_public_key_update)
        if jwt_refresh is not None:
            pulumi.set(__self__, "jwt_refresh", jwt_refresh)
        if jwt_refresh_token_revoke is not None:
            pulumi.set(__self__, "jwt_refresh_token_revoke", jwt_refresh_token_revoke)
        if kickstart_success is not None:
            pulumi.set(__self__, "kickstart_success", kickstart_success)
        if user_action is not None:
            pulumi.set(__self__, "user_action", user_action)
        if user_bulk_create is not None:
            pulumi.set(__self__, "user_bulk_create", user_bulk_create)
        if user_create is not None:
            pulumi.set(__self__, "user_create", user_create)
        if user_create_complete is not None:
            pulumi.set(__self__, "user_create_complete", user_create_complete)
        if user_deactivate is not None:
            pulumi.set(__self__, "user_deactivate", user_deactivate)
        if user_delete is not None:
            pulumi.set(__self__, "user_delete", user_delete)
        if user_delete_complete is not None:
            pulumi.set(__self__, "user_delete_complete", user_delete_complete)
        if user_email_update is not None:
            pulumi.set(__self__, "user_email_update", user_email_update)
        if user_email_verified is not None:
            pulumi.set(__self__, "user_email_verified", user_email_verified)
        if user_identity_provider_link is not None:
            pulumi.set(__self__, "user_identity_provider_link", user_identity_provider_link)
        if user_identity_provider_unlink is not None:
            pulumi.set(__self__, "user_identity_provider_unlink", user_identity_provider_unlink)
        if user_login_failed is not None:
            pulumi.set(__self__, "user_login_failed", user_login_failed)
        if user_login_id_duplicate_create is not None:
            pulumi.set(__self__, "user_login_id_duplicate_create", user_login_id_duplicate_create)
        if user_login_id_duplicate_update is not None:
            pulumi.set(__self__, "user_login_id_duplicate_update", user_login_id_duplicate_update)
        if user_login_new_device is not None:
            pulumi.set(__self__, "user_login_new_device", user_login_new_device)
        if user_login_success is not None:
            pulumi.set(__self__, "user_login_success", user_login_success)
        if user_login_suspicious is not None:
            pulumi.set(__self__, "user_login_suspicious", user_login_suspicious)
        if user_password_breach is not None:
            pulumi.set(__self__, "user_password_breach", user_password_breach)
        if user_password_reset_send is not None:
            pulumi.set(__self__, "user_password_reset_send", user_password_reset_send)
        if user_password_reset_start is not None:
            pulumi.set(__self__, "user_password_reset_start", user_password_reset_start)
        if user_password_reset_success is not None:
            pulumi.set(__self__, "user_password_reset_success", user_password_reset_success)
        if user_password_update is not None:
            pulumi.set(__self__, "user_password_update", user_password_update)
        if user_reactivate is not None:
            pulumi.set(__self__, "user_reactivate", user_reactivate)
        if user_registration_create is not None:
            pulumi.set(__self__, "user_registration_create", user_registration_create)
        if user_registration_create_complete is not None:
            pulumi.set(__self__, "user_registration_create_complete", user_registration_create_complete)
        if user_registration_delete is not None:
            pulumi.set(__self__, "user_registration_delete", user_registration_delete)
        if user_registration_delete_complete is not None:
            pulumi.set(__self__, "user_registration_delete_complete", user_registration_delete_complete)
        if user_registration_update is not None:
            pulumi.set(__self__, "user_registration_update", user_registration_update)
        if user_registration_update_complete is not None:
            pulumi.set(__self__, "user_registration_update_complete", user_registration_update_complete)
        if user_registration_verified is not None:
            pulumi.set(__self__, "user_registration_verified", user_registration_verified)
        if user_two_factor_method_add is not None:
            pulumi.set(__self__, "user_two_factor_method_add", user_two_factor_method_add)
        if user_two_factor_method_remove is not None:
            pulumi.set(__self__, "user_two_factor_method_remove", user_two_factor_method_remove)
        if user_update is not None:
            pulumi.set(__self__, "user_update", user_update)
        if user_update_complete is not None:
            pulumi.set(__self__, "user_update_complete", user_update_complete)

    @property
    @pulumi.getter(name="auditLogCreate")
    def audit_log_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When an audit log is created
        """
        return pulumi.get(self, "audit_log_create")

    @audit_log_create.setter
    def audit_log_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "audit_log_create", value)

    @property
    @pulumi.getter(name="eventLogCreate")
    def event_log_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When an event log is created
        """
        return pulumi.get(self, "event_log_create")

    @event_log_create.setter
    def event_log_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "event_log_create", value)

    @property
    @pulumi.getter(name="jwtPublicKeyUpdate")
    def jwt_public_key_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a JWT RSA Public / Private keypair may have been changed
        """
        return pulumi.get(self, "jwt_public_key_update")

    @jwt_public_key_update.setter
    def jwt_public_key_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jwt_public_key_update", value)

    @property
    @pulumi.getter(name="jwtRefresh")
    def jwt_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        When an access token is refreshed using a refresh token
        """
        return pulumi.get(self, "jwt_refresh")

    @jwt_refresh.setter
    def jwt_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jwt_refresh", value)

    @property
    @pulumi.getter(name="jwtRefreshTokenRevoke")
    def jwt_refresh_token_revoke(self) -> Optional[pulumi.Input[bool]]:
        """
        When a JWT Refresh Token is revoked
        """
        return pulumi.get(self, "jwt_refresh_token_revoke")

    @jwt_refresh_token_revoke.setter
    def jwt_refresh_token_revoke(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jwt_refresh_token_revoke", value)

    @property
    @pulumi.getter(name="kickstartSuccess")
    def kickstart_success(self) -> Optional[pulumi.Input[bool]]:
        """
        When kickstart has successfully completed
        """
        return pulumi.get(self, "kickstart_success")

    @kickstart_success.setter
    def kickstart_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kickstart_success", value)

    @property
    @pulumi.getter(name="userAction")
    def user_action(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user action is triggered
        """
        return pulumi.get(self, "user_action")

    @user_action.setter
    def user_action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_action", value)

    @property
    @pulumi.getter(name="userBulkCreate")
    def user_bulk_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When multiple users are created in bulk (i.e. during an import)
        """
        return pulumi.get(self, "user_bulk_create")

    @user_bulk_create.setter
    def user_bulk_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_bulk_create", value)

    @property
    @pulumi.getter(name="userCreate")
    def user_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is created
        """
        return pulumi.get(self, "user_create")

    @user_create.setter
    def user_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_create", value)

    @property
    @pulumi.getter(name="userCreateComplete")
    def user_create_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user create transaction has completed
        """
        return pulumi.get(self, "user_create_complete")

    @user_create_complete.setter
    def user_create_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_create_complete", value)

    @property
    @pulumi.getter(name="userDeactivate")
    def user_deactivate(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is deactivated
        """
        return pulumi.get(self, "user_deactivate")

    @user_deactivate.setter
    def user_deactivate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_deactivate", value)

    @property
    @pulumi.getter(name="userDelete")
    def user_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is deleted
        """
        return pulumi.get(self, "user_delete")

    @user_delete.setter
    def user_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_delete", value)

    @property
    @pulumi.getter(name="userDeleteComplete")
    def user_delete_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user delete transaction has completed
        """
        return pulumi.get(self, "user_delete_complete")

    @user_delete_complete.setter
    def user_delete_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_delete_complete", value)

    @property
    @pulumi.getter(name="userEmailUpdate")
    def user_email_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user updates their email address
        """
        return pulumi.get(self, "user_email_update")

    @user_email_update.setter
    def user_email_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_email_update", value)

    @property
    @pulumi.getter(name="userEmailVerified")
    def user_email_verified(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user verifies their email address
        """
        return pulumi.get(self, "user_email_verified")

    @user_email_verified.setter
    def user_email_verified(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_email_verified", value)

    @property
    @pulumi.getter(name="userIdentityProviderLink")
    def user_identity_provider_link(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is linked to an identity provider
        """
        return pulumi.get(self, "user_identity_provider_link")

    @user_identity_provider_link.setter
    def user_identity_provider_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_identity_provider_link", value)

    @property
    @pulumi.getter(name="userIdentityProviderUnlink")
    def user_identity_provider_unlink(self) -> Optional[pulumi.Input[bool]]:
        """
        When a link to an identity provider is removed
        """
        return pulumi.get(self, "user_identity_provider_unlink")

    @user_identity_provider_unlink.setter
    def user_identity_provider_unlink(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_identity_provider_unlink", value)

    @property
    @pulumi.getter(name="userLoginFailed")
    def user_login_failed(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user fails a login request
        """
        return pulumi.get(self, "user_login_failed")

    @user_login_failed.setter
    def user_login_failed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_failed", value)

    @property
    @pulumi.getter(name="userLoginIdDuplicateCreate")
    def user_login_id_duplicate_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When a request to create a user with a login Id (email or username) which is already in use has been received
        """
        return pulumi.get(self, "user_login_id_duplicate_create")

    @user_login_id_duplicate_create.setter
    def user_login_id_duplicate_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_id_duplicate_create", value)

    @property
    @pulumi.getter(name="userLoginIdDuplicateUpdate")
    def user_login_id_duplicate_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a request to update a user and change their login Id (email or username) to one that is already in use has been received
        """
        return pulumi.get(self, "user_login_id_duplicate_update")

    @user_login_id_duplicate_update.setter
    def user_login_id_duplicate_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_id_duplicate_update", value)

    @property
    @pulumi.getter(name="userLoginNewDevice")
    def user_login_new_device(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user begins a login request with a new device
        """
        return pulumi.get(self, "user_login_new_device")

    @user_login_new_device.setter
    def user_login_new_device(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_new_device", value)

    @property
    @pulumi.getter(name="userLoginSuccess")
    def user_login_success(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user completes a login request
        """
        return pulumi.get(self, "user_login_success")

    @user_login_success.setter
    def user_login_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_success", value)

    @property
    @pulumi.getter(name="userLoginSuspicious")
    def user_login_suspicious(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user logs in and is considered to be a potential threat
        """
        return pulumi.get(self, "user_login_suspicious")

    @user_login_suspicious.setter
    def user_login_suspicious(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_login_suspicious", value)

    @property
    @pulumi.getter(name="userPasswordBreach")
    def user_password_breach(self) -> Optional[pulumi.Input[bool]]:
        """
        When Reactor detects a user is using a potentially breached password (requires an activated license)
        """
        return pulumi.get(self, "user_password_breach")

    @user_password_breach.setter
    def user_password_breach(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_password_breach", value)

    @property
    @pulumi.getter(name="userPasswordResetSend")
    def user_password_reset_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When a forgot password email has been sent to a user
        """
        return pulumi.get(self, "user_password_reset_send")

    @user_password_reset_send.setter
    def user_password_reset_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_password_reset_send", value)

    @property
    @pulumi.getter(name="userPasswordResetStart")
    def user_password_reset_start(self) -> Optional[pulumi.Input[bool]]:
        """
        When the process to reset a user password has started
        """
        return pulumi.get(self, "user_password_reset_start")

    @user_password_reset_start.setter
    def user_password_reset_start(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_password_reset_start", value)

    @property
    @pulumi.getter(name="userPasswordResetSuccess")
    def user_password_reset_success(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user has successfully reset their password
        """
        return pulumi.get(self, "user_password_reset_success")

    @user_password_reset_success.setter
    def user_password_reset_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_password_reset_success", value)

    @property
    @pulumi.getter(name="userPasswordUpdate")
    def user_password_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user has updated their password
        """
        return pulumi.get(self, "user_password_update")

    @user_password_update.setter
    def user_password_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_password_update", value)

    @property
    @pulumi.getter(name="userReactivate")
    def user_reactivate(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is reactivated
        """
        return pulumi.get(self, "user_reactivate")

    @user_reactivate.setter
    def user_reactivate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_reactivate", value)

    @property
    @pulumi.getter(name="userRegistrationCreate")
    def user_registration_create(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration is created
        """
        return pulumi.get(self, "user_registration_create")

    @user_registration_create.setter
    def user_registration_create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_create", value)

    @property
    @pulumi.getter(name="userRegistrationCreateComplete")
    def user_registration_create_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration create transaction has completed
        """
        return pulumi.get(self, "user_registration_create_complete")

    @user_registration_create_complete.setter
    def user_registration_create_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_create_complete", value)

    @property
    @pulumi.getter(name="userRegistrationDelete")
    def user_registration_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration is deleted
        """
        return pulumi.get(self, "user_registration_delete")

    @user_registration_delete.setter
    def user_registration_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_delete", value)

    @property
    @pulumi.getter(name="userRegistrationDeleteComplete")
    def user_registration_delete_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration delete transaction has completed
        """
        return pulumi.get(self, "user_registration_delete_complete")

    @user_registration_delete_complete.setter
    def user_registration_delete_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_delete_complete", value)

    @property
    @pulumi.getter(name="userRegistrationUpdate")
    def user_registration_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration is updated
        """
        return pulumi.get(self, "user_registration_update")

    @user_registration_update.setter
    def user_registration_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_update", value)

    @property
    @pulumi.getter(name="userRegistrationUpdateComplete")
    def user_registration_update_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user registration update transaction has completed
        """
        return pulumi.get(self, "user_registration_update_complete")

    @user_registration_update_complete.setter
    def user_registration_update_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_update_complete", value)

    @property
    @pulumi.getter(name="userRegistrationVerified")
    def user_registration_verified(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user completes registration verification
        """
        return pulumi.get(self, "user_registration_verified")

    @user_registration_verified.setter
    def user_registration_verified(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_registration_verified", value)

    @property
    @pulumi.getter(name="userTwoFactorMethodAdd")
    def user_two_factor_method_add(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user has added a two-factor method
        """
        return pulumi.get(self, "user_two_factor_method_add")

    @user_two_factor_method_add.setter
    def user_two_factor_method_add(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_two_factor_method_add", value)

    @property
    @pulumi.getter(name="userTwoFactorMethodRemove")
    def user_two_factor_method_remove(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user has removed a two-factor method
        """
        return pulumi.get(self, "user_two_factor_method_remove")

    @user_two_factor_method_remove.setter
    def user_two_factor_method_remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_two_factor_method_remove", value)

    @property
    @pulumi.getter(name="userUpdate")
    def user_update(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user is updated
        """
        return pulumi.get(self, "user_update")

    @user_update.setter
    def user_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_update", value)

    @property
    @pulumi.getter(name="userUpdateComplete")
    def user_update_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        When a user update transaction has completed
        """
        return pulumi.get(self, "user_update_complete")

    @user_update_complete.setter
    def user_update_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_update_complete", value)


@pulumi.input_type
class GetFormFieldValidatorArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 expression: Optional[str] = None):
        """
        :param bool enabled: Determines if user input should be validated.
        :param str expression: A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if user input should be validated.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class GetFormStepArgs:
    def __init__(__self__, *,
                 fields: Sequence[str]):
        pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Sequence[str]:
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Sequence[str]):
        pulumi.set(self, "fields", value)


