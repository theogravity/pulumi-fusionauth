# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'FusionAuthApiKeyPermissionsEndpoint',
    'FusionAuthApplicationAccessControlConfiguration',
    'FusionAuthApplicationCleanSpeakConfiguration',
    'FusionAuthApplicationCleanSpeakConfigurationUsernameModeration',
    'FusionAuthApplicationEmailConfiguration',
    'FusionAuthApplicationFormConfiguration',
    'FusionAuthApplicationJwtConfiguration',
    'FusionAuthApplicationLambdaConfiguration',
    'FusionAuthApplicationLoginConfiguration',
    'FusionAuthApplicationMultiFactorConfiguration',
    'FusionAuthApplicationOauthConfiguration',
    'FusionAuthApplicationRegistrationConfiguration',
    'FusionAuthApplicationRegistrationConfigurationBirthDate',
    'FusionAuthApplicationRegistrationConfigurationFirstName',
    'FusionAuthApplicationRegistrationConfigurationFullName',
    'FusionAuthApplicationRegistrationConfigurationLastName',
    'FusionAuthApplicationRegistrationConfigurationMiddleName',
    'FusionAuthApplicationRegistrationConfigurationMobilePhone',
    'FusionAuthApplicationRegistrationDeletePolicy',
    'FusionAuthApplicationSamlv2Configuration',
    'FusionAuthApplicationSamlv2ConfigurationLogout',
    'FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout',
    'FusionAuthEntityTypeJwtConfiguration',
    'FusionAuthFormFieldValidator',
    'FusionAuthFormStep',
    'FusionAuthIdpAppleApplicationConfiguration',
    'FusionAuthIdpAppleTenantConfiguration',
    'FusionAuthIdpExternalJwtApplicationConfiguration',
    'FusionAuthIdpExternalJwtTenantConfiguration',
    'FusionAuthIdpFacebookApplicationConfiguration',
    'FusionAuthIdpFacebookTenantConfiguration',
    'FusionAuthIdpGoogleApplicationConfiguration',
    'FusionAuthIdpGoogleTenantConfiguration',
    'FusionAuthIdpLinkedInApplicationConfiguration',
    'FusionAuthIdpLinkedInTenantConfiguration',
    'FusionAuthIdpOpenIdConnectApplicationConfiguration',
    'FusionAuthIdpOpenIdConnectTenantConfiguration',
    'FusionAuthIdpPsnApplicationConfiguration',
    'FusionAuthIdpPsnTenantConfiguration',
    'FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration',
    'FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration',
    'FusionAuthIdpSamlv2ApplicationConfiguration',
    'FusionAuthIdpSamlv2TenantConfiguration',
    'FusionAuthIdpSteamApplicationConfiguration',
    'FusionAuthIdpSteamTenantConfiguration',
    'FusionAuthIdpTwitchApplicationConfiguration',
    'FusionAuthIdpTwitchTenantConfiguration',
    'FusionAuthIdpXBoxApplicationConfiguration',
    'FusionAuthIdpXBoxTenantConfiguration',
    'FusionAuthSystemConfigurationAuditLogConfiguration',
    'FusionAuthSystemConfigurationAuditLogConfigurationDelete',
    'FusionAuthSystemConfigurationCorsConfiguration',
    'FusionAuthSystemConfigurationEventLogConfiguration',
    'FusionAuthSystemConfigurationLoginRecordConfiguration',
    'FusionAuthSystemConfigurationLoginRecordConfigurationDelete',
    'FusionAuthSystemConfigurationUiConfiguration',
    'FusionAuthTenantAccessControlConfiguration',
    'FusionAuthTenantCaptchaConfiguration',
    'FusionAuthTenantConnectorPolicy',
    'FusionAuthTenantEmailConfiguration',
    'FusionAuthTenantEmailConfigurationUnverified',
    'FusionAuthTenantEventConfiguration',
    'FusionAuthTenantExternalIdentifierConfiguration',
    'FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator',
    'FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator',
    'FusionAuthTenantFailedAuthenticationConfiguration',
    'FusionAuthTenantFamilyConfiguration',
    'FusionAuthTenantFormConfiguration',
    'FusionAuthTenantJwtConfiguration',
    'FusionAuthTenantLoginConfiguration',
    'FusionAuthTenantMaximumPasswordAge',
    'FusionAuthTenantMinimumPasswordAge',
    'FusionAuthTenantMultiFactorConfiguration',
    'FusionAuthTenantMultiFactorConfigurationAuthenticator',
    'FusionAuthTenantMultiFactorConfigurationEmail',
    'FusionAuthTenantMultiFactorConfigurationSms',
    'FusionAuthTenantOauthConfiguration',
    'FusionAuthTenantPasswordEncryptionConfiguration',
    'FusionAuthTenantPasswordValidationRules',
    'FusionAuthTenantPasswordValidationRulesBreachDetection',
    'FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords',
    'FusionAuthTenantRateLimitConfiguration',
    'FusionAuthTenantRateLimitConfigurationFailedLogin',
    'FusionAuthTenantRateLimitConfigurationForgotPassword',
    'FusionAuthTenantRateLimitConfigurationSendEmailVerification',
    'FusionAuthTenantRateLimitConfigurationSendPasswordless',
    'FusionAuthTenantRateLimitConfigurationSendRegistrationVerification',
    'FusionAuthTenantRateLimitConfigurationSendTwoFactor',
    'FusionAuthTenantRegistrationConfiguration',
    'FusionAuthTenantUserDeletePolicy',
    'FusionAuthTenantUsernameConfiguration',
    'FusionAuthTenantUsernameConfigurationUnique',
    'FusionAuthUserActionOption',
    'FusionAuthUserTwoFactorMethod',
    'FusionAuthWebhookEventsEnabled',
    'GetFormFieldValidatorResult',
    'GetFormStepResult',
]

@pulumi.output_type
class FusionAuthApiKeyPermissionsEndpoint(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 delete: Optional[bool] = None,
                 get: Optional[bool] = None,
                 patch: Optional[bool] = None,
                 post: Optional[bool] = None,
                 put: Optional[bool] = None):
        """
        :param bool delete: HTTP DELETE Verb.
        :param bool get: HTTP GET Verb.
        :param bool patch: HTTP PATCH Verb
        :param bool post: HTTP POST Verb
        :param bool put: HTTP PUT Verb
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if get is not None:
            pulumi.set(__self__, "get", get)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if put is not None:
            pulumi.set(__self__, "put", put)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def delete(self) -> Optional[bool]:
        """
        HTTP DELETE Verb.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def get(self) -> Optional[bool]:
        """
        HTTP GET Verb.
        """
        return pulumi.get(self, "get")

    @property
    @pulumi.getter
    def patch(self) -> Optional[bool]:
        """
        HTTP PATCH Verb
        """
        return pulumi.get(self, "patch")

    @property
    @pulumi.getter
    def post(self) -> Optional[bool]:
        """
        HTTP POST Verb
        """
        return pulumi.get(self, "post")

    @property
    @pulumi.getter
    def put(self) -> Optional[bool]:
        """
        HTTP PUT Verb
        """
        return pulumi.get(self, "put")


@pulumi.output_type
class FusionAuthApplicationAccessControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uiIpAccessControlListId":
            suggest = "ui_ip_access_control_list_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationAccessControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationAccessControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationAccessControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ui_ip_access_control_list_id: Optional[str] = None):
        """
        :param str ui_ip_access_control_list_id: The Id of the IP Access Control List limiting access to this application.
        """
        if ui_ip_access_control_list_id is not None:
            pulumi.set(__self__, "ui_ip_access_control_list_id", ui_ip_access_control_list_id)

    @property
    @pulumi.getter(name="uiIpAccessControlListId")
    def ui_ip_access_control_list_id(self) -> Optional[str]:
        """
        The Id of the IP Access Control List limiting access to this application.
        """
        return pulumi.get(self, "ui_ip_access_control_list_id")


@pulumi.output_type
class FusionAuthApplicationCleanSpeakConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationIds":
            suggest = "application_ids"
        elif key == "usernameModeration":
            suggest = "username_moderation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationCleanSpeakConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationCleanSpeakConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationCleanSpeakConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_ids: Optional[Sequence[str]] = None,
                 username_moderation: Optional['outputs.FusionAuthApplicationCleanSpeakConfigurationUsernameModeration'] = None):
        """
        :param Sequence[str] application_ids: An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.
        """
        if application_ids is not None:
            pulumi.set(__self__, "application_ids", application_ids)
        if username_moderation is not None:
            pulumi.set(__self__, "username_moderation", username_moderation)

    @property
    @pulumi.getter(name="applicationIds")
    def application_ids(self) -> Optional[Sequence[str]]:
        """
        An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.
        """
        return pulumi.get(self, "application_ids")

    @property
    @pulumi.getter(name="usernameModeration")
    def username_moderation(self) -> Optional['outputs.FusionAuthApplicationCleanSpeakConfigurationUsernameModeration']:
        return pulumi.get(self, "username_moderation")


@pulumi.output_type
class FusionAuthApplicationCleanSpeakConfigurationUsernameModeration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationCleanSpeakConfigurationUsernameModeration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationCleanSpeakConfigurationUsernameModeration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationCleanSpeakConfigurationUsernameModeration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str application_id: The Id of the CleanSpeak application that usernames are sent to for moderation.
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        The Id of the CleanSpeak application that usernames are sent to for moderation.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthApplicationEmailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailUpdateTemplateId":
            suggest = "email_update_template_id"
        elif key == "emailVerificationTemplateId":
            suggest = "email_verification_template_id"
        elif key == "emailVerifiedTemplateId":
            suggest = "email_verified_template_id"
        elif key == "forgotPasswordTemplateId":
            suggest = "forgot_password_template_id"
        elif key == "loginIdInUseOnCreateTemplateId":
            suggest = "login_id_in_use_on_create_template_id"
        elif key == "loginIdInUseOnUpdateTemplateId":
            suggest = "login_id_in_use_on_update_template_id"
        elif key == "loginNewDeviceTemplateId":
            suggest = "login_new_device_template_id"
        elif key == "loginSuspiciousTemplateId":
            suggest = "login_suspicious_template_id"
        elif key == "passwordResetSuccessTemplateId":
            suggest = "password_reset_success_template_id"
        elif key == "passwordUpdateTemplateId":
            suggest = "password_update_template_id"
        elif key == "passwordlessEmailTemplateId":
            suggest = "passwordless_email_template_id"
        elif key == "setPasswordEmailTemplateId":
            suggest = "set_password_email_template_id"
        elif key == "twoFactorMethodAddTemplateId":
            suggest = "two_factor_method_add_template_id"
        elif key == "twoFactorMethodRemoveTemplateId":
            suggest = "two_factor_method_remove_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationEmailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationEmailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationEmailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_update_template_id: Optional[str] = None,
                 email_verification_template_id: Optional[str] = None,
                 email_verified_template_id: Optional[str] = None,
                 forgot_password_template_id: Optional[str] = None,
                 login_id_in_use_on_create_template_id: Optional[str] = None,
                 login_id_in_use_on_update_template_id: Optional[str] = None,
                 login_new_device_template_id: Optional[str] = None,
                 login_suspicious_template_id: Optional[str] = None,
                 password_reset_success_template_id: Optional[str] = None,
                 password_update_template_id: Optional[str] = None,
                 passwordless_email_template_id: Optional[str] = None,
                 set_password_email_template_id: Optional[str] = None,
                 two_factor_method_add_template_id: Optional[str] = None,
                 two_factor_method_remove_template_id: Optional[str] = None):
        """
        :param str email_update_template_id: The Id of the Email Template used to send emails to users when their email address is updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str email_verification_template_id: The Id of the Email Template used to send emails to users to verify that their email address is valid. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str email_verified_template_id: The Id of the Email Template used to verify user emails. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str forgot_password_template_id: The Id of the Email Template that is used when a user is sent a forgot password email. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str login_id_in_use_on_create_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str login_id_in_use_on_update_template_id: The Id of the Email Template used to send emails to users when another user attempts to update an existing account to use their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str login_new_device_template_id: The Id of the Email Template used to send emails to users when they log in on a new device. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str login_suspicious_template_id: The Id of the Email Template used to send emails to users when a suspicious login occurs. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str password_reset_success_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been reset. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str password_update_template_id: The Id of the Email Template used to send emails to users when their password has been updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str passwordless_email_template_id: The Id of the Passwordless Email Template, sent to users when they start a passwordless login. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str set_password_email_template_id: The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str two_factor_method_add_template_id: The Id of the Email Template used to send emails to users when a MFA method has been added to their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        :param str two_factor_method_remove_template_id: The Id of the Email Template used to send emails to users when a MFA method has been removed from their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        if email_update_template_id is not None:
            pulumi.set(__self__, "email_update_template_id", email_update_template_id)
        if email_verification_template_id is not None:
            pulumi.set(__self__, "email_verification_template_id", email_verification_template_id)
        if email_verified_template_id is not None:
            pulumi.set(__self__, "email_verified_template_id", email_verified_template_id)
        if forgot_password_template_id is not None:
            pulumi.set(__self__, "forgot_password_template_id", forgot_password_template_id)
        if login_id_in_use_on_create_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_create_template_id", login_id_in_use_on_create_template_id)
        if login_id_in_use_on_update_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_update_template_id", login_id_in_use_on_update_template_id)
        if login_new_device_template_id is not None:
            pulumi.set(__self__, "login_new_device_template_id", login_new_device_template_id)
        if login_suspicious_template_id is not None:
            pulumi.set(__self__, "login_suspicious_template_id", login_suspicious_template_id)
        if password_reset_success_template_id is not None:
            pulumi.set(__self__, "password_reset_success_template_id", password_reset_success_template_id)
        if password_update_template_id is not None:
            pulumi.set(__self__, "password_update_template_id", password_update_template_id)
        if passwordless_email_template_id is not None:
            pulumi.set(__self__, "passwordless_email_template_id", passwordless_email_template_id)
        if set_password_email_template_id is not None:
            pulumi.set(__self__, "set_password_email_template_id", set_password_email_template_id)
        if two_factor_method_add_template_id is not None:
            pulumi.set(__self__, "two_factor_method_add_template_id", two_factor_method_add_template_id)
        if two_factor_method_remove_template_id is not None:
            pulumi.set(__self__, "two_factor_method_remove_template_id", two_factor_method_remove_template_id)

    @property
    @pulumi.getter(name="emailUpdateTemplateId")
    def email_update_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when their email address is updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_update_template_id")

    @property
    @pulumi.getter(name="emailVerificationTemplateId")
    def email_verification_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users to verify that their email address is valid. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_verification_template_id")

    @property
    @pulumi.getter(name="emailVerifiedTemplateId")
    def email_verified_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to verify user emails. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "email_verified_template_id")

    @property
    @pulumi.getter(name="forgotPasswordTemplateId")
    def forgot_password_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "forgot_password_template_id")

    @property
    @pulumi.getter(name="loginIdInUseOnCreateTemplateId")
    def login_id_in_use_on_create_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_id_in_use_on_create_template_id")

    @property
    @pulumi.getter(name="loginIdInUseOnUpdateTemplateId")
    def login_id_in_use_on_update_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to update an existing account to use their login Id. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_id_in_use_on_update_template_id")

    @property
    @pulumi.getter(name="loginNewDeviceTemplateId")
    def login_new_device_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when they log in on a new device. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_new_device_template_id")

    @property
    @pulumi.getter(name="loginSuspiciousTemplateId")
    def login_suspicious_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a suspicious login occurs. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "login_suspicious_template_id")

    @property
    @pulumi.getter(name="passwordResetSuccessTemplateId")
    def password_reset_success_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been reset. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "password_reset_success_template_id")

    @property
    @pulumi.getter(name="passwordUpdateTemplateId")
    def password_update_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when their password has been updated. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "password_update_template_id")

    @property
    @pulumi.getter(name="passwordlessEmailTemplateId")
    def passwordless_email_template_id(self) -> Optional[str]:
        """
        The Id of the Passwordless Email Template, sent to users when they start a passwordless login. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "passwordless_email_template_id")

    @property
    @pulumi.getter(name="setPasswordEmailTemplateId")
    def set_password_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "set_password_email_template_id")

    @property
    @pulumi.getter(name="twoFactorMethodAddTemplateId")
    def two_factor_method_add_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been added to their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "two_factor_method_add_template_id")

    @property
    @pulumi.getter(name="twoFactorMethodRemoveTemplateId")
    def two_factor_method_remove_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been removed from their account. When configured, this value will take precedence over the same configuration from the Tenant when an application context is known.
        """
        return pulumi.get(self, "two_factor_method_remove_template_id")


@pulumi.output_type
class FusionAuthApplicationFormConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminRegistrationFormId":
            suggest = "admin_registration_form_id"
        elif key == "selfServiceFormId":
            suggest = "self_service_form_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationFormConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationFormConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationFormConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_registration_form_id: Optional[str] = None,
                 self_service_form_id: Optional[str] = None):
        """
        :param str admin_registration_form_id: The unique Id of the form to use for the Add and Edit User Registration form when used in the FusionAuth admin UI.
        :param str self_service_form_id: The unique Id of the form to to enable authenticated users to manage their profile on the account page.
        """
        if admin_registration_form_id is not None:
            pulumi.set(__self__, "admin_registration_form_id", admin_registration_form_id)
        if self_service_form_id is not None:
            pulumi.set(__self__, "self_service_form_id", self_service_form_id)

    @property
    @pulumi.getter(name="adminRegistrationFormId")
    def admin_registration_form_id(self) -> Optional[str]:
        """
        The unique Id of the form to use for the Add and Edit User Registration form when used in the FusionAuth admin UI.
        """
        return pulumi.get(self, "admin_registration_form_id")

    @property
    @pulumi.getter(name="selfServiceFormId")
    def self_service_form_id(self) -> Optional[str]:
        """
        The unique Id of the form to to enable authenticated users to manage their profile on the account page.
        """
        return pulumi.get(self, "self_service_form_id")


@pulumi.output_type
class FusionAuthApplicationJwtConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenId":
            suggest = "access_token_id"
        elif key == "idTokenKeyId":
            suggest = "id_token_key_id"
        elif key == "refreshTokenTtlMinutes":
            suggest = "refresh_token_ttl_minutes"
        elif key == "ttlSeconds":
            suggest = "ttl_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationJwtConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationJwtConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationJwtConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id_token_key_id: Optional[str] = None,
                 refresh_token_ttl_minutes: Optional[int] = None,
                 ttl_seconds: Optional[int] = None):
        """
        :param str access_token_id: The Id of the signing key used to sign the access token.
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param str id_token_key_id: The Id of the signing key used to sign the Id token.
        :param int refresh_token_ttl_minutes: The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT.
        :param int ttl_seconds: The length of time in seconds the JWT will live before it is expired and no longer valid.
        """
        if access_token_id is not None:
            pulumi.set(__self__, "access_token_id", access_token_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id_token_key_id is not None:
            pulumi.set(__self__, "id_token_key_id", id_token_key_id)
        if refresh_token_ttl_minutes is not None:
            pulumi.set(__self__, "refresh_token_ttl_minutes", refresh_token_ttl_minutes)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @property
    @pulumi.getter(name="accessTokenId")
    def access_token_id(self) -> Optional[str]:
        """
        The Id of the signing key used to sign the access token.
        """
        return pulumi.get(self, "access_token_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="idTokenKeyId")
    def id_token_key_id(self) -> Optional[str]:
        """
        The Id of the signing key used to sign the Id token.
        """
        return pulumi.get(self, "id_token_key_id")

    @property
    @pulumi.getter(name="refreshTokenTtlMinutes")
    def refresh_token_ttl_minutes(self) -> Optional[int]:
        """
        The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT.
        """
        return pulumi.get(self, "refresh_token_ttl_minutes")

    @property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[int]:
        """
        The length of time in seconds the JWT will live before it is expired and no longer valid.
        """
        return pulumi.get(self, "ttl_seconds")


@pulumi.output_type
class FusionAuthApplicationLambdaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenPopulateId":
            suggest = "access_token_populate_id"
        elif key == "idTokenPopulateId":
            suggest = "id_token_populate_id"
        elif key == "samlv2PopulateId":
            suggest = "samlv2_populate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationLambdaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationLambdaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationLambdaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_populate_id: Optional[str] = None,
                 id_token_populate_id: Optional[str] = None,
                 samlv2_populate_id: Optional[str] = None):
        """
        :param str access_token_populate_id: The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API.
        :param str id_token_populate_id: The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request.
        :param str samlv2_populate_id: The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request.
        """
        if access_token_populate_id is not None:
            pulumi.set(__self__, "access_token_populate_id", access_token_populate_id)
        if id_token_populate_id is not None:
            pulumi.set(__self__, "id_token_populate_id", id_token_populate_id)
        if samlv2_populate_id is not None:
            pulumi.set(__self__, "samlv2_populate_id", samlv2_populate_id)

    @property
    @pulumi.getter(name="accessTokenPopulateId")
    def access_token_populate_id(self) -> Optional[str]:
        """
        The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API.
        """
        return pulumi.get(self, "access_token_populate_id")

    @property
    @pulumi.getter(name="idTokenPopulateId")
    def id_token_populate_id(self) -> Optional[str]:
        """
        The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request.
        """
        return pulumi.get(self, "id_token_populate_id")

    @property
    @pulumi.getter(name="samlv2PopulateId")
    def samlv2_populate_id(self) -> Optional[str]:
        """
        The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request.
        """
        return pulumi.get(self, "samlv2_populate_id")


@pulumi.output_type
class FusionAuthApplicationLoginConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowTokenRefresh":
            suggest = "allow_token_refresh"
        elif key == "generateRefreshTokens":
            suggest = "generate_refresh_tokens"
        elif key == "requireAuthentication":
            suggest = "require_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationLoginConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationLoginConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationLoginConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_token_refresh: Optional[bool] = None,
                 generate_refresh_tokens: Optional[bool] = None,
                 require_authentication: Optional[bool] = None):
        """
        :param bool allow_token_refresh: Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.
        :param bool generate_refresh_tokens: Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        :param bool require_authentication: Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.
        """
        if allow_token_refresh is not None:
            pulumi.set(__self__, "allow_token_refresh", allow_token_refresh)
        if generate_refresh_tokens is not None:
            pulumi.set(__self__, "generate_refresh_tokens", generate_refresh_tokens)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)

    @property
    @pulumi.getter(name="allowTokenRefresh")
    def allow_token_refresh(self) -> Optional[bool]:
        """
        Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.
        """
        return pulumi.get(self, "allow_token_refresh")

    @property
    @pulumi.getter(name="generateRefreshTokens")
    def generate_refresh_tokens(self) -> Optional[bool]:
        """
        Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        """
        return pulumi.get(self, "generate_refresh_tokens")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.
        """
        return pulumi.get(self, "require_authentication")


@pulumi.output_type
class FusionAuthApplicationMultiFactorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailTemplateId":
            suggest = "email_template_id"
        elif key == "loginPolicy":
            suggest = "login_policy"
        elif key == "smsTemplateId":
            suggest = "sms_template_id"
        elif key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationMultiFactorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationMultiFactorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationMultiFactorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_template_id: Optional[str] = None,
                 login_policy: Optional[str] = None,
                 sms_template_id: Optional[str] = None,
                 trust_policy: Optional[str] = None):
        """
        :param str email_template_id: The Id of the email template that is used when notifying a user to complete a multi-factor authentication request.
        :param str login_policy: When enabled and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When disabled, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When required, the user will be required to complete a two-factor challenge during login. Possible values are `Enabled`, `Disabled` or `Required`.
        :param str sms_template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        :param str trust_policy: When `multi_factor_configuration.login_policy` is set to `Enabled`, this trust policy is utilized when determining if a user must complete a two-factor challenge during login. Possible values are `Any`, `This` or `None`.
        """
        if email_template_id is not None:
            pulumi.set(__self__, "email_template_id", email_template_id)
        if login_policy is not None:
            pulumi.set(__self__, "login_policy", login_policy)
        if sms_template_id is not None:
            pulumi.set(__self__, "sms_template_id", sms_template_id)
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="emailTemplateId")
    def email_template_id(self) -> Optional[str]:
        """
        The Id of the email template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "email_template_id")

    @property
    @pulumi.getter(name="loginPolicy")
    def login_policy(self) -> Optional[str]:
        """
        When enabled and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When disabled, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When required, the user will be required to complete a two-factor challenge during login. Possible values are `Enabled`, `Disabled` or `Required`.
        """
        return pulumi.get(self, "login_policy")

    @property
    @pulumi.getter(name="smsTemplateId")
    def sms_template_id(self) -> Optional[str]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "sms_template_id")

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        """
        When `multi_factor_configuration.login_policy` is set to `Enabled`, this trust policy is utilized when determining if a user must complete a two-factor challenge during login. Possible values are `Any`, `This` or `None`.
        """
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class FusionAuthApplicationOauthConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedOriginUrls":
            suggest = "authorized_origin_urls"
        elif key == "authorizedRedirectUrls":
            suggest = "authorized_redirect_urls"
        elif key == "authorizedUrlValidationPolicy":
            suggest = "authorized_url_validation_policy"
        elif key == "clientAuthenticationPolicy":
            suggest = "client_authentication_policy"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "deviceVerificationUrl":
            suggest = "device_verification_url"
        elif key == "enabledGrants":
            suggest = "enabled_grants"
        elif key == "generateRefreshTokens":
            suggest = "generate_refresh_tokens"
        elif key == "logoutBehavior":
            suggest = "logout_behavior"
        elif key == "logoutUrl":
            suggest = "logout_url"
        elif key == "proofKeyForCodeExchangePolicy":
            suggest = "proof_key_for_code_exchange_policy"
        elif key == "requireClientAuthentication":
            suggest = "require_client_authentication"
        elif key == "requireRegistration":
            suggest = "require_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationOauthConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationOauthConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationOauthConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_origin_urls: Optional[Sequence[str]] = None,
                 authorized_redirect_urls: Optional[Sequence[str]] = None,
                 authorized_url_validation_policy: Optional[str] = None,
                 client_authentication_policy: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 debug: Optional[bool] = None,
                 device_verification_url: Optional[str] = None,
                 enabled_grants: Optional[Sequence[str]] = None,
                 generate_refresh_tokens: Optional[bool] = None,
                 logout_behavior: Optional[str] = None,
                 logout_url: Optional[str] = None,
                 proof_key_for_code_exchange_policy: Optional[str] = None,
                 require_client_authentication: Optional[bool] = None,
                 require_registration: Optional[bool] = None):
        """
        :param Sequence[str] authorized_origin_urls: An array of URLs that are the authorized origins for FusionAuth OAuth.
        :param Sequence[str] authorized_redirect_urls: An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        :param str authorized_url_validation_policy: Determines whether wildcard expressions will be allowed in the authorized_redirect_urls and authorized_origin_urls.
        :param str client_authentication_policy: Determines the client authentication requirements for the OAuth 2.0 Token endpoint.
        :param str client_secret: The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored.
        :param bool debug: Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        :param str device_verification_url: The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled.
        :param Sequence[str] enabled_grants: The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.
        :param bool generate_refresh_tokens: Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        :param str logout_behavior: Behavior when /oauth2/logout is called.
        :param str logout_url: The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        :param str proof_key_for_code_exchange_policy: Determines the PKCE requirements when using the authorization code grant.
        :param bool require_client_authentication: Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data.
        :param bool require_registration: When enabled the user will be required to be registered, or complete registration before redirecting to the configured callback in the authorization code grant or the implicit grant. This configuration does not currently apply to any other grant.
        """
        if authorized_origin_urls is not None:
            pulumi.set(__self__, "authorized_origin_urls", authorized_origin_urls)
        if authorized_redirect_urls is not None:
            pulumi.set(__self__, "authorized_redirect_urls", authorized_redirect_urls)
        if authorized_url_validation_policy is not None:
            pulumi.set(__self__, "authorized_url_validation_policy", authorized_url_validation_policy)
        if client_authentication_policy is not None:
            pulumi.set(__self__, "client_authentication_policy", client_authentication_policy)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if device_verification_url is not None:
            pulumi.set(__self__, "device_verification_url", device_verification_url)
        if enabled_grants is not None:
            pulumi.set(__self__, "enabled_grants", enabled_grants)
        if generate_refresh_tokens is not None:
            pulumi.set(__self__, "generate_refresh_tokens", generate_refresh_tokens)
        if logout_behavior is not None:
            pulumi.set(__self__, "logout_behavior", logout_behavior)
        if logout_url is not None:
            pulumi.set(__self__, "logout_url", logout_url)
        if proof_key_for_code_exchange_policy is not None:
            pulumi.set(__self__, "proof_key_for_code_exchange_policy", proof_key_for_code_exchange_policy)
        if require_client_authentication is not None:
            pulumi.set(__self__, "require_client_authentication", require_client_authentication)
        if require_registration is not None:
            pulumi.set(__self__, "require_registration", require_registration)

    @property
    @pulumi.getter(name="authorizedOriginUrls")
    def authorized_origin_urls(self) -> Optional[Sequence[str]]:
        """
        An array of URLs that are the authorized origins for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_origin_urls")

    @property
    @pulumi.getter(name="authorizedRedirectUrls")
    def authorized_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_redirect_urls")

    @property
    @pulumi.getter(name="authorizedUrlValidationPolicy")
    def authorized_url_validation_policy(self) -> Optional[str]:
        """
        Determines whether wildcard expressions will be allowed in the authorized_redirect_urls and authorized_origin_urls.
        """
        return pulumi.get(self, "authorized_url_validation_policy")

    @property
    @pulumi.getter(name="clientAuthenticationPolicy")
    def client_authentication_policy(self) -> Optional[str]:
        """
        Determines the client authentication requirements for the OAuth 2.0 Token endpoint.
        """
        return pulumi.get(self, "client_authentication_policy")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter(name="deviceVerificationUrl")
    def device_verification_url(self) -> Optional[str]:
        """
        The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled.
        """
        return pulumi.get(self, "device_verification_url")

    @property
    @pulumi.getter(name="enabledGrants")
    def enabled_grants(self) -> Optional[Sequence[str]]:
        """
        The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.
        """
        return pulumi.get(self, "enabled_grants")

    @property
    @pulumi.getter(name="generateRefreshTokens")
    def generate_refresh_tokens(self) -> Optional[bool]:
        """
        Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested.
        """
        return pulumi.get(self, "generate_refresh_tokens")

    @property
    @pulumi.getter(name="logoutBehavior")
    def logout_behavior(self) -> Optional[str]:
        """
        Behavior when /oauth2/logout is called.
        """
        return pulumi.get(self, "logout_behavior")

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[str]:
        """
        The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        """
        return pulumi.get(self, "logout_url")

    @property
    @pulumi.getter(name="proofKeyForCodeExchangePolicy")
    def proof_key_for_code_exchange_policy(self) -> Optional[str]:
        """
        Determines the PKCE requirements when using the authorization code grant.
        """
        return pulumi.get(self, "proof_key_for_code_exchange_policy")

    @property
    @pulumi.getter(name="requireClientAuthentication")
    def require_client_authentication(self) -> Optional[bool]:
        """
        Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data.
        """
        return pulumi.get(self, "require_client_authentication")

    @property
    @pulumi.getter(name="requireRegistration")
    def require_registration(self) -> Optional[bool]:
        """
        When enabled the user will be required to be registered, or complete registration before redirecting to the configured callback in the authorization code grant or the implicit grant. This configuration does not currently apply to any other grant.
        """
        return pulumi.get(self, "require_registration")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "birthDate":
            suggest = "birth_date"
        elif key == "confirmPassword":
            suggest = "confirm_password"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "formId":
            suggest = "form_id"
        elif key == "fullName":
            suggest = "full_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "loginIdType":
            suggest = "login_id_type"
        elif key == "middleName":
            suggest = "middle_name"
        elif key == "mobilePhone":
            suggest = "mobile_phone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationRegistrationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationRegistrationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationRegistrationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 birth_date: Optional['outputs.FusionAuthApplicationRegistrationConfigurationBirthDate'] = None,
                 confirm_password: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 first_name: Optional['outputs.FusionAuthApplicationRegistrationConfigurationFirstName'] = None,
                 form_id: Optional[str] = None,
                 full_name: Optional['outputs.FusionAuthApplicationRegistrationConfigurationFullName'] = None,
                 last_name: Optional['outputs.FusionAuthApplicationRegistrationConfigurationLastName'] = None,
                 login_id_type: Optional[str] = None,
                 middle_name: Optional['outputs.FusionAuthApplicationRegistrationConfigurationMiddleName'] = None,
                 mobile_phone: Optional['outputs.FusionAuthApplicationRegistrationConfigurationMobilePhone'] = None,
                 type: Optional[str] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param str form_id: The Id of an associated Form when using advanced registration configuration type. This field is required when application.registrationConfiguration.type is set to advanced.
        :param str login_id_type: The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique.
        :param str type: The type of registration flow.
        """
        if birth_date is not None:
            pulumi.set(__self__, "birth_date", birth_date)
        if confirm_password is not None:
            pulumi.set(__self__, "confirm_password", confirm_password)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if form_id is not None:
            pulumi.set(__self__, "form_id", form_id)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if login_id_type is not None:
            pulumi.set(__self__, "login_id_type", login_id_type)
        if middle_name is not None:
            pulumi.set(__self__, "middle_name", middle_name)
        if mobile_phone is not None:
            pulumi.set(__self__, "mobile_phone", mobile_phone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="birthDate")
    def birth_date(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationBirthDate']:
        return pulumi.get(self, "birth_date")

    @property
    @pulumi.getter(name="confirmPassword")
    def confirm_password(self) -> Optional[bool]:
        return pulumi.get(self, "confirm_password")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationFirstName']:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="formId")
    def form_id(self) -> Optional[str]:
        """
        The Id of an associated Form when using advanced registration configuration type. This field is required when application.registrationConfiguration.type is set to advanced.
        """
        return pulumi.get(self, "form_id")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationFullName']:
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationLastName']:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="loginIdType")
    def login_id_type(self) -> Optional[str]:
        """
        The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique.
        """
        return pulumi.get(self, "login_id_type")

    @property
    @pulumi.getter(name="middleName")
    def middle_name(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationMiddleName']:
        return pulumi.get(self, "middle_name")

    @property
    @pulumi.getter(name="mobilePhone")
    def mobile_phone(self) -> Optional['outputs.FusionAuthApplicationRegistrationConfigurationMobilePhone']:
        return pulumi.get(self, "mobile_phone")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of registration flow.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationBirthDate(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationFirstName(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationFullName(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationLastName(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationMiddleName(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationConfigurationMobilePhone(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class FusionAuthApplicationRegistrationDeletePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unverifiedEnabled":
            suggest = "unverified_enabled"
        elif key == "unverifiedNumberOfDaysToRetain":
            suggest = "unverified_number_of_days_to_retain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationRegistrationDeletePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationRegistrationDeletePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationRegistrationDeletePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unverified_enabled: Optional[bool] = None,
                 unverified_number_of_days_to_retain: Optional[int] = None):
        """
        :param bool unverified_enabled: Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days.
        :param int unverified_number_of_days_to_retain: The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0.
        """
        if unverified_enabled is not None:
            pulumi.set(__self__, "unverified_enabled", unverified_enabled)
        if unverified_number_of_days_to_retain is not None:
            pulumi.set(__self__, "unverified_number_of_days_to_retain", unverified_number_of_days_to_retain)

    @property
    @pulumi.getter(name="unverifiedEnabled")
    def unverified_enabled(self) -> Optional[bool]:
        """
        Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unverified_enabled")

    @property
    @pulumi.getter(name="unverifiedNumberOfDaysToRetain")
    def unverified_number_of_days_to_retain(self) -> Optional[int]:
        """
        The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0.
        """
        return pulumi.get(self, "unverified_number_of_days_to_retain")


@pulumi.output_type
class FusionAuthApplicationSamlv2Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedRedirectUrls":
            suggest = "authorized_redirect_urls"
        elif key == "callbackUrl":
            suggest = "callback_url"
        elif key == "defaultVerificationKeyId":
            suggest = "default_verification_key_id"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "logoutUrl":
            suggest = "logout_url"
        elif key == "requiredSignedRequests":
            suggest = "required_signed_requests"
        elif key == "xmlSignatureCanonicalizationMethod":
            suggest = "xml_signature_canonicalization_method"
        elif key == "xmlSignatureLocation":
            suggest = "xml_signature_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationSamlv2Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationSamlv2Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationSamlv2Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_redirect_urls: Sequence[str],
                 issuer: str,
                 audience: Optional[str] = None,
                 callback_url: Optional[str] = None,
                 debug: Optional[bool] = None,
                 default_verification_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 key_id: Optional[str] = None,
                 logout: Optional['outputs.FusionAuthApplicationSamlv2ConfigurationLogout'] = None,
                 logout_url: Optional[str] = None,
                 required_signed_requests: Optional[bool] = None,
                 xml_signature_canonicalization_method: Optional[str] = None,
                 xml_signature_location: Optional[str] = None):
        """
        :param Sequence[str] authorized_redirect_urls: An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        :param str issuer: The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login.
        :param str audience: The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response.
        :param str callback_url: The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML.
        :param bool debug: Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        :param str default_verification_key_id: The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param str key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param str logout_url: The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        :param bool required_signed_requests: If set to true, will force verification through the key store.
        :param str xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        :param str xml_signature_location: The location to place the XML signature when signing a successful SAML response.
        """
        pulumi.set(__self__, "authorized_redirect_urls", authorized_redirect_urls)
        pulumi.set(__self__, "issuer", issuer)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if callback_url is not None:
            pulumi.set(__self__, "callback_url", callback_url)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if default_verification_key_id is not None:
            pulumi.set(__self__, "default_verification_key_id", default_verification_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if logout is not None:
            pulumi.set(__self__, "logout", logout)
        if logout_url is not None:
            pulumi.set(__self__, "logout_url", logout_url)
        if required_signed_requests is not None:
            pulumi.set(__self__, "required_signed_requests", required_signed_requests)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)
        if xml_signature_location is not None:
            pulumi.set(__self__, "xml_signature_location", xml_signature_location)

    @property
    @pulumi.getter(name="authorizedRedirectUrls")
    def authorized_redirect_urls(self) -> Sequence[str]:
        """
        An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.
        """
        return pulumi.get(self, "authorized_redirect_urls")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> Optional[str]:
        """
        The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML.
        """
        return pulumi.get(self, "callback_url")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes.
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter(name="defaultVerificationKeyId")
    def default_verification_key_id(self) -> Optional[str]:
        """
        The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        """
        return pulumi.get(self, "default_verification_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def logout(self) -> Optional['outputs.FusionAuthApplicationSamlv2ConfigurationLogout']:
        return pulumi.get(self, "logout")

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[str]:
        """
        The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly.
        """
        return pulumi.get(self, "logout_url")

    @property
    @pulumi.getter(name="requiredSignedRequests")
    def required_signed_requests(self) -> Optional[bool]:
        """
        If set to true, will force verification through the key store.
        """
        return pulumi.get(self, "required_signed_requests")

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[str]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")

    @property
    @pulumi.getter(name="xmlSignatureLocation")
    def xml_signature_location(self) -> Optional[str]:
        """
        The location to place the XML signature when signing a successful SAML response.
        """
        return pulumi.get(self, "xml_signature_location")


@pulumi.output_type
class FusionAuthApplicationSamlv2ConfigurationLogout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultVerificationKeyId":
            suggest = "default_verification_key_id"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "requireSignedRequests":
            suggest = "require_signed_requests"
        elif key == "singleLogout":
            suggest = "single_logout"
        elif key == "xmlSignatureCanonicalizationMethod":
            suggest = "xml_signature_canonicalization_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationSamlv2ConfigurationLogout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationSamlv2ConfigurationLogout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationSamlv2ConfigurationLogout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: Optional[str] = None,
                 default_verification_key_id: Optional[str] = None,
                 key_id: Optional[str] = None,
                 require_signed_requests: Optional[bool] = None,
                 single_logout: Optional['outputs.FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout'] = None,
                 xml_signature_canonicalization_method: Optional[str] = None):
        """
        :param str behavior: This configuration is functionally equivalent to the Logout Behavior found in the OAuth2 configuration.
        :param str default_verification_key_id: The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        :param str key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param bool require_signed_requests: Set this parameter equal to true to require the SAML v2 Service Provider to sign the Logout request. When this value is true all Logout requests missing a signature will be rejected.
        :param str xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if default_verification_key_id is not None:
            pulumi.set(__self__, "default_verification_key_id", default_verification_key_id)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if require_signed_requests is not None:
            pulumi.set(__self__, "require_signed_requests", require_signed_requests)
        if single_logout is not None:
            pulumi.set(__self__, "single_logout", single_logout)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[str]:
        """
        This configuration is functionally equivalent to the Logout Behavior found in the OAuth2 configuration.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter(name="defaultVerificationKeyId")
    def default_verification_key_id(self) -> Optional[str]:
        """
        The unique Id of the Key used to verify the signature if the public key cannot be determined by the KeyInfo element when using POST bindings, or the key used to verify the signature when using HTTP Redirect bindings.
        """
        return pulumi.get(self, "default_verification_key_id")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="requireSignedRequests")
    def require_signed_requests(self) -> Optional[bool]:
        """
        Set this parameter equal to true to require the SAML v2 Service Provider to sign the Logout request. When this value is true all Logout requests missing a signature will be rejected.
        """
        return pulumi.get(self, "require_signed_requests")

    @property
    @pulumi.getter(name="singleLogout")
    def single_logout(self) -> Optional['outputs.FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout']:
        return pulumi.get(self, "single_logout")

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[str]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")


@pulumi.output_type
class FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "xmlSignatureCanonicalizationMethod":
            suggest = "xml_signature_canonicalization_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthApplicationSamlv2ConfigurationLogoutSingleLogout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 key_id: Optional[str] = None,
                 url: Optional[str] = None,
                 xml_signature_canonicalization_method: Optional[str] = None):
        """
        :param bool enabled: Whether or not SAML Single Logout for this SAML IdP is enabled.
        :param str key_id: The unique Id of the Key used to sign the SAML Single Logout response.
        :param str url: The URL at which you want to receive the LogoutRequest from FusionAuth.
        :param str xml_signature_canonicalization_method: The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if xml_signature_canonicalization_method is not None:
            pulumi.set(__self__, "xml_signature_canonicalization_method", xml_signature_canonicalization_method)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML Single Logout for this SAML IdP is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The unique Id of the Key used to sign the SAML Single Logout response.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL at which you want to receive the LogoutRequest from FusionAuth.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="xmlSignatureCanonicalizationMethod")
    def xml_signature_canonicalization_method(self) -> Optional[str]:
        """
        The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use.
        """
        return pulumi.get(self, "xml_signature_canonicalization_method")


@pulumi.output_type
class FusionAuthEntityTypeJwtConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenKeyId":
            suggest = "access_token_key_id"
        elif key == "timeToLiveInSeconds":
            suggest = "time_to_live_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthEntityTypeJwtConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthEntityTypeJwtConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthEntityTypeJwtConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 time_to_live_in_seconds: Optional[int] = None):
        """
        :param str access_token_key_id: The unique ID of the signing key used to sign the access token. Required when
               enabled is set to true.
        :param bool enabled: Indicates if this application is using the JWT configuration defined here or the global JWT
               configuration defined by the Tenant. If this is false the signing algorithm configured in the Tenant will be used.
               If true the signing algorithm defined in this application will be used.
        :param int time_to_live_in_seconds: The length of time in seconds the JWT will live before it is expired and no
               longer valid. Required when enabled is set to true.
        """
        if access_token_key_id is not None:
            pulumi.set(__self__, "access_token_key_id", access_token_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_to_live_in_seconds is not None:
            pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)

    @property
    @pulumi.getter(name="accessTokenKeyId")
    def access_token_key_id(self) -> Optional[str]:
        """
        The unique ID of the signing key used to sign the access token. Required when
        enabled is set to true.
        """
        return pulumi.get(self, "access_token_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates if this application is using the JWT configuration defined here or the global JWT
        configuration defined by the Tenant. If this is false the signing algorithm configured in the Tenant will be used.
        If true the signing algorithm defined in this application will be used.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> Optional[int]:
        """
        The length of time in seconds the JWT will live before it is expired and no
        longer valid. Required when enabled is set to true.
        """
        return pulumi.get(self, "time_to_live_in_seconds")


@pulumi.output_type
class FusionAuthFormFieldValidator(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 expression: Optional[str] = None):
        """
        :param bool enabled: Determines if user input should be validated.
        :param str expression: A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if user input should be validated.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class FusionAuthFormStep(dict):
    def __init__(__self__, *,
                 fields: Sequence[str]):
        """
        :param Sequence[str] fields: An ordered list of Form Field Ids assigned to this step.
        """
        pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Sequence[str]:
        """
        An ordered list of Form Field Ids assigned to this step.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class FusionAuthIdpAppleApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "createRegistration":
            suggest = "create_registration"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "servicesId":
            suggest = "services_id"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpAppleApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpAppleApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpAppleApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 key_id: Optional[str] = None,
                 scope: Optional[str] = None,
                 services_id: Optional[str] = None,
                 team_id: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str key_id: The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        :param str scope: The top-level space separated scope that you are requesting from Apple.
        :param str services_id: The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        :param str team_id: The Apple App ID Prefix, or Team ID found in your Apple Developer Account which has been configured for Sign in with Apple.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if services_id is not None:
            pulumi.set(__self__, "services_id", services_id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level space separated scope that you are requesting from Apple.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="servicesId")
    def services_id(self) -> Optional[str]:
        """
        The unique Id of the private key downloaded from Apple and imported into Key Master that will be used to sign the client secret.
        """
        return pulumi.get(self, "services_id")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        The Apple App ID Prefix, or Team ID found in your Apple Developer Account which has been configured for Sign in with Apple.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class FusionAuthIdpAppleTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpAppleTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpAppleTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpAppleTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpExternalJwtApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpExternalJwtApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpExternalJwtApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpExternalJwtApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthIdpExternalJwtTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpExternalJwtTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpExternalJwtTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpExternalJwtTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpFacebookApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpFacebookApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpFacebookApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpFacebookApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 fields: Optional[str] = None,
                 permissions: Optional[str] = None):
        """
        :param str app_id: The top-level Facebook `appId` for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        :param str application_id: ID of the FusionAuth Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_secret: The top-level client secret, also known as 'App Secret', to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        :param bool create_registration: Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str fields: The top-level fields that you are requesting from Facebook.
               Field values are documented at [Facebook Graph API](https://developers.facebook.com/docs/graph-api/using-graph-api/)
        :param str permissions: The top-level permissions that your application is asking of the user’s Facebook account.
               Permission values are documented at [Facebook Login API](https://developers.facebook.com/docs/permissions/reference)
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The top-level Facebook `appId` for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the FusionAuth Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret, also known as 'App Secret', to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def fields(self) -> Optional[str]:
        """
        The top-level fields that you are requesting from Facebook.
        Field values are documented at [Facebook Graph API](https://developers.facebook.com/docs/graph-api/using-graph-api/)
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[str]:
        """
        The top-level permissions that your application is asking of the user’s Facebook account.
        Permission values are documented at [Facebook Login API](https://developers.facebook.com/docs/permissions/reference)
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class FusionAuthIdpFacebookTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpFacebookTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpFacebookTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpFacebookTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpGoogleApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpGoogleApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpGoogleApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpGoogleApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account.
        :param str client_secret: The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from Google.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from Google.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class FusionAuthIdpGoogleTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpGoogleTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpGoogleTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpGoogleTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpLinkedInApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpLinkedInApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpLinkedInApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpLinkedInApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str application_id: ID of the FusionAuth Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: The top-level LinkedIn client id for your Application. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        :param str client_secret: The top-level client secret to use with the LinkedIn Identity Provider when retrieving the long-lived token. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        :param bool create_registration: Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from LinkedIn.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the FusionAuth Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The top-level LinkedIn client id for your Application. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the LinkedIn Identity Provider when retrieving the long-lived token. This value is retrieved from the LinkedIn developer website when you set up your LinkedIn app.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a `UserRegistration` is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from LinkedIn.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class FusionAuthIdpLinkedInTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpLinkedInTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpLinkedInTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpLinkedInTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpOpenIdConnectApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonImageUrl":
            suggest = "button_image_url"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "createRegistration":
            suggest = "create_registration"
        elif key == "oauth2ClientId":
            suggest = "oauth2_client_id"
        elif key == "oauth2ClientSecret":
            suggest = "oauth2_client_secret"
        elif key == "oauth2Scope":
            suggest = "oauth2_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpOpenIdConnectApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpOpenIdConnectApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpOpenIdConnectApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_image_url: Optional[str] = None,
                 button_text: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 oauth2_client_id: Optional[str] = None,
                 oauth2_client_secret: Optional[str] = None,
                 oauth2_scope: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_image_url: The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str oauth2_client_id: The top-level client id for your Application.
        :param str oauth2_client_secret: The top-level client secret to use with the OpenID Connect identity provider.
        :param str oauth2_scope: The top-level scope that you are requesting from the OpenID Connect identity provider.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_image_url is not None:
            pulumi.set(__self__, "button_image_url", button_image_url)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if oauth2_client_id is not None:
            pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        if oauth2_client_secret is not None:
            pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        if oauth2_scope is not None:
            pulumi.set(__self__, "oauth2_scope", oauth2_scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonImageUrl")
    def button_image_url(self) -> Optional[str]:
        """
        The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_image_url")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> Optional[str]:
        """
        The top-level client id for your Application.
        """
        return pulumi.get(self, "oauth2_client_id")

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the OpenID Connect identity provider.
        """
        return pulumi.get(self, "oauth2_client_secret")

    @property
    @pulumi.getter(name="oauth2Scope")
    def oauth2_scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from the OpenID Connect identity provider.
        """
        return pulumi.get(self, "oauth2_scope")


@pulumi.output_type
class FusionAuthIdpOpenIdConnectTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpOpenIdConnectTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpOpenIdConnectTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpOpenIdConnectTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpPsnApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpPsnApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpPsnApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpPsnApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: The top-level Sony PlayStation Network client id for your Application. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        :param str client_secret: The top-level client secret to use with the Sony PlayStation Network Identity Provider when retrieving the long-lived token. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from Sony PlayStation Network.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The top-level Sony PlayStation Network client id for your Application. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the Sony PlayStation Network Identity Provider when retrieving the long-lived token. This value is retrieved from the Sony PlayStation Network developer website when you setup your Sony PlayStation Network developer account.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from Sony PlayStation Network.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class FusionAuthIdpPsnTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpPsnTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpPsnTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpPsnTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSamlV2IdpInitiatedApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSamlV2IdpInitiatedTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpSamlv2ApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonImageUrl":
            suggest = "button_image_url"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSamlv2ApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSamlv2ApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSamlv2ApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_image_url: Optional[str] = None,
                 button_text: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_image_url: The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_image_url is not None:
            pulumi.set(__self__, "button_image_url", button_image_url)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonImageUrl")
    def button_image_url(self) -> Optional[str]:
        """
        The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_image_url")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthIdpSamlv2TenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSamlv2TenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSamlv2TenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSamlv2TenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpSteamApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "createRegistration":
            suggest = "create_registration"
        elif key == "webApiKey":
            suggest = "web_api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSteamApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSteamApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSteamApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None,
                 web_api_key: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: The top-level Steam client id for your Application. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from Steam.
        :param str web_api_key: The top-level web API key to use with the Steam Identity Provider when retrieving the player summary info. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if web_api_key is not None:
            pulumi.set(__self__, "web_api_key", web_api_key)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The top-level Steam client id for your Application. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from Steam.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="webApiKey")
    def web_api_key(self) -> Optional[str]:
        """
        The top-level web API key to use with the Steam Identity Provider when retrieving the player summary info. This value is retrieved from the Steam developer website when you setup your Steam developer account.
        """
        return pulumi.get(self, "web_api_key")


@pulumi.output_type
class FusionAuthIdpSteamTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpSteamTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpSteamTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpSteamTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpTwitchApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpTwitchApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpTwitchApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpTwitchApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param str client_secret: The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from Xbox.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from Xbox.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class FusionAuthIdpTwitchTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpTwitchTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpTwitchTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpTwitchTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthIdpXBoxApplicationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "createRegistration":
            suggest = "create_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpXBoxApplicationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpXBoxApplicationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpXBoxApplicationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 button_text: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 create_registration: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str application_id: ID of the Application to apply this configuration to.
        :param str button_text: The top-level button text to use on the FusionAuth login page for this Identity Provider.
        :param str client_id: TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param str client_secret: The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        :param bool create_registration: Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        :param bool enabled: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str scope: The top-level scope that you are requesting from Xbox.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if create_registration is not None:
            pulumi.set(__self__, "create_registration", create_registration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        ID of the Application to apply this configuration to.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[str]:
        """
        The top-level button text to use on the FusionAuth login page for this Identity Provider.
        """
        return pulumi.get(self, "button_text")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        TThe top-level Xbox client id for your Application. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The top-level client secret to use with the Xbox Identity Provider when retrieving the long-lived token. This value is retrieved from the Xbox developer website when you setup your Xbox developer account.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="createRegistration")
    def create_registration(self) -> Optional[bool]:
        """
        Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into.
        """
        return pulumi.get(self, "create_registration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The top-level scope that you are requesting from Xbox.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class FusionAuthIdpXBoxTenantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitUserLinkCountEnabled":
            suggest = "limit_user_link_count_enabled"
        elif key == "limitUserLinkCountMaximumLinks":
            suggest = "limit_user_link_count_maximum_links"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthIdpXBoxTenantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthIdpXBoxTenantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthIdpXBoxTenantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_user_link_count_enabled: Optional[bool] = None,
                 limit_user_link_count_maximum_links: Optional[int] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool limit_user_link_count_enabled: When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        :param int limit_user_link_count_maximum_links: Determines if this provider is enabled. If it is false then it will be disabled globally.
        :param str tenant_id: The unique Id of the tenant that this configuration applies to.
        """
        if limit_user_link_count_enabled is not None:
            pulumi.set(__self__, "limit_user_link_count_enabled", limit_user_link_count_enabled)
        if limit_user_link_count_maximum_links is not None:
            pulumi.set(__self__, "limit_user_link_count_maximum_links", limit_user_link_count_maximum_links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="limitUserLinkCountEnabled")
    def limit_user_link_count_enabled(self) -> Optional[bool]:
        """
        When enabled, the number of identity provider links a user may create is enforced by maximumLinks.
        """
        return pulumi.get(self, "limit_user_link_count_enabled")

    @property
    @pulumi.getter(name="limitUserLinkCountMaximumLinks")
    def limit_user_link_count_maximum_links(self) -> Optional[int]:
        """
        Determines if this provider is enabled. If it is false then it will be disabled globally.
        """
        return pulumi.get(self, "limit_user_link_count_maximum_links")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique Id of the tenant that this configuration applies to.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FusionAuthSystemConfigurationAuditLogConfiguration(dict):
    def __init__(__self__, *,
                 delete: Optional['outputs.FusionAuthSystemConfigurationAuditLogConfigurationDelete'] = None):
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.FusionAuthSystemConfigurationAuditLogConfigurationDelete']:
        return pulumi.get(self, "delete")


@pulumi.output_type
class FusionAuthSystemConfigurationAuditLogConfigurationDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfDaysToRetain":
            suggest = "number_of_days_to_retain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthSystemConfigurationAuditLogConfigurationDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthSystemConfigurationAuditLogConfigurationDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthSystemConfigurationAuditLogConfigurationDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 number_of_days_to_retain: Optional[int] = None):
        """
        :param bool enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param int number_of_days_to_retain: The number of days to retain login records.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_days_to_retain is not None:
            pulumi.set(__self__, "number_of_days_to_retain", number_of_days_to_retain)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="numberOfDaysToRetain")
    def number_of_days_to_retain(self) -> Optional[int]:
        """
        The number of days to retain login records.
        """
        return pulumi.get(self, "number_of_days_to_retain")


@pulumi.output_type
class FusionAuthSystemConfigurationCorsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "exposedHeaders":
            suggest = "exposed_headers"
        elif key == "preflightMaxAgeInSeconds":
            suggest = "preflight_max_age_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthSystemConfigurationCorsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthSystemConfigurationCorsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthSystemConfigurationCorsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allowed_headers: Optional[Sequence[str]] = None,
                 allowed_methods: Optional[Sequence[str]] = None,
                 allowed_origins: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 exposed_headers: Optional[Sequence[str]] = None,
                 preflight_max_age_in_seconds: Optional[int] = None):
        """
        :param bool allow_credentials: The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials.
        :param Sequence[str] allowed_headers: The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers.
        :param Sequence[str] allowed_methods: The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods.
        :param Sequence[str] allowed_origins: The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified.
        :param bool enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param Sequence[str] exposed_headers: The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers.
        :param int preflight_max_age_in_seconds: The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if preflight_max_age_in_seconds is not None:
            pulumi.set(__self__, "preflight_max_age_in_seconds", preflight_max_age_in_seconds)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[Sequence[str]]:
        """
        The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers.
        """
        return pulumi.get(self, "exposed_headers")

    @property
    @pulumi.getter(name="preflightMaxAgeInSeconds")
    def preflight_max_age_in_seconds(self) -> Optional[int]:
        """
        The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age.
        """
        return pulumi.get(self, "preflight_max_age_in_seconds")


@pulumi.output_type
class FusionAuthSystemConfigurationEventLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberToRetain":
            suggest = "number_to_retain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthSystemConfigurationEventLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthSystemConfigurationEventLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthSystemConfigurationEventLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_to_retain: Optional[int] = None):
        """
        :param int number_to_retain: The number of events to retain. Once the the number of event logs exceeds this configured value they will be deleted starting with the oldest event logs.
        """
        if number_to_retain is not None:
            pulumi.set(__self__, "number_to_retain", number_to_retain)

    @property
    @pulumi.getter(name="numberToRetain")
    def number_to_retain(self) -> Optional[int]:
        """
        The number of events to retain. Once the the number of event logs exceeds this configured value they will be deleted starting with the oldest event logs.
        """
        return pulumi.get(self, "number_to_retain")


@pulumi.output_type
class FusionAuthSystemConfigurationLoginRecordConfiguration(dict):
    def __init__(__self__, *,
                 delete: Optional['outputs.FusionAuthSystemConfigurationLoginRecordConfigurationDelete'] = None):
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.FusionAuthSystemConfigurationLoginRecordConfigurationDelete']:
        return pulumi.get(self, "delete")


@pulumi.output_type
class FusionAuthSystemConfigurationLoginRecordConfigurationDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfDaysToRetain":
            suggest = "number_of_days_to_retain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthSystemConfigurationLoginRecordConfigurationDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthSystemConfigurationLoginRecordConfigurationDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthSystemConfigurationLoginRecordConfigurationDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 number_of_days_to_retain: Optional[int] = None):
        """
        :param bool enabled: Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        :param int number_of_days_to_retain: The number of days to retain login records.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_days_to_retain is not None:
            pulumi.set(__self__, "number_of_days_to_retain", number_of_days_to_retain)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not FusionAuth should delete the login records based upon this configuration. When true the loginRecordConfiguration.delete.numberOfDaysToRetain will be used to identify login records that are eligible for deletion. When this value is set to false login records will be preserved forever.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="numberOfDaysToRetain")
    def number_of_days_to_retain(self) -> Optional[int]:
        """
        The number of days to retain login records.
        """
        return pulumi.get(self, "number_of_days_to_retain")


@pulumi.output_type
class FusionAuthSystemConfigurationUiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerColor":
            suggest = "header_color"
        elif key == "logoUrl":
            suggest = "logo_url"
        elif key == "menuFontColor":
            suggest = "menu_font_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthSystemConfigurationUiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthSystemConfigurationUiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthSystemConfigurationUiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_color: Optional[str] = None,
                 logo_url: Optional[str] = None,
                 menu_font_color: Optional[str] = None):
        """
        :param str header_color: A hexadecimal color to override the default menu color in the user interface.
        :param str logo_url: A URL of a logo to override the default FusionAuth logo in the user interface.
        :param str menu_font_color: A hexadecimal color to override the default menu font color in the user interface.
        """
        if header_color is not None:
            pulumi.set(__self__, "header_color", header_color)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)
        if menu_font_color is not None:
            pulumi.set(__self__, "menu_font_color", menu_font_color)

    @property
    @pulumi.getter(name="headerColor")
    def header_color(self) -> Optional[str]:
        """
        A hexadecimal color to override the default menu color in the user interface.
        """
        return pulumi.get(self, "header_color")

    @property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[str]:
        """
        A URL of a logo to override the default FusionAuth logo in the user interface.
        """
        return pulumi.get(self, "logo_url")

    @property
    @pulumi.getter(name="menuFontColor")
    def menu_font_color(self) -> Optional[str]:
        """
        A hexadecimal color to override the default menu font color in the user interface.
        """
        return pulumi.get(self, "menu_font_color")


@pulumi.output_type
class FusionAuthTenantAccessControlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uiIpAccessControlListId":
            suggest = "ui_ip_access_control_list_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantAccessControlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantAccessControlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantAccessControlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ui_ip_access_control_list_id: Optional[str] = None):
        """
        :param str ui_ip_access_control_list_id: The Id of the IP Access Control List limiting access to all applications in this tenant.
        """
        if ui_ip_access_control_list_id is not None:
            pulumi.set(__self__, "ui_ip_access_control_list_id", ui_ip_access_control_list_id)

    @property
    @pulumi.getter(name="uiIpAccessControlListId")
    def ui_ip_access_control_list_id(self) -> Optional[str]:
        """
        The Id of the IP Access Control List limiting access to all applications in this tenant.
        """
        return pulumi.get(self, "ui_ip_access_control_list_id")


@pulumi.output_type
class FusionAuthTenantCaptchaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captchaMethod":
            suggest = "captcha_method"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "siteKey":
            suggest = "site_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantCaptchaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantCaptchaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantCaptchaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 captcha_method: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 secret_key: Optional[str] = None,
                 site_key: Optional[str] = None,
                 threshold: Optional[float] = None):
        """
        :param str captcha_method: The type of captcha method to use. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str secret_key: The secret key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param str site_key: The site key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        :param float threshold: The numeric threshold which separates a passing score from a failing one. This value only applies if using either the Google v3 or HCaptcha Enterprise method, otherwise this value is ignored.
        """
        if captcha_method is not None:
            pulumi.set(__self__, "captcha_method", captcha_method)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if site_key is not None:
            pulumi.set(__self__, "site_key", site_key)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="captchaMethod")
    def captcha_method(self) -> Optional[str]:
        """
        The type of captcha method to use. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "captcha_method")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        The secret key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> Optional[str]:
        """
        The site key for this captcha method. This field is required when tenant.captchaConfiguration.enabled is set to true.
        """
        return pulumi.get(self, "site_key")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        The numeric threshold which separates a passing score from a failing one. This value only applies if using either the Google v3 or HCaptcha Enterprise method, otherwise this value is ignored.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class FusionAuthTenantConnectorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorId":
            suggest = "connector_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantConnectorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantConnectorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantConnectorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_id: Optional[str] = None,
                 domains: Optional[Sequence[str]] = None,
                 migrate: Optional[bool] = None):
        """
        :param str connector_id: The identifier of the Connector to which this policy refers.
        :param Sequence[str] domains: A list of email domains to which this connector should apply. A value of ["*"] indicates this connector applies to all users.
        :param bool migrate: If true, the user’s data will be migrated to FusionAuth at first successful authentication; subsequent authentications will occur against the FusionAuth datastore. If false, the Connector’s source will be treated as authoritative.
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[str]:
        """
        The identifier of the Connector to which this policy refers.
        """
        return pulumi.get(self, "connector_id")

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        A list of email domains to which this connector should apply. A value of ["*"] indicates this connector applies to all users.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def migrate(self) -> Optional[bool]:
        """
        If true, the user’s data will be migrated to FusionAuth at first successful authentication; subsequent authentications will occur against the FusionAuth datastore. If false, the Connector’s source will be treated as authoritative.
        """
        return pulumi.get(self, "migrate")


@pulumi.output_type
class FusionAuthTenantEmailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalHeaders":
            suggest = "additional_headers"
        elif key == "defaultFromEmail":
            suggest = "default_from_email"
        elif key == "defaultFromName":
            suggest = "default_from_name"
        elif key == "emailUpdateEmailTemplateId":
            suggest = "email_update_email_template_id"
        elif key == "emailVerifiedEmailTemplateId":
            suggest = "email_verified_email_template_id"
        elif key == "forgotPasswordEmailTemplateId":
            suggest = "forgot_password_email_template_id"
        elif key == "implicitEmailVerificationAllowed":
            suggest = "implicit_email_verification_allowed"
        elif key == "loginIdInUseOnCreateEmailTemplateId":
            suggest = "login_id_in_use_on_create_email_template_id"
        elif key == "loginIdInUseOnUpdateEmailTemplateId":
            suggest = "login_id_in_use_on_update_email_template_id"
        elif key == "loginNewDeviceEmailTemplateId":
            suggest = "login_new_device_email_template_id"
        elif key == "loginSuspiciousEmailTemplateId":
            suggest = "login_suspicious_email_template_id"
        elif key == "passwordResetSuccessEmailTemplateId":
            suggest = "password_reset_success_email_template_id"
        elif key == "passwordUpdateEmailTemplateId":
            suggest = "password_update_email_template_id"
        elif key == "passwordlessEmailTemplateId":
            suggest = "passwordless_email_template_id"
        elif key == "setPasswordEmailTemplateId":
            suggest = "set_password_email_template_id"
        elif key == "twoFactorMethodAddEmailTemplateId":
            suggest = "two_factor_method_add_email_template_id"
        elif key == "twoFactorMethodRemoveEmailTemplateId":
            suggest = "two_factor_method_remove_email_template_id"
        elif key == "verificationEmailTemplateId":
            suggest = "verification_email_template_id"
        elif key == "verificationStrategy":
            suggest = "verification_strategy"
        elif key == "verifyEmail":
            suggest = "verify_email"
        elif key == "verifyEmailWhenChanged":
            suggest = "verify_email_when_changed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantEmailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantEmailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantEmailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 port: int,
                 additional_headers: Optional[Mapping[str, Any]] = None,
                 default_from_email: Optional[str] = None,
                 default_from_name: Optional[str] = None,
                 email_update_email_template_id: Optional[str] = None,
                 email_verified_email_template_id: Optional[str] = None,
                 forgot_password_email_template_id: Optional[str] = None,
                 implicit_email_verification_allowed: Optional[bool] = None,
                 login_id_in_use_on_create_email_template_id: Optional[str] = None,
                 login_id_in_use_on_update_email_template_id: Optional[str] = None,
                 login_new_device_email_template_id: Optional[str] = None,
                 login_suspicious_email_template_id: Optional[str] = None,
                 password: Optional[str] = None,
                 password_reset_success_email_template_id: Optional[str] = None,
                 password_update_email_template_id: Optional[str] = None,
                 passwordless_email_template_id: Optional[str] = None,
                 properties: Optional[str] = None,
                 security: Optional[str] = None,
                 set_password_email_template_id: Optional[str] = None,
                 two_factor_method_add_email_template_id: Optional[str] = None,
                 two_factor_method_remove_email_template_id: Optional[str] = None,
                 unverified: Optional['outputs.FusionAuthTenantEmailConfigurationUnverified'] = None,
                 username: Optional[str] = None,
                 verification_email_template_id: Optional[str] = None,
                 verification_strategy: Optional[str] = None,
                 verify_email: Optional[bool] = None,
                 verify_email_when_changed: Optional[bool] = None):
        """
        :param str host: The host name of the SMTP server that FusionAuth will use.
        :param int port: The port of the SMTP server that FusionAuth will use.
        :param Mapping[str, Any] additional_headers: The additional SMTP headers to be added to each outgoing email. Each SMTP header consists of a name and a value.
        :param str default_from_email: The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>).
        :param str default_from_name: The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>).
        :param str email_update_email_template_id: The Id of the Email Template that is used when a user is sent a forgot password email.
        :param str email_verified_email_template_id: The Id of the Email Template used to verify user emails.
        :param str forgot_password_email_template_id: The Id of the Email Template that is used when a user is sent a forgot password email.
        :param bool implicit_email_verification_allowed: When set to true, this allows email to be verified as a result of completing a similar email based workflow such as change password. When seto false, the user must explicitly complete the email verification workflow even if the user has already completed a similar email workflow such as change password.
        :param str login_id_in_use_on_create_email_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        :param str login_id_in_use_on_update_email_template_id: The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        :param str login_new_device_email_template_id: The Id of the Email Template used to send emails to users when they log in on a new device.
        :param str login_suspicious_email_template_id: The Id of the Email Template used to send emails to users when a suspicious login occurs.
        :param str password: An optional password FusionAuth will use to authenticate with the SMTP server.
        :param str password_reset_success_email_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password habeen reset.
        :param str password_update_email_template_id: The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been rese
        :param str passwordless_email_template_id: The Id of the Passwordless Email Template.
        :param str properties: Additional Email Configuration in a properties file formatted String.
        :param str security: The type of security protocol FusionAuth will use when connecting to the SMTP server.
        :param str set_password_email_template_id: The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password.
        :param str two_factor_method_add_email_template_id: The Id of the Email Template used to send emails to users when a MFA method has been added to their account.
        :param str two_factor_method_remove_email_template_id: The Id of the Email Template used to send emails to users when a MFA method has been removed from their account.
        :param str username: An optional username FusionAuth will to authenticate with the SMTP server.
        :param str verification_email_template_id: The Id of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address ivalid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required.
        :param str verification_strategy: The process by which the user will verify their email address. Possible values are `ClickableLink` or `FormField`.
        :param bool verify_email: Whether the user’s email addresses are verified when the registers with your application.
        :param bool verify_email_when_changed: Whether the user’s email addresses are verified when the user changes them.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if default_from_email is not None:
            pulumi.set(__self__, "default_from_email", default_from_email)
        if default_from_name is not None:
            pulumi.set(__self__, "default_from_name", default_from_name)
        if email_update_email_template_id is not None:
            pulumi.set(__self__, "email_update_email_template_id", email_update_email_template_id)
        if email_verified_email_template_id is not None:
            pulumi.set(__self__, "email_verified_email_template_id", email_verified_email_template_id)
        if forgot_password_email_template_id is not None:
            pulumi.set(__self__, "forgot_password_email_template_id", forgot_password_email_template_id)
        if implicit_email_verification_allowed is not None:
            pulumi.set(__self__, "implicit_email_verification_allowed", implicit_email_verification_allowed)
        if login_id_in_use_on_create_email_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_create_email_template_id", login_id_in_use_on_create_email_template_id)
        if login_id_in_use_on_update_email_template_id is not None:
            pulumi.set(__self__, "login_id_in_use_on_update_email_template_id", login_id_in_use_on_update_email_template_id)
        if login_new_device_email_template_id is not None:
            pulumi.set(__self__, "login_new_device_email_template_id", login_new_device_email_template_id)
        if login_suspicious_email_template_id is not None:
            pulumi.set(__self__, "login_suspicious_email_template_id", login_suspicious_email_template_id)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if password_reset_success_email_template_id is not None:
            pulumi.set(__self__, "password_reset_success_email_template_id", password_reset_success_email_template_id)
        if password_update_email_template_id is not None:
            pulumi.set(__self__, "password_update_email_template_id", password_update_email_template_id)
        if passwordless_email_template_id is not None:
            pulumi.set(__self__, "passwordless_email_template_id", passwordless_email_template_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if set_password_email_template_id is not None:
            pulumi.set(__self__, "set_password_email_template_id", set_password_email_template_id)
        if two_factor_method_add_email_template_id is not None:
            pulumi.set(__self__, "two_factor_method_add_email_template_id", two_factor_method_add_email_template_id)
        if two_factor_method_remove_email_template_id is not None:
            pulumi.set(__self__, "two_factor_method_remove_email_template_id", two_factor_method_remove_email_template_id)
        if unverified is not None:
            pulumi.set(__self__, "unverified", unverified)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if verification_email_template_id is not None:
            pulumi.set(__self__, "verification_email_template_id", verification_email_template_id)
        if verification_strategy is not None:
            pulumi.set(__self__, "verification_strategy", verification_strategy)
        if verify_email is not None:
            pulumi.set(__self__, "verify_email", verify_email)
        if verify_email_when_changed is not None:
            pulumi.set(__self__, "verify_email_when_changed", verify_email_when_changed)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host name of the SMTP server that FusionAuth will use.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the SMTP server that FusionAuth will use.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Mapping[str, Any]]:
        """
        The additional SMTP headers to be added to each outgoing email. Each SMTP header consists of a name and a value.
        """
        return pulumi.get(self, "additional_headers")

    @property
    @pulumi.getter(name="defaultFromEmail")
    def default_from_email(self) -> Optional[str]:
        """
        The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>).
        """
        return pulumi.get(self, "default_from_email")

    @property
    @pulumi.getter(name="defaultFromName")
    def default_from_name(self) -> Optional[str]:
        """
        The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>).
        """
        return pulumi.get(self, "default_from_name")

    @property
    @pulumi.getter(name="emailUpdateEmailTemplateId")
    def email_update_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email.
        """
        return pulumi.get(self, "email_update_email_template_id")

    @property
    @pulumi.getter(name="emailVerifiedEmailTemplateId")
    def email_verified_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to verify user emails.
        """
        return pulumi.get(self, "email_verified_email_template_id")

    @property
    @pulumi.getter(name="forgotPasswordEmailTemplateId")
    def forgot_password_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used when a user is sent a forgot password email.
        """
        return pulumi.get(self, "forgot_password_email_template_id")

    @property
    @pulumi.getter(name="implicitEmailVerificationAllowed")
    def implicit_email_verification_allowed(self) -> Optional[bool]:
        """
        When set to true, this allows email to be verified as a result of completing a similar email based workflow such as change password. When seto false, the user must explicitly complete the email verification workflow even if the user has already completed a similar email workflow such as change password.
        """
        return pulumi.get(self, "implicit_email_verification_allowed")

    @property
    @pulumi.getter(name="loginIdInUseOnCreateEmailTemplateId")
    def login_id_in_use_on_create_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        """
        return pulumi.get(self, "login_id_in_use_on_create_email_template_id")

    @property
    @pulumi.getter(name="loginIdInUseOnUpdateEmailTemplateId")
    def login_id_in_use_on_update_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when another user attempts to create an account with their login Id.
        """
        return pulumi.get(self, "login_id_in_use_on_update_email_template_id")

    @property
    @pulumi.getter(name="loginNewDeviceEmailTemplateId")
    def login_new_device_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when they log in on a new device.
        """
        return pulumi.get(self, "login_new_device_email_template_id")

    @property
    @pulumi.getter(name="loginSuspiciousEmailTemplateId")
    def login_suspicious_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a suspicious login occurs.
        """
        return pulumi.get(self, "login_suspicious_email_template_id")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        An optional password FusionAuth will use to authenticate with the SMTP server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="passwordResetSuccessEmailTemplateId")
    def password_reset_success_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password habeen reset.
        """
        return pulumi.get(self, "password_reset_success_email_template_id")

    @property
    @pulumi.getter(name="passwordUpdateEmailTemplateId")
    def password_update_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when they have completed a 'forgot password' workflow and their password has been rese
        """
        return pulumi.get(self, "password_update_email_template_id")

    @property
    @pulumi.getter(name="passwordlessEmailTemplateId")
    def passwordless_email_template_id(self) -> Optional[str]:
        """
        The Id of the Passwordless Email Template.
        """
        return pulumi.get(self, "passwordless_email_template_id")

    @property
    @pulumi.getter
    def properties(self) -> Optional[str]:
        """
        Additional Email Configuration in a properties file formatted String.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def security(self) -> Optional[str]:
        """
        The type of security protocol FusionAuth will use when connecting to the SMTP server.
        """
        return pulumi.get(self, "security")

    @property
    @pulumi.getter(name="setPasswordEmailTemplateId")
    def set_password_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password.
        """
        return pulumi.get(self, "set_password_email_template_id")

    @property
    @pulumi.getter(name="twoFactorMethodAddEmailTemplateId")
    def two_factor_method_add_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been added to their account.
        """
        return pulumi.get(self, "two_factor_method_add_email_template_id")

    @property
    @pulumi.getter(name="twoFactorMethodRemoveEmailTemplateId")
    def two_factor_method_remove_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template used to send emails to users when a MFA method has been removed from their account.
        """
        return pulumi.get(self, "two_factor_method_remove_email_template_id")

    @property
    @pulumi.getter
    def unverified(self) -> Optional['outputs.FusionAuthTenantEmailConfigurationUnverified']:
        return pulumi.get(self, "unverified")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        An optional username FusionAuth will to authenticate with the SMTP server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="verificationEmailTemplateId")
    def verification_email_template_id(self) -> Optional[str]:
        """
        The Id of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address ivalid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required.
        """
        return pulumi.get(self, "verification_email_template_id")

    @property
    @pulumi.getter(name="verificationStrategy")
    def verification_strategy(self) -> Optional[str]:
        """
        The process by which the user will verify their email address. Possible values are `ClickableLink` or `FormField`.
        """
        return pulumi.get(self, "verification_strategy")

    @property
    @pulumi.getter(name="verifyEmail")
    def verify_email(self) -> Optional[bool]:
        """
        Whether the user’s email addresses are verified when the registers with your application.
        """
        return pulumi.get(self, "verify_email")

    @property
    @pulumi.getter(name="verifyEmailWhenChanged")
    def verify_email_when_changed(self) -> Optional[bool]:
        """
        Whether the user’s email addresses are verified when the user changes them.
        """
        return pulumi.get(self, "verify_email_when_changed")


@pulumi.output_type
class FusionAuthTenantEmailConfigurationUnverified(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmailChangeWhenGated":
            suggest = "allow_email_change_when_gated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantEmailConfigurationUnverified. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantEmailConfigurationUnverified.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantEmailConfigurationUnverified.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_email_change_when_gated: Optional[bool] = None,
                 behavior: Optional[str] = None):
        """
        :param bool allow_email_change_when_gated: When this value is set to true, the user is allowed to change their email address when they are gated because they haven’t verified their email address.
        :param str behavior: = (Optional) The behavior when detecting breaches at time of user login
        """
        if allow_email_change_when_gated is not None:
            pulumi.set(__self__, "allow_email_change_when_gated", allow_email_change_when_gated)
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @property
    @pulumi.getter(name="allowEmailChangeWhenGated")
    def allow_email_change_when_gated(self) -> Optional[bool]:
        """
        When this value is set to true, the user is allowed to change their email address when they are gated because they haven’t verified their email address.
        """
        return pulumi.get(self, "allow_email_change_when_gated")

    @property
    @pulumi.getter
    def behavior(self) -> Optional[str]:
        """
        = (Optional) The behavior when detecting breaches at time of user login
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class FusionAuthTenantEventConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transactionType":
            suggest = "transaction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantEventConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantEventConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantEventConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 event: Optional[str] = None,
                 transaction_type: Optional[str] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str event: The event type
        :param str transaction_type: The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if transaction_type is not None:
            pulumi.set(__self__, "transaction_type", transaction_type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The event type
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="transactionType")
    def transaction_type(self) -> Optional[str]:
        """
        The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks.
        """
        return pulumi.get(self, "transaction_type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationGrantIdTimeToLiveInSeconds":
            suggest = "authorization_grant_id_time_to_live_in_seconds"
        elif key == "changePasswordIdGenerator":
            suggest = "change_password_id_generator"
        elif key == "changePasswordIdTimeToLiveInSeconds":
            suggest = "change_password_id_time_to_live_in_seconds"
        elif key == "deviceCodeTimeToLiveInSeconds":
            suggest = "device_code_time_to_live_in_seconds"
        elif key == "deviceUserCodeIdGenerator":
            suggest = "device_user_code_id_generator"
        elif key == "emailVerificationIdGenerator":
            suggest = "email_verification_id_generator"
        elif key == "emailVerificationIdTimeToLiveInSeconds":
            suggest = "email_verification_id_time_to_live_in_seconds"
        elif key == "emailVerificationOneTimeCodeGenerator":
            suggest = "email_verification_one_time_code_generator"
        elif key == "externalAuthenticationIdTimeToLiveInSeconds":
            suggest = "external_authentication_id_time_to_live_in_seconds"
        elif key == "oneTimePasswordTimeToLiveInSeconds":
            suggest = "one_time_password_time_to_live_in_seconds"
        elif key == "passwordlessLoginGenerator":
            suggest = "passwordless_login_generator"
        elif key == "passwordlessLoginTimeToLiveInSeconds":
            suggest = "passwordless_login_time_to_live_in_seconds"
        elif key == "registrationVerificationIdGenerator":
            suggest = "registration_verification_id_generator"
        elif key == "registrationVerificationIdTimeToLiveInSeconds":
            suggest = "registration_verification_id_time_to_live_in_seconds"
        elif key == "registrationVerificationOneTimeCodeGenerator":
            suggest = "registration_verification_one_time_code_generator"
        elif key == "setupPasswordIdGenerator":
            suggest = "setup_password_id_generator"
        elif key == "setupPasswordIdTimeToLiveInSeconds":
            suggest = "setup_password_id_time_to_live_in_seconds"
        elif key == "twoFactorIdTimeToLiveInSeconds":
            suggest = "two_factor_id_time_to_live_in_seconds"
        elif key == "twoFactorOneTimeCodeIdGenerator":
            suggest = "two_factor_one_time_code_id_generator"
        elif key == "twoFactorTrustIdTimeToLiveInSeconds":
            suggest = "two_factor_trust_id_time_to_live_in_seconds"
        elif key == "pendingAccountLinkTimeToLiveInSeconds":
            suggest = "pending_account_link_time_to_live_in_seconds"
        elif key == "samlV2AuthnRequestIdTtlSeconds":
            suggest = "saml_v2_authn_request_id_ttl_seconds"
        elif key == "trustTokenTimeToLiveInSeconds":
            suggest = "trust_token_time_to_live_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantExternalIdentifierConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantExternalIdentifierConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantExternalIdentifierConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_grant_id_time_to_live_in_seconds: int,
                 change_password_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator',
                 change_password_id_time_to_live_in_seconds: int,
                 device_code_time_to_live_in_seconds: int,
                 device_user_code_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator',
                 email_verification_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator',
                 email_verification_id_time_to_live_in_seconds: int,
                 email_verification_one_time_code_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator',
                 external_authentication_id_time_to_live_in_seconds: int,
                 one_time_password_time_to_live_in_seconds: int,
                 passwordless_login_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator',
                 passwordless_login_time_to_live_in_seconds: int,
                 registration_verification_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator',
                 registration_verification_id_time_to_live_in_seconds: int,
                 registration_verification_one_time_code_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator',
                 setup_password_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator',
                 setup_password_id_time_to_live_in_seconds: int,
                 two_factor_id_time_to_live_in_seconds: int,
                 two_factor_one_time_code_id_generator: 'outputs.FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator',
                 two_factor_trust_id_time_to_live_in_seconds: int,
                 pending_account_link_time_to_live_in_seconds: Optional[int] = None,
                 saml_v2_authn_request_id_ttl_seconds: Optional[int] = None,
                 trust_token_time_to_live_in_seconds: Optional[int] = None):
        """
        :param int authorization_grant_id_time_to_live_in_seconds: The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.
        :param int change_password_id_time_to_live_in_seconds: The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        :param int device_code_time_to_live_in_seconds: The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        :param int email_verification_id_time_to_live_in_seconds: The time in seconds until a email verification Id is no longer valid and cannot be used by the Verify Email API. Value must be greater than 0.
        :param int external_authentication_id_time_to_live_in_seconds: The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        :param int one_time_password_time_to_live_in_seconds: The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0.
        :param int passwordless_login_time_to_live_in_seconds: The time in seconds until a passwordless code is no longer valid and cannot be used by the Passwordless API. Value must be greater than 0.
        :param int registration_verification_id_time_to_live_in_seconds: The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0.
        :param int setup_password_id_time_to_live_in_seconds: The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        :param int two_factor_id_time_to_live_in_seconds: The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0.
        :param int two_factor_trust_id_time_to_live_in_seconds: The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0.
        :param int pending_account_link_time_to_live_in_seconds: The number of seconds before the pending account link identifier is no longer valid to complete an account link request. Value must be greater than 0.
        :param int saml_v2_authn_request_id_ttl_seconds: The time in seconds that a SAML AuthN request will be eligible for use to authenticate with FusionAuth.
        :param int trust_token_time_to_live_in_seconds: The number of seconds before the Trust Token is no longer valid to complete a request that requires trust. Value must be greater than 0.
        """
        pulumi.set(__self__, "authorization_grant_id_time_to_live_in_seconds", authorization_grant_id_time_to_live_in_seconds)
        pulumi.set(__self__, "change_password_id_generator", change_password_id_generator)
        pulumi.set(__self__, "change_password_id_time_to_live_in_seconds", change_password_id_time_to_live_in_seconds)
        pulumi.set(__self__, "device_code_time_to_live_in_seconds", device_code_time_to_live_in_seconds)
        pulumi.set(__self__, "device_user_code_id_generator", device_user_code_id_generator)
        pulumi.set(__self__, "email_verification_id_generator", email_verification_id_generator)
        pulumi.set(__self__, "email_verification_id_time_to_live_in_seconds", email_verification_id_time_to_live_in_seconds)
        pulumi.set(__self__, "email_verification_one_time_code_generator", email_verification_one_time_code_generator)
        pulumi.set(__self__, "external_authentication_id_time_to_live_in_seconds", external_authentication_id_time_to_live_in_seconds)
        pulumi.set(__self__, "one_time_password_time_to_live_in_seconds", one_time_password_time_to_live_in_seconds)
        pulumi.set(__self__, "passwordless_login_generator", passwordless_login_generator)
        pulumi.set(__self__, "passwordless_login_time_to_live_in_seconds", passwordless_login_time_to_live_in_seconds)
        pulumi.set(__self__, "registration_verification_id_generator", registration_verification_id_generator)
        pulumi.set(__self__, "registration_verification_id_time_to_live_in_seconds", registration_verification_id_time_to_live_in_seconds)
        pulumi.set(__self__, "registration_verification_one_time_code_generator", registration_verification_one_time_code_generator)
        pulumi.set(__self__, "setup_password_id_generator", setup_password_id_generator)
        pulumi.set(__self__, "setup_password_id_time_to_live_in_seconds", setup_password_id_time_to_live_in_seconds)
        pulumi.set(__self__, "two_factor_id_time_to_live_in_seconds", two_factor_id_time_to_live_in_seconds)
        pulumi.set(__self__, "two_factor_one_time_code_id_generator", two_factor_one_time_code_id_generator)
        pulumi.set(__self__, "two_factor_trust_id_time_to_live_in_seconds", two_factor_trust_id_time_to_live_in_seconds)
        if pending_account_link_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "pending_account_link_time_to_live_in_seconds", pending_account_link_time_to_live_in_seconds)
        if saml_v2_authn_request_id_ttl_seconds is not None:
            pulumi.set(__self__, "saml_v2_authn_request_id_ttl_seconds", saml_v2_authn_request_id_ttl_seconds)
        if trust_token_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "trust_token_time_to_live_in_seconds", trust_token_time_to_live_in_seconds)

    @property
    @pulumi.getter(name="authorizationGrantIdTimeToLiveInSeconds")
    def authorization_grant_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.
        """
        return pulumi.get(self, "authorization_grant_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="changePasswordIdGenerator")
    def change_password_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator':
        return pulumi.get(self, "change_password_id_generator")

    @property
    @pulumi.getter(name="changePasswordIdTimeToLiveInSeconds")
    def change_password_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        """
        return pulumi.get(self, "change_password_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="deviceCodeTimeToLiveInSeconds")
    def device_code_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        """
        return pulumi.get(self, "device_code_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="deviceUserCodeIdGenerator")
    def device_user_code_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator':
        return pulumi.get(self, "device_user_code_id_generator")

    @property
    @pulumi.getter(name="emailVerificationIdGenerator")
    def email_verification_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator':
        return pulumi.get(self, "email_verification_id_generator")

    @property
    @pulumi.getter(name="emailVerificationIdTimeToLiveInSeconds")
    def email_verification_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a email verification Id is no longer valid and cannot be used by the Verify Email API. Value must be greater than 0.
        """
        return pulumi.get(self, "email_verification_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="emailVerificationOneTimeCodeGenerator")
    def email_verification_one_time_code_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator':
        return pulumi.get(self, "email_verification_one_time_code_generator")

    @property
    @pulumi.getter(name="externalAuthenticationIdTimeToLiveInSeconds")
    def external_authentication_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0.
        """
        return pulumi.get(self, "external_authentication_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="oneTimePasswordTimeToLiveInSeconds")
    def one_time_password_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0.
        """
        return pulumi.get(self, "one_time_password_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="passwordlessLoginGenerator")
    def passwordless_login_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator':
        return pulumi.get(self, "passwordless_login_generator")

    @property
    @pulumi.getter(name="passwordlessLoginTimeToLiveInSeconds")
    def passwordless_login_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a passwordless code is no longer valid and cannot be used by the Passwordless API. Value must be greater than 0.
        """
        return pulumi.get(self, "passwordless_login_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="registrationVerificationIdGenerator")
    def registration_verification_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator':
        return pulumi.get(self, "registration_verification_id_generator")

    @property
    @pulumi.getter(name="registrationVerificationIdTimeToLiveInSeconds")
    def registration_verification_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0.
        """
        return pulumi.get(self, "registration_verification_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="registrationVerificationOneTimeCodeGenerator")
    def registration_verification_one_time_code_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator':
        return pulumi.get(self, "registration_verification_one_time_code_generator")

    @property
    @pulumi.getter(name="setupPasswordIdGenerator")
    def setup_password_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator':
        return pulumi.get(self, "setup_password_id_generator")

    @property
    @pulumi.getter(name="setupPasswordIdTimeToLiveInSeconds")
    def setup_password_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0.
        """
        return pulumi.get(self, "setup_password_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="twoFactorIdTimeToLiveInSeconds")
    def two_factor_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0.
        """
        return pulumi.get(self, "two_factor_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="twoFactorOneTimeCodeIdGenerator")
    def two_factor_one_time_code_id_generator(self) -> 'outputs.FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator':
        return pulumi.get(self, "two_factor_one_time_code_id_generator")

    @property
    @pulumi.getter(name="twoFactorTrustIdTimeToLiveInSeconds")
    def two_factor_trust_id_time_to_live_in_seconds(self) -> int:
        """
        The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0.
        """
        return pulumi.get(self, "two_factor_trust_id_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="pendingAccountLinkTimeToLiveInSeconds")
    def pending_account_link_time_to_live_in_seconds(self) -> Optional[int]:
        """
        The number of seconds before the pending account link identifier is no longer valid to complete an account link request. Value must be greater than 0.
        """
        return pulumi.get(self, "pending_account_link_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="samlV2AuthnRequestIdTtlSeconds")
    def saml_v2_authn_request_id_ttl_seconds(self) -> Optional[int]:
        """
        The time in seconds that a SAML AuthN request will be eligible for use to authenticate with FusionAuth.
        """
        return pulumi.get(self, "saml_v2_authn_request_id_ttl_seconds")

    @property
    @pulumi.getter(name="trustTokenTimeToLiveInSeconds")
    def trust_token_time_to_live_in_seconds(self) -> Optional[int]:
        """
        The number of seconds before the Trust Token is no longer valid to complete a request that requires trust. Value must be greater than 0.
        """
        return pulumi.get(self, "trust_token_time_to_live_in_seconds")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationChangePasswordIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationDeviceUserCodeIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationEmailVerificationIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationEmailVerificationOneTimeCodeGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: Optional[str] = None):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationPasswordlessLoginGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationRegistrationVerificationOneTimeCodeGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: Optional[str] = None):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationSetupPasswordIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: str):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantExternalIdentifierConfigurationTwoFactorOneTimeCodeIdGenerator(dict):
    def __init__(__self__, *,
                 length: int,
                 type: Optional[str] = None):
        """
        :param int length: TThe length of the secure generator used for generating the the two factor code Id.
        :param str type: The type of the secure generator used for generating the two factor one time code Id.
        """
        pulumi.set(__self__, "length", length)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        TThe length of the secure generator used for generating the the two factor code Id.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the secure generator used for generating the two factor one time code Id.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FusionAuthTenantFailedAuthenticationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCancelPolicyOnPasswordReset":
            suggest = "action_cancel_policy_on_password_reset"
        elif key == "actionDuration":
            suggest = "action_duration"
        elif key == "actionDurationUnit":
            suggest = "action_duration_unit"
        elif key == "emailUser":
            suggest = "email_user"
        elif key == "resetCountInSeconds":
            suggest = "reset_count_in_seconds"
        elif key == "tooManyAttempts":
            suggest = "too_many_attempts"
        elif key == "userActionId":
            suggest = "user_action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantFailedAuthenticationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantFailedAuthenticationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantFailedAuthenticationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_cancel_policy_on_password_reset: Optional[bool] = None,
                 action_duration: Optional[int] = None,
                 action_duration_unit: Optional[str] = None,
                 email_user: Optional[bool] = None,
                 reset_count_in_seconds: Optional[int] = None,
                 too_many_attempts: Optional[int] = None,
                 user_action_id: Optional[str] = None):
        """
        :param bool action_cancel_policy_on_password_reset: Indicates whether you want the user to be able to self-service unlock their account prior to the action duration by completing a password reset workflow.
        :param int action_duration: The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0.
        :param str action_duration_unit: The unit of time associated with a duration.
        :param bool email_user: Indicates you would like to email the user when the user’s account is locked due to this action being taken. This requires the User Action specified by the tenant.failedAuthenticationConfiguration.userActionId to also be configured for email. If the User Action is not configured to be able to email the user, this configuration will be ignored.
        :param int reset_count_in_seconds: The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.
        :param int too_many_attempts: The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0.
        :param str user_action_id: The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts.
        """
        if action_cancel_policy_on_password_reset is not None:
            pulumi.set(__self__, "action_cancel_policy_on_password_reset", action_cancel_policy_on_password_reset)
        if action_duration is not None:
            pulumi.set(__self__, "action_duration", action_duration)
        if action_duration_unit is not None:
            pulumi.set(__self__, "action_duration_unit", action_duration_unit)
        if email_user is not None:
            pulumi.set(__self__, "email_user", email_user)
        if reset_count_in_seconds is not None:
            pulumi.set(__self__, "reset_count_in_seconds", reset_count_in_seconds)
        if too_many_attempts is not None:
            pulumi.set(__self__, "too_many_attempts", too_many_attempts)
        if user_action_id is not None:
            pulumi.set(__self__, "user_action_id", user_action_id)

    @property
    @pulumi.getter(name="actionCancelPolicyOnPasswordReset")
    def action_cancel_policy_on_password_reset(self) -> Optional[bool]:
        """
        Indicates whether you want the user to be able to self-service unlock their account prior to the action duration by completing a password reset workflow.
        """
        return pulumi.get(self, "action_cancel_policy_on_password_reset")

    @property
    @pulumi.getter(name="actionDuration")
    def action_duration(self) -> Optional[int]:
        """
        The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0.
        """
        return pulumi.get(self, "action_duration")

    @property
    @pulumi.getter(name="actionDurationUnit")
    def action_duration_unit(self) -> Optional[str]:
        """
        The unit of time associated with a duration.
        """
        return pulumi.get(self, "action_duration_unit")

    @property
    @pulumi.getter(name="emailUser")
    def email_user(self) -> Optional[bool]:
        """
        Indicates you would like to email the user when the user’s account is locked due to this action being taken. This requires the User Action specified by the tenant.failedAuthenticationConfiguration.userActionId to also be configured for email. If the User Action is not configured to be able to email the user, this configuration will be ignored.
        """
        return pulumi.get(self, "email_user")

    @property
    @pulumi.getter(name="resetCountInSeconds")
    def reset_count_in_seconds(self) -> Optional[int]:
        """
        The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.
        """
        return pulumi.get(self, "reset_count_in_seconds")

    @property
    @pulumi.getter(name="tooManyAttempts")
    def too_many_attempts(self) -> Optional[int]:
        """
        The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0.
        """
        return pulumi.get(self, "too_many_attempts")

    @property
    @pulumi.getter(name="userActionId")
    def user_action_id(self) -> Optional[str]:
        """
        The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts.
        """
        return pulumi.get(self, "user_action_id")


@pulumi.output_type
class FusionAuthTenantFamilyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowChildRegistrations":
            suggest = "allow_child_registrations"
        elif key == "confirmChildEmailTemplateId":
            suggest = "confirm_child_email_template_id"
        elif key == "deleteOrphanedAccounts":
            suggest = "delete_orphaned_accounts"
        elif key == "deleteOrphanedAccountsDays":
            suggest = "delete_orphaned_accounts_days"
        elif key == "familyRequestEmailTemplateId":
            suggest = "family_request_email_template_id"
        elif key == "maximumChildAge":
            suggest = "maximum_child_age"
        elif key == "minimumOwnerAge":
            suggest = "minimum_owner_age"
        elif key == "parentEmailRequired":
            suggest = "parent_email_required"
        elif key == "parentRegistrationEmailTemplateId":
            suggest = "parent_registration_email_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantFamilyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantFamilyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantFamilyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_child_registrations: Optional[bool] = None,
                 confirm_child_email_template_id: Optional[str] = None,
                 delete_orphaned_accounts: Optional[bool] = None,
                 delete_orphaned_accounts_days: Optional[int] = None,
                 enabled: Optional[bool] = None,
                 family_request_email_template_id: Optional[str] = None,
                 maximum_child_age: Optional[int] = None,
                 minimum_owner_age: Optional[int] = None,
                 parent_email_required: Optional[bool] = None,
                 parent_registration_email_template_id: Optional[str] = None):
        """
        :param bool allow_child_registrations: Whether to allow child registrations.
        :param str confirm_child_email_template_id: The unique Id of the email template to use when confirming a child.
        :param bool delete_orphaned_accounts: Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days.
        :param int delete_orphaned_accounts_days: The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0.
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str family_request_email_template_id: The unique Id of the email template to use when a family request is made.
        :param int maximum_child_age: The maximum age of a child. Value must be greater than 0.
        :param int minimum_owner_age: The minimum age to be an owner. Value must be greater than 0.
        :param bool parent_email_required: Whether a parent email is required.
        :param str parent_registration_email_template_id: The unique Id of the email template to use for parent registration.
        """
        if allow_child_registrations is not None:
            pulumi.set(__self__, "allow_child_registrations", allow_child_registrations)
        if confirm_child_email_template_id is not None:
            pulumi.set(__self__, "confirm_child_email_template_id", confirm_child_email_template_id)
        if delete_orphaned_accounts is not None:
            pulumi.set(__self__, "delete_orphaned_accounts", delete_orphaned_accounts)
        if delete_orphaned_accounts_days is not None:
            pulumi.set(__self__, "delete_orphaned_accounts_days", delete_orphaned_accounts_days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if family_request_email_template_id is not None:
            pulumi.set(__self__, "family_request_email_template_id", family_request_email_template_id)
        if maximum_child_age is not None:
            pulumi.set(__self__, "maximum_child_age", maximum_child_age)
        if minimum_owner_age is not None:
            pulumi.set(__self__, "minimum_owner_age", minimum_owner_age)
        if parent_email_required is not None:
            pulumi.set(__self__, "parent_email_required", parent_email_required)
        if parent_registration_email_template_id is not None:
            pulumi.set(__self__, "parent_registration_email_template_id", parent_registration_email_template_id)

    @property
    @pulumi.getter(name="allowChildRegistrations")
    def allow_child_registrations(self) -> Optional[bool]:
        """
        Whether to allow child registrations.
        """
        return pulumi.get(self, "allow_child_registrations")

    @property
    @pulumi.getter(name="confirmChildEmailTemplateId")
    def confirm_child_email_template_id(self) -> Optional[str]:
        """
        The unique Id of the email template to use when confirming a child.
        """
        return pulumi.get(self, "confirm_child_email_template_id")

    @property
    @pulumi.getter(name="deleteOrphanedAccounts")
    def delete_orphaned_accounts(self) -> Optional[bool]:
        """
        Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days.
        """
        return pulumi.get(self, "delete_orphaned_accounts")

    @property
    @pulumi.getter(name="deleteOrphanedAccountsDays")
    def delete_orphaned_accounts_days(self) -> Optional[int]:
        """
        The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0.
        """
        return pulumi.get(self, "delete_orphaned_accounts_days")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="familyRequestEmailTemplateId")
    def family_request_email_template_id(self) -> Optional[str]:
        """
        The unique Id of the email template to use when a family request is made.
        """
        return pulumi.get(self, "family_request_email_template_id")

    @property
    @pulumi.getter(name="maximumChildAge")
    def maximum_child_age(self) -> Optional[int]:
        """
        The maximum age of a child. Value must be greater than 0.
        """
        return pulumi.get(self, "maximum_child_age")

    @property
    @pulumi.getter(name="minimumOwnerAge")
    def minimum_owner_age(self) -> Optional[int]:
        """
        The minimum age to be an owner. Value must be greater than 0.
        """
        return pulumi.get(self, "minimum_owner_age")

    @property
    @pulumi.getter(name="parentEmailRequired")
    def parent_email_required(self) -> Optional[bool]:
        """
        Whether a parent email is required.
        """
        return pulumi.get(self, "parent_email_required")

    @property
    @pulumi.getter(name="parentRegistrationEmailTemplateId")
    def parent_registration_email_template_id(self) -> Optional[str]:
        """
        The unique Id of the email template to use for parent registration.
        """
        return pulumi.get(self, "parent_registration_email_template_id")


@pulumi.output_type
class FusionAuthTenantFormConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUserFormId":
            suggest = "admin_user_form_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantFormConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantFormConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantFormConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_user_form_id: Optional[str] = None):
        """
        :param str admin_user_form_id: The unique Id of the form to use for the Add and Edit User form when used in the FusionAuth admin UI.
        """
        if admin_user_form_id is not None:
            pulumi.set(__self__, "admin_user_form_id", admin_user_form_id)

    @property
    @pulumi.getter(name="adminUserFormId")
    def admin_user_form_id(self) -> Optional[str]:
        """
        The unique Id of the form to use for the Add and Edit User form when used in the FusionAuth admin UI.
        """
        return pulumi.get(self, "admin_user_form_id")


@pulumi.output_type
class FusionAuthTenantJwtConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshTokenTimeToLiveInMinutes":
            suggest = "refresh_token_time_to_live_in_minutes"
        elif key == "timeToLiveInSeconds":
            suggest = "time_to_live_in_seconds"
        elif key == "accessTokenKeyId":
            suggest = "access_token_key_id"
        elif key == "idTokenKeyId":
            suggest = "id_token_key_id"
        elif key == "refreshTokenExpirationPolicy":
            suggest = "refresh_token_expiration_policy"
        elif key == "refreshTokenRevocationPolicyOnLoginPrevented":
            suggest = "refresh_token_revocation_policy_on_login_prevented"
        elif key == "refreshTokenRevocationPolicyOnPasswordChange":
            suggest = "refresh_token_revocation_policy_on_password_change"
        elif key == "refreshTokenUsagePolicy":
            suggest = "refresh_token_usage_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantJwtConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantJwtConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantJwtConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_token_time_to_live_in_minutes: int,
                 time_to_live_in_seconds: int,
                 access_token_key_id: Optional[str] = None,
                 id_token_key_id: Optional[str] = None,
                 refresh_token_expiration_policy: Optional[str] = None,
                 refresh_token_revocation_policy_on_login_prevented: Optional[bool] = None,
                 refresh_token_revocation_policy_on_password_change: Optional[bool] = None,
                 refresh_token_usage_policy: Optional[str] = None):
        """
        :param int refresh_token_time_to_live_in_minutes: The length of time in minutes a Refresh Token is valid from the time it was issued. Value must be greater than 0.
        :param int time_to_live_in_seconds: The length of time in seconds this JWT is valid from the time it was issued. Value must be greater than 0.
        :param str access_token_key_id: The unique id of the signing key used to sign the access token. Required prior to `1.30.0`.
        :param str id_token_key_id: The unique id of the signing key used to sign the Id token. Required prior to `1.30.0`.
        :param str refresh_token_expiration_policy: The refresh token expiration policy.
        :param bool refresh_token_revocation_policy_on_login_prevented: When enabled, the refresh token will be revoked when a user action, such as locking an account based on a number of failed login attempts, prevents user login.
        :param bool refresh_token_revocation_policy_on_password_change: When enabled, the refresh token will be revoked when a user changes their password."
        :param str refresh_token_usage_policy: The refresh token usage policy.
        """
        pulumi.set(__self__, "refresh_token_time_to_live_in_minutes", refresh_token_time_to_live_in_minutes)
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        if access_token_key_id is not None:
            pulumi.set(__self__, "access_token_key_id", access_token_key_id)
        if id_token_key_id is not None:
            pulumi.set(__self__, "id_token_key_id", id_token_key_id)
        if refresh_token_expiration_policy is not None:
            pulumi.set(__self__, "refresh_token_expiration_policy", refresh_token_expiration_policy)
        if refresh_token_revocation_policy_on_login_prevented is not None:
            pulumi.set(__self__, "refresh_token_revocation_policy_on_login_prevented", refresh_token_revocation_policy_on_login_prevented)
        if refresh_token_revocation_policy_on_password_change is not None:
            pulumi.set(__self__, "refresh_token_revocation_policy_on_password_change", refresh_token_revocation_policy_on_password_change)
        if refresh_token_usage_policy is not None:
            pulumi.set(__self__, "refresh_token_usage_policy", refresh_token_usage_policy)

    @property
    @pulumi.getter(name="refreshTokenTimeToLiveInMinutes")
    def refresh_token_time_to_live_in_minutes(self) -> int:
        """
        The length of time in minutes a Refresh Token is valid from the time it was issued. Value must be greater than 0.
        """
        return pulumi.get(self, "refresh_token_time_to_live_in_minutes")

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> int:
        """
        The length of time in seconds this JWT is valid from the time it was issued. Value must be greater than 0.
        """
        return pulumi.get(self, "time_to_live_in_seconds")

    @property
    @pulumi.getter(name="accessTokenKeyId")
    def access_token_key_id(self) -> Optional[str]:
        """
        The unique id of the signing key used to sign the access token. Required prior to `1.30.0`.
        """
        return pulumi.get(self, "access_token_key_id")

    @property
    @pulumi.getter(name="idTokenKeyId")
    def id_token_key_id(self) -> Optional[str]:
        """
        The unique id of the signing key used to sign the Id token. Required prior to `1.30.0`.
        """
        return pulumi.get(self, "id_token_key_id")

    @property
    @pulumi.getter(name="refreshTokenExpirationPolicy")
    def refresh_token_expiration_policy(self) -> Optional[str]:
        """
        The refresh token expiration policy.
        """
        return pulumi.get(self, "refresh_token_expiration_policy")

    @property
    @pulumi.getter(name="refreshTokenRevocationPolicyOnLoginPrevented")
    def refresh_token_revocation_policy_on_login_prevented(self) -> Optional[bool]:
        """
        When enabled, the refresh token will be revoked when a user action, such as locking an account based on a number of failed login attempts, prevents user login.
        """
        return pulumi.get(self, "refresh_token_revocation_policy_on_login_prevented")

    @property
    @pulumi.getter(name="refreshTokenRevocationPolicyOnPasswordChange")
    def refresh_token_revocation_policy_on_password_change(self) -> Optional[bool]:
        """
        When enabled, the refresh token will be revoked when a user changes their password."
        """
        return pulumi.get(self, "refresh_token_revocation_policy_on_password_change")

    @property
    @pulumi.getter(name="refreshTokenUsagePolicy")
    def refresh_token_usage_policy(self) -> Optional[str]:
        """
        The refresh token usage policy.
        """
        return pulumi.get(self, "refresh_token_usage_policy")


@pulumi.output_type
class FusionAuthTenantLoginConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireAuthentication":
            suggest = "require_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantLoginConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantLoginConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantLoginConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 require_authentication: Optional[bool] = None):
        """
        :param bool require_authentication: Indicates whether to require an API key for the Login API when an `applicationId` is not provided. When an `applicationId` is provided to the Login API call, the application configuration will take precedence. In almost all cases, you will want to this to be `true`.
        """
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        Indicates whether to require an API key for the Login API when an `applicationId` is not provided. When an `applicationId` is provided to the Login API call, the application configuration will take precedence. In almost all cases, you will want to this to be `true`.
        """
        return pulumi.get(self, "require_authentication")


@pulumi.output_type
class FusionAuthTenantMaximumPasswordAge(dict):
    def __init__(__self__, *,
                 days: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int days: The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. Required when systemConfiguration.maximumPasswordAge.enabled is set to true.
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. Required when systemConfiguration.maximumPasswordAge.enabled is set to true.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthTenantMinimumPasswordAge(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int seconds: The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. Required when systemConfiguration.minimumPasswordAge.enabled is set to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[int]:
        """
        The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. Required when systemConfiguration.minimumPasswordAge.enabled is set to true.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class FusionAuthTenantMultiFactorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPolicy":
            suggest = "login_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantMultiFactorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantMultiFactorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantMultiFactorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticator: Optional['outputs.FusionAuthTenantMultiFactorConfigurationAuthenticator'] = None,
                 email: Optional['outputs.FusionAuthTenantMultiFactorConfigurationEmail'] = None,
                 login_policy: Optional[str] = None,
                 sms: Optional['outputs.FusionAuthTenantMultiFactorConfigurationSms'] = None):
        """
        :param str login_policy: When set to `Enabled` and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When set to `Disabled`, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When the login policy is to `Required`, a two-factor challenge will be required during login. If a user does not have configured two-factor methods, they will not be able to log in.
        """
        if authenticator is not None:
            pulumi.set(__self__, "authenticator", authenticator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if login_policy is not None:
            pulumi.set(__self__, "login_policy", login_policy)
        if sms is not None:
            pulumi.set(__self__, "sms", sms)

    @property
    @pulumi.getter
    def authenticator(self) -> Optional['outputs.FusionAuthTenantMultiFactorConfigurationAuthenticator']:
        return pulumi.get(self, "authenticator")

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.FusionAuthTenantMultiFactorConfigurationEmail']:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="loginPolicy")
    def login_policy(self) -> Optional[str]:
        """
        When set to `Enabled` and a user has one or more two-factor methods configured, the user will be required to complete a two-factor challenge during login. When set to `Disabled`, even when a user has configured one or more two-factor methods, the user will not be required to complete a two-factor challenge during login. When the login policy is to `Required`, a two-factor challenge will be required during login. If a user does not have configured two-factor methods, they will not be able to log in.
        """
        return pulumi.get(self, "login_policy")

    @property
    @pulumi.getter
    def sms(self) -> Optional['outputs.FusionAuthTenantMultiFactorConfigurationSms']:
        return pulumi.get(self, "sms")


@pulumi.output_type
class FusionAuthTenantMultiFactorConfigurationAuthenticator(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthTenantMultiFactorConfigurationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantMultiFactorConfigurationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantMultiFactorConfigurationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantMultiFactorConfigurationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 template_id: Optional[str] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class FusionAuthTenantMultiFactorConfigurationSms(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messengerId":
            suggest = "messenger_id"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantMultiFactorConfigurationSms. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantMultiFactorConfigurationSms.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantMultiFactorConfigurationSms.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 messenger_id: Optional[str] = None,
                 template_id: Optional[str] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str messenger_id: The messenger that is used to deliver a SMS multi-factor authentication request.
        :param str template_id: The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if messenger_id is not None:
            pulumi.set(__self__, "messenger_id", messenger_id)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="messengerId")
    def messenger_id(self) -> Optional[str]:
        """
        The messenger that is used to deliver a SMS multi-factor authentication request.
        """
        return pulumi.get(self, "messenger_id")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The Id of the SMS template that is used when notifying a user to complete a multi-factor authentication request.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class FusionAuthTenantOauthConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentialsAccessTokenPopulateLambdaId":
            suggest = "client_credentials_access_token_populate_lambda_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantOauthConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantOauthConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantOauthConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials_access_token_populate_lambda_id: Optional[str] = None):
        """
        :param str client_credentials_access_token_populate_lambda_id: The Id of a lambda that will be called to populate the JWT during a client credentials grant. **Note:** A paid edition of FusionAuth is required to utilize client credentials grant.
        """
        if client_credentials_access_token_populate_lambda_id is not None:
            pulumi.set(__self__, "client_credentials_access_token_populate_lambda_id", client_credentials_access_token_populate_lambda_id)

    @property
    @pulumi.getter(name="clientCredentialsAccessTokenPopulateLambdaId")
    def client_credentials_access_token_populate_lambda_id(self) -> Optional[str]:
        """
        The Id of a lambda that will be called to populate the JWT during a client credentials grant. **Note:** A paid edition of FusionAuth is required to utilize client credentials grant.
        """
        return pulumi.get(self, "client_credentials_access_token_populate_lambda_id")


@pulumi.output_type
class FusionAuthTenantPasswordEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionScheme":
            suggest = "encryption_scheme"
        elif key == "encryptionSchemeFactor":
            suggest = "encryption_scheme_factor"
        elif key == "modifyEncryptionSchemeOnLogin":
            suggest = "modify_encryption_scheme_on_login"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantPasswordEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantPasswordEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantPasswordEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_scheme: Optional[str] = None,
                 encryption_scheme_factor: Optional[int] = None,
                 modify_encryption_scheme_on_login: Optional[bool] = None):
        """
        :param str encryption_scheme: The default method for encrypting the User’s password.
        :param int encryption_scheme_factor: The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation.
        :param bool modify_encryption_scheme_on_login: When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import.
        """
        if encryption_scheme is not None:
            pulumi.set(__self__, "encryption_scheme", encryption_scheme)
        if encryption_scheme_factor is not None:
            pulumi.set(__self__, "encryption_scheme_factor", encryption_scheme_factor)
        if modify_encryption_scheme_on_login is not None:
            pulumi.set(__self__, "modify_encryption_scheme_on_login", modify_encryption_scheme_on_login)

    @property
    @pulumi.getter(name="encryptionScheme")
    def encryption_scheme(self) -> Optional[str]:
        """
        The default method for encrypting the User’s password.
        """
        return pulumi.get(self, "encryption_scheme")

    @property
    @pulumi.getter(name="encryptionSchemeFactor")
    def encryption_scheme_factor(self) -> Optional[int]:
        """
        The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation.
        """
        return pulumi.get(self, "encryption_scheme_factor")

    @property
    @pulumi.getter(name="modifyEncryptionSchemeOnLogin")
    def modify_encryption_scheme_on_login(self) -> Optional[bool]:
        """
        When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import.
        """
        return pulumi.get(self, "modify_encryption_scheme_on_login")


@pulumi.output_type
class FusionAuthTenantPasswordValidationRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breachDetection":
            suggest = "breach_detection"
        elif key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "rememberPreviousPasswords":
            suggest = "remember_previous_passwords"
        elif key == "requireNonAlpha":
            suggest = "require_non_alpha"
        elif key == "requireNumber":
            suggest = "require_number"
        elif key == "requiredMixedCase":
            suggest = "required_mixed_case"
        elif key == "validateOnLogin":
            suggest = "validate_on_login"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantPasswordValidationRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantPasswordValidationRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantPasswordValidationRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breach_detection: Optional['outputs.FusionAuthTenantPasswordValidationRulesBreachDetection'] = None,
                 max_length: Optional[int] = None,
                 min_length: Optional[int] = None,
                 remember_previous_passwords: Optional['outputs.FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords'] = None,
                 require_non_alpha: Optional[bool] = None,
                 require_number: Optional[bool] = None,
                 required_mixed_case: Optional[bool] = None,
                 validate_on_login: Optional[bool] = None):
        """
        :param int max_length: The maximum length of a password when a new user is created or a user requests a password change.
        :param int min_length: The minimum length of a password when a new user is created or a user requests a password change.
        :param bool require_non_alpha: Whether to force the user to use at least one non-alphanumeric character.
        :param bool require_number: Whether to force the user to use at least one number.
        :param bool required_mixed_case: Whether to force the user to use at least one uppercase and one lowercase character.
        :param bool validate_on_login: When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        if breach_detection is not None:
            pulumi.set(__self__, "breach_detection", breach_detection)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if remember_previous_passwords is not None:
            pulumi.set(__self__, "remember_previous_passwords", remember_previous_passwords)
        if require_non_alpha is not None:
            pulumi.set(__self__, "require_non_alpha", require_non_alpha)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if required_mixed_case is not None:
            pulumi.set(__self__, "required_mixed_case", required_mixed_case)
        if validate_on_login is not None:
            pulumi.set(__self__, "validate_on_login", validate_on_login)

    @property
    @pulumi.getter(name="breachDetection")
    def breach_detection(self) -> Optional['outputs.FusionAuthTenantPasswordValidationRulesBreachDetection']:
        return pulumi.get(self, "breach_detection")

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[int]:
        """
        The maximum length of a password when a new user is created or a user requests a password change.
        """
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        """
        The minimum length of a password when a new user is created or a user requests a password change.
        """
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="rememberPreviousPasswords")
    def remember_previous_passwords(self) -> Optional['outputs.FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords']:
        return pulumi.get(self, "remember_previous_passwords")

    @property
    @pulumi.getter(name="requireNonAlpha")
    def require_non_alpha(self) -> Optional[bool]:
        """
        Whether to force the user to use at least one non-alphanumeric character.
        """
        return pulumi.get(self, "require_non_alpha")

    @property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[bool]:
        """
        Whether to force the user to use at least one number.
        """
        return pulumi.get(self, "require_number")

    @property
    @pulumi.getter(name="requiredMixedCase")
    def required_mixed_case(self) -> Optional[bool]:
        """
        Whether to force the user to use at least one uppercase and one lowercase character.
        """
        return pulumi.get(self, "required_mixed_case")

    @property
    @pulumi.getter(name="validateOnLogin")
    def validate_on_login(self) -> Optional[bool]:
        """
        When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        return pulumi.get(self, "validate_on_login")


@pulumi.output_type
class FusionAuthTenantPasswordValidationRulesBreachDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchMode":
            suggest = "match_mode"
        elif key == "notifyUserEmailTemplateId":
            suggest = "notify_user_email_template_id"
        elif key == "onLogin":
            suggest = "on_login"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantPasswordValidationRulesBreachDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantPasswordValidationRulesBreachDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantPasswordValidationRulesBreachDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 match_mode: Optional[str] = None,
                 notify_user_email_template_id: Optional[str] = None,
                 on_login: Optional[str] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param str match_mode: The level of severity where Reactor will consider a breach.
        :param str notify_user_email_template_id: The Id of the email template to use when notifying user of breached password. Required if tenant.passwordValidationRules.breachDetection.onLogin is set to NotifyUser.
        :param str on_login: The behavior when detecting breaches at time of user login
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_mode is not None:
            pulumi.set(__self__, "match_mode", match_mode)
        if notify_user_email_template_id is not None:
            pulumi.set(__self__, "notify_user_email_template_id", notify_user_email_template_id)
        if on_login is not None:
            pulumi.set(__self__, "on_login", on_login)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="matchMode")
    def match_mode(self) -> Optional[str]:
        """
        The level of severity where Reactor will consider a breach.
        """
        return pulumi.get(self, "match_mode")

    @property
    @pulumi.getter(name="notifyUserEmailTemplateId")
    def notify_user_email_template_id(self) -> Optional[str]:
        """
        The Id of the email template to use when notifying user of breached password. Required if tenant.passwordValidationRules.breachDetection.onLogin is set to NotifyUser.
        """
        return pulumi.get(self, "notify_user_email_template_id")

    @property
    @pulumi.getter(name="onLogin")
    def on_login(self) -> Optional[str]:
        """
        The behavior when detecting breaches at time of user login
        """
        return pulumi.get(self, "on_login")


@pulumi.output_type
class FusionAuthTenantPasswordValidationRulesRememberPreviousPasswords(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int count: The number of previous passwords to remember. Value must be greater than 0.
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of previous passwords to remember. Value must be greater than 0.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FusionAuthTenantRateLimitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedLogin":
            suggest = "failed_login"
        elif key == "forgotPassword":
            suggest = "forgot_password"
        elif key == "sendEmailVerification":
            suggest = "send_email_verification"
        elif key == "sendPasswordless":
            suggest = "send_passwordless"
        elif key == "sendRegistrationVerification":
            suggest = "send_registration_verification"
        elif key == "sendTwoFactor":
            suggest = "send_two_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_login: Optional['outputs.FusionAuthTenantRateLimitConfigurationFailedLogin'] = None,
                 forgot_password: Optional['outputs.FusionAuthTenantRateLimitConfigurationForgotPassword'] = None,
                 send_email_verification: Optional['outputs.FusionAuthTenantRateLimitConfigurationSendEmailVerification'] = None,
                 send_passwordless: Optional['outputs.FusionAuthTenantRateLimitConfigurationSendPasswordless'] = None,
                 send_registration_verification: Optional['outputs.FusionAuthTenantRateLimitConfigurationSendRegistrationVerification'] = None,
                 send_two_factor: Optional['outputs.FusionAuthTenantRateLimitConfigurationSendTwoFactor'] = None):
        if failed_login is not None:
            pulumi.set(__self__, "failed_login", failed_login)
        if forgot_password is not None:
            pulumi.set(__self__, "forgot_password", forgot_password)
        if send_email_verification is not None:
            pulumi.set(__self__, "send_email_verification", send_email_verification)
        if send_passwordless is not None:
            pulumi.set(__self__, "send_passwordless", send_passwordless)
        if send_registration_verification is not None:
            pulumi.set(__self__, "send_registration_verification", send_registration_verification)
        if send_two_factor is not None:
            pulumi.set(__self__, "send_two_factor", send_two_factor)

    @property
    @pulumi.getter(name="failedLogin")
    def failed_login(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationFailedLogin']:
        return pulumi.get(self, "failed_login")

    @property
    @pulumi.getter(name="forgotPassword")
    def forgot_password(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationForgotPassword']:
        return pulumi.get(self, "forgot_password")

    @property
    @pulumi.getter(name="sendEmailVerification")
    def send_email_verification(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationSendEmailVerification']:
        return pulumi.get(self, "send_email_verification")

    @property
    @pulumi.getter(name="sendPasswordless")
    def send_passwordless(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationSendPasswordless']:
        return pulumi.get(self, "send_passwordless")

    @property
    @pulumi.getter(name="sendRegistrationVerification")
    def send_registration_verification(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationSendRegistrationVerification']:
        return pulumi.get(self, "send_registration_verification")

    @property
    @pulumi.getter(name="sendTwoFactor")
    def send_two_factor(self) -> Optional['outputs.FusionAuthTenantRateLimitConfigurationSendTwoFactor']:
        return pulumi.get(self, "send_two_factor")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationFailedLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationFailedLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationFailedLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationFailedLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationForgotPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationForgotPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationForgotPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationForgotPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationSendEmailVerification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationSendEmailVerification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationSendEmailVerification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationSendEmailVerification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationSendPasswordless(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationSendPasswordless. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationSendPasswordless.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationSendPasswordless.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationSendRegistrationVerification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationSendRegistrationVerification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationSendRegistrationVerification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationSendRegistrationVerification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRateLimitConfigurationSendTwoFactor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriodInSeconds":
            suggest = "time_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRateLimitConfigurationSendTwoFactor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRateLimitConfigurationSendTwoFactor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRateLimitConfigurationSendTwoFactor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 limit: Optional[int] = None,
                 time_period_in_seconds: Optional[int] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int limit: The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        :param int time_period_in_seconds: The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_period_in_seconds is not None:
            pulumi.set(__self__, "time_period_in_seconds", time_period_in_seconds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of times a user can request a two-factor code by email or SMS within the configured `time_period_in_seconds` duration.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="timePeriodInSeconds")
    def time_period_in_seconds(self) -> Optional[int]:
        """
        The duration for the number of times a user can request a two-factor code by email or SMS before being rate limited.
        """
        return pulumi.get(self, "time_period_in_seconds")


@pulumi.output_type
class FusionAuthTenantRegistrationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockedDomains":
            suggest = "blocked_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantRegistrationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantRegistrationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantRegistrationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocked_domains: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] blocked_domains: A list of unique domains that are not allowed to register when self service is enabled.
        """
        if blocked_domains is not None:
            pulumi.set(__self__, "blocked_domains", blocked_domains)

    @property
    @pulumi.getter(name="blockedDomains")
    def blocked_domains(self) -> Optional[Sequence[str]]:
        """
        A list of unique domains that are not allowed to register when self service is enabled.
        """
        return pulumi.get(self, "blocked_domains")


@pulumi.output_type
class FusionAuthTenantUserDeletePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unverifiedEnabled":
            suggest = "unverified_enabled"
        elif key == "unverifiedNumberOfDaysToRetain":
            suggest = "unverified_number_of_days_to_retain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantUserDeletePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantUserDeletePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantUserDeletePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unverified_enabled: Optional[bool] = None,
                 unverified_number_of_days_to_retain: Optional[int] = None):
        """
        :param bool unverified_enabled: Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        if unverified_enabled is not None:
            pulumi.set(__self__, "unverified_enabled", unverified_enabled)
        if unverified_number_of_days_to_retain is not None:
            pulumi.set(__self__, "unverified_number_of_days_to_retain", unverified_number_of_days_to_retain)

    @property
    @pulumi.getter(name="unverifiedEnabled")
    def unverified_enabled(self) -> Optional[bool]:
        """
        Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unverified_enabled")

    @property
    @pulumi.getter(name="unverifiedNumberOfDaysToRetain")
    def unverified_number_of_days_to_retain(self) -> Optional[int]:
        return pulumi.get(self, "unverified_number_of_days_to_retain")


@pulumi.output_type
class FusionAuthTenantUsernameConfiguration(dict):
    def __init__(__self__, *,
                 unique: Optional['outputs.FusionAuthTenantUsernameConfigurationUnique'] = None):
        """
        :param 'FusionAuthTenantUsernameConfigurationUniqueArgs' unique: Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        if unique is not None:
            pulumi.set(__self__, "unique", unique)

    @property
    @pulumi.getter
    def unique(self) -> Optional['outputs.FusionAuthTenantUsernameConfigurationUnique']:
        """
        Indicates that users without a verified email address will be permanently deleted after tenant.userDeletePolicy.unverified.numberOfDaysToRetain days.
        """
        return pulumi.get(self, "unique")


@pulumi.output_type
class FusionAuthTenantUsernameConfigurationUnique(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfDigits":
            suggest = "number_of_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthTenantUsernameConfigurationUnique. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthTenantUsernameConfigurationUnique.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthTenantUsernameConfigurationUnique.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 number_of_digits: Optional[int] = None,
                 separator: Optional[str] = None,
                 strategy: Optional[str] = None):
        """
        :param bool enabled: When true, FusionAuth will handle username collisions by generating a random suffix.
        :param int number_of_digits: The maximum number of digits to use when building a unique suffix for a username. A number will be randomly selected and will be 1 or more digits up to this configured value in length. For example, if this value is 5, the suffix will be a number between 00001 and 99999, inclusive.
        :param str separator: A single character to use as a separator from the requested username and a unique suffix that is added when a duplicate username is detected. This value can be a single non-alphanumeric ASCII character.
        :param str strategy: When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if number_of_digits is not None:
            pulumi.set(__self__, "number_of_digits", number_of_digits)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true, FusionAuth will handle username collisions by generating a random suffix.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="numberOfDigits")
    def number_of_digits(self) -> Optional[int]:
        """
        The maximum number of digits to use when building a unique suffix for a username. A number will be randomly selected and will be 1 or more digits up to this configured value in length. For example, if this value is 5, the suffix will be a number between 00001 and 99999, inclusive.
        """
        return pulumi.get(self, "number_of_digits")

    @property
    @pulumi.getter
    def separator(self) -> Optional[str]:
        """
        A single character to use as a separator from the requested username and a unique suffix that is added when a duplicate username is detected. This value can be a single non-alphanumeric ASCII character.
        """
        return pulumi.get(self, "separator")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class FusionAuthUserActionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localizedNames":
            suggest = "localized_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthUserActionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthUserActionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthUserActionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 localized_names: Optional[Mapping[str, Any]] = None):
        """
        :param str name: The name of this User Action Option.
        :param Mapping[str, Any] localized_names: A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language.
        """
        pulumi.set(__self__, "name", name)
        if localized_names is not None:
            pulumi.set(__self__, "localized_names", localized_names)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this User Action Option.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="localizedNames")
    def localized_names(self) -> Optional[Mapping[str, Any]]:
        """
        A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language.
        """
        return pulumi.get(self, "localized_names")


@pulumi.output_type
class FusionAuthUserTwoFactorMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticatorAlgorithm":
            suggest = "authenticator_algorithm"
        elif key == "authenticatorCodeLength":
            suggest = "authenticator_code_length"
        elif key == "authenticatorTimeStep":
            suggest = "authenticator_time_step"
        elif key == "mobilePhone":
            suggest = "mobile_phone"
        elif key == "twoFactorMethodId":
            suggest = "two_factor_method_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthUserTwoFactorMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthUserTwoFactorMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthUserTwoFactorMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticator_algorithm: Optional[str] = None,
                 authenticator_code_length: Optional[int] = None,
                 authenticator_time_step: Optional[int] = None,
                 email: Optional[str] = None,
                 method: Optional[str] = None,
                 mobile_phone: Optional[str] = None,
                 secret: Optional[str] = None,
                 two_factor_method_id: Optional[str] = None):
        """
        :param str authenticator_algorithm: The algorithm used by the TOTP authenticator. With the current implementation, this will always be HmacSHA1.
        :param int authenticator_code_length: The length of code generated by the TOTP. With the current implementation, this will always be 6.
        :param int authenticator_time_step: The time-step size in seconds. With the current implementation, this will always be 30.
        :param str email: The value of the email address for this method.
        :param str method: The type of this method. There will also be an object with the same value containing additional information about this method.
        :param str mobile_phone: The value of the mobile phone for this method.
        :param str secret: A base64 encoded secret
        """
        if authenticator_algorithm is not None:
            pulumi.set(__self__, "authenticator_algorithm", authenticator_algorithm)
        if authenticator_code_length is not None:
            pulumi.set(__self__, "authenticator_code_length", authenticator_code_length)
        if authenticator_time_step is not None:
            pulumi.set(__self__, "authenticator_time_step", authenticator_time_step)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mobile_phone is not None:
            pulumi.set(__self__, "mobile_phone", mobile_phone)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if two_factor_method_id is not None:
            pulumi.set(__self__, "two_factor_method_id", two_factor_method_id)

    @property
    @pulumi.getter(name="authenticatorAlgorithm")
    def authenticator_algorithm(self) -> Optional[str]:
        """
        The algorithm used by the TOTP authenticator. With the current implementation, this will always be HmacSHA1.
        """
        return pulumi.get(self, "authenticator_algorithm")

    @property
    @pulumi.getter(name="authenticatorCodeLength")
    def authenticator_code_length(self) -> Optional[int]:
        """
        The length of code generated by the TOTP. With the current implementation, this will always be 6.
        """
        return pulumi.get(self, "authenticator_code_length")

    @property
    @pulumi.getter(name="authenticatorTimeStep")
    def authenticator_time_step(self) -> Optional[int]:
        """
        The time-step size in seconds. With the current implementation, this will always be 30.
        """
        return pulumi.get(self, "authenticator_time_step")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The value of the email address for this method.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The type of this method. There will also be an object with the same value containing additional information about this method.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="mobilePhone")
    def mobile_phone(self) -> Optional[str]:
        """
        The value of the mobile phone for this method.
        """
        return pulumi.get(self, "mobile_phone")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        A base64 encoded secret
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="twoFactorMethodId")
    def two_factor_method_id(self) -> Optional[str]:
        return pulumi.get(self, "two_factor_method_id")


@pulumi.output_type
class FusionAuthWebhookEventsEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogCreate":
            suggest = "audit_log_create"
        elif key == "eventLogCreate":
            suggest = "event_log_create"
        elif key == "jwtPublicKeyUpdate":
            suggest = "jwt_public_key_update"
        elif key == "jwtRefresh":
            suggest = "jwt_refresh"
        elif key == "jwtRefreshTokenRevoke":
            suggest = "jwt_refresh_token_revoke"
        elif key == "kickstartSuccess":
            suggest = "kickstart_success"
        elif key == "userAction":
            suggest = "user_action"
        elif key == "userBulkCreate":
            suggest = "user_bulk_create"
        elif key == "userCreate":
            suggest = "user_create"
        elif key == "userCreateComplete":
            suggest = "user_create_complete"
        elif key == "userDeactivate":
            suggest = "user_deactivate"
        elif key == "userDelete":
            suggest = "user_delete"
        elif key == "userDeleteComplete":
            suggest = "user_delete_complete"
        elif key == "userEmailUpdate":
            suggest = "user_email_update"
        elif key == "userEmailVerified":
            suggest = "user_email_verified"
        elif key == "userIdentityProviderLink":
            suggest = "user_identity_provider_link"
        elif key == "userIdentityProviderUnlink":
            suggest = "user_identity_provider_unlink"
        elif key == "userLoginFailed":
            suggest = "user_login_failed"
        elif key == "userLoginIdDuplicateCreate":
            suggest = "user_login_id_duplicate_create"
        elif key == "userLoginIdDuplicateUpdate":
            suggest = "user_login_id_duplicate_update"
        elif key == "userLoginNewDevice":
            suggest = "user_login_new_device"
        elif key == "userLoginSuccess":
            suggest = "user_login_success"
        elif key == "userLoginSuspicious":
            suggest = "user_login_suspicious"
        elif key == "userPasswordBreach":
            suggest = "user_password_breach"
        elif key == "userPasswordResetSend":
            suggest = "user_password_reset_send"
        elif key == "userPasswordResetStart":
            suggest = "user_password_reset_start"
        elif key == "userPasswordResetSuccess":
            suggest = "user_password_reset_success"
        elif key == "userPasswordUpdate":
            suggest = "user_password_update"
        elif key == "userReactivate":
            suggest = "user_reactivate"
        elif key == "userRegistrationCreate":
            suggest = "user_registration_create"
        elif key == "userRegistrationCreateComplete":
            suggest = "user_registration_create_complete"
        elif key == "userRegistrationDelete":
            suggest = "user_registration_delete"
        elif key == "userRegistrationDeleteComplete":
            suggest = "user_registration_delete_complete"
        elif key == "userRegistrationUpdate":
            suggest = "user_registration_update"
        elif key == "userRegistrationUpdateComplete":
            suggest = "user_registration_update_complete"
        elif key == "userRegistrationVerified":
            suggest = "user_registration_verified"
        elif key == "userTwoFactorMethodAdd":
            suggest = "user_two_factor_method_add"
        elif key == "userTwoFactorMethodRemove":
            suggest = "user_two_factor_method_remove"
        elif key == "userUpdate":
            suggest = "user_update"
        elif key == "userUpdateComplete":
            suggest = "user_update_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionAuthWebhookEventsEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionAuthWebhookEventsEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionAuthWebhookEventsEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log_create: Optional[bool] = None,
                 event_log_create: Optional[bool] = None,
                 jwt_public_key_update: Optional[bool] = None,
                 jwt_refresh: Optional[bool] = None,
                 jwt_refresh_token_revoke: Optional[bool] = None,
                 kickstart_success: Optional[bool] = None,
                 user_action: Optional[bool] = None,
                 user_bulk_create: Optional[bool] = None,
                 user_create: Optional[bool] = None,
                 user_create_complete: Optional[bool] = None,
                 user_deactivate: Optional[bool] = None,
                 user_delete: Optional[bool] = None,
                 user_delete_complete: Optional[bool] = None,
                 user_email_update: Optional[bool] = None,
                 user_email_verified: Optional[bool] = None,
                 user_identity_provider_link: Optional[bool] = None,
                 user_identity_provider_unlink: Optional[bool] = None,
                 user_login_failed: Optional[bool] = None,
                 user_login_id_duplicate_create: Optional[bool] = None,
                 user_login_id_duplicate_update: Optional[bool] = None,
                 user_login_new_device: Optional[bool] = None,
                 user_login_success: Optional[bool] = None,
                 user_login_suspicious: Optional[bool] = None,
                 user_password_breach: Optional[bool] = None,
                 user_password_reset_send: Optional[bool] = None,
                 user_password_reset_start: Optional[bool] = None,
                 user_password_reset_success: Optional[bool] = None,
                 user_password_update: Optional[bool] = None,
                 user_reactivate: Optional[bool] = None,
                 user_registration_create: Optional[bool] = None,
                 user_registration_create_complete: Optional[bool] = None,
                 user_registration_delete: Optional[bool] = None,
                 user_registration_delete_complete: Optional[bool] = None,
                 user_registration_update: Optional[bool] = None,
                 user_registration_update_complete: Optional[bool] = None,
                 user_registration_verified: Optional[bool] = None,
                 user_two_factor_method_add: Optional[bool] = None,
                 user_two_factor_method_remove: Optional[bool] = None,
                 user_update: Optional[bool] = None,
                 user_update_complete: Optional[bool] = None):
        """
        :param bool audit_log_create: When an audit log is created
        :param bool event_log_create: When an event log is created
        :param bool jwt_public_key_update: When a JWT RSA Public / Private keypair may have been changed
        :param bool jwt_refresh: When an access token is refreshed using a refresh token
        :param bool jwt_refresh_token_revoke: When a JWT Refresh Token is revoked
        :param bool kickstart_success: When kickstart has successfully completed
        :param bool user_action: When a user action is triggered
        :param bool user_bulk_create: When multiple users are created in bulk (i.e. during an import)
        :param bool user_create: When a user is created
        :param bool user_create_complete: When a user create transaction has completed
        :param bool user_deactivate: When a user is deactivated
        :param bool user_delete: When a user is deleted
        :param bool user_delete_complete: When a user delete transaction has completed
        :param bool user_email_update: When a user updates their email address
        :param bool user_email_verified: When a user verifies their email address
        :param bool user_identity_provider_link: When a user is linked to an identity provider
        :param bool user_identity_provider_unlink: When a link to an identity provider is removed
        :param bool user_login_failed: When a user fails a login request
        :param bool user_login_id_duplicate_create: When a request to create a user with a login Id (email or username) which is already in use has been received
        :param bool user_login_id_duplicate_update: When a request to update a user and change their login Id (email or username) to one that is already in use has been received
        :param bool user_login_new_device: When a user begins a login request with a new device
        :param bool user_login_success: When a user completes a login request
        :param bool user_login_suspicious: When a user logs in and is considered to be a potential threat
        :param bool user_password_breach: When Reactor detects a user is using a potentially breached password (requires an activated license)
        :param bool user_password_reset_send: When a forgot password email has been sent to a user
        :param bool user_password_reset_start: When the process to reset a user password has started
        :param bool user_password_reset_success: When a user has successfully reset their password
        :param bool user_password_update: When a user has updated their password
        :param bool user_reactivate: When a user is reactivated
        :param bool user_registration_create: When a user registration is created
        :param bool user_registration_create_complete: When a user registration create transaction has completed
        :param bool user_registration_delete: When a user registration is deleted
        :param bool user_registration_delete_complete: When a user registration delete transaction has completed
        :param bool user_registration_update: When a user registration is updated
        :param bool user_registration_update_complete: When a user registration update transaction has completed
        :param bool user_registration_verified: When a user completes registration verification
        :param bool user_two_factor_method_add: When a user has added a two-factor method
        :param bool user_two_factor_method_remove: When a user has removed a two-factor method
        :param bool user_update: When a user is updated
        :param bool user_update_complete: When a user update transaction has completed
        """
        if audit_log_create is not None:
            pulumi.set(__self__, "audit_log_create", audit_log_create)
        if event_log_create is not None:
            pulumi.set(__self__, "event_log_create", event_log_create)
        if jwt_public_key_update is not None:
            pulumi.set(__self__, "jwt_public_key_update", jwt_public_key_update)
        if jwt_refresh is not None:
            pulumi.set(__self__, "jwt_refresh", jwt_refresh)
        if jwt_refresh_token_revoke is not None:
            pulumi.set(__self__, "jwt_refresh_token_revoke", jwt_refresh_token_revoke)
        if kickstart_success is not None:
            pulumi.set(__self__, "kickstart_success", kickstart_success)
        if user_action is not None:
            pulumi.set(__self__, "user_action", user_action)
        if user_bulk_create is not None:
            pulumi.set(__self__, "user_bulk_create", user_bulk_create)
        if user_create is not None:
            pulumi.set(__self__, "user_create", user_create)
        if user_create_complete is not None:
            pulumi.set(__self__, "user_create_complete", user_create_complete)
        if user_deactivate is not None:
            pulumi.set(__self__, "user_deactivate", user_deactivate)
        if user_delete is not None:
            pulumi.set(__self__, "user_delete", user_delete)
        if user_delete_complete is not None:
            pulumi.set(__self__, "user_delete_complete", user_delete_complete)
        if user_email_update is not None:
            pulumi.set(__self__, "user_email_update", user_email_update)
        if user_email_verified is not None:
            pulumi.set(__self__, "user_email_verified", user_email_verified)
        if user_identity_provider_link is not None:
            pulumi.set(__self__, "user_identity_provider_link", user_identity_provider_link)
        if user_identity_provider_unlink is not None:
            pulumi.set(__self__, "user_identity_provider_unlink", user_identity_provider_unlink)
        if user_login_failed is not None:
            pulumi.set(__self__, "user_login_failed", user_login_failed)
        if user_login_id_duplicate_create is not None:
            pulumi.set(__self__, "user_login_id_duplicate_create", user_login_id_duplicate_create)
        if user_login_id_duplicate_update is not None:
            pulumi.set(__self__, "user_login_id_duplicate_update", user_login_id_duplicate_update)
        if user_login_new_device is not None:
            pulumi.set(__self__, "user_login_new_device", user_login_new_device)
        if user_login_success is not None:
            pulumi.set(__self__, "user_login_success", user_login_success)
        if user_login_suspicious is not None:
            pulumi.set(__self__, "user_login_suspicious", user_login_suspicious)
        if user_password_breach is not None:
            pulumi.set(__self__, "user_password_breach", user_password_breach)
        if user_password_reset_send is not None:
            pulumi.set(__self__, "user_password_reset_send", user_password_reset_send)
        if user_password_reset_start is not None:
            pulumi.set(__self__, "user_password_reset_start", user_password_reset_start)
        if user_password_reset_success is not None:
            pulumi.set(__self__, "user_password_reset_success", user_password_reset_success)
        if user_password_update is not None:
            pulumi.set(__self__, "user_password_update", user_password_update)
        if user_reactivate is not None:
            pulumi.set(__self__, "user_reactivate", user_reactivate)
        if user_registration_create is not None:
            pulumi.set(__self__, "user_registration_create", user_registration_create)
        if user_registration_create_complete is not None:
            pulumi.set(__self__, "user_registration_create_complete", user_registration_create_complete)
        if user_registration_delete is not None:
            pulumi.set(__self__, "user_registration_delete", user_registration_delete)
        if user_registration_delete_complete is not None:
            pulumi.set(__self__, "user_registration_delete_complete", user_registration_delete_complete)
        if user_registration_update is not None:
            pulumi.set(__self__, "user_registration_update", user_registration_update)
        if user_registration_update_complete is not None:
            pulumi.set(__self__, "user_registration_update_complete", user_registration_update_complete)
        if user_registration_verified is not None:
            pulumi.set(__self__, "user_registration_verified", user_registration_verified)
        if user_two_factor_method_add is not None:
            pulumi.set(__self__, "user_two_factor_method_add", user_two_factor_method_add)
        if user_two_factor_method_remove is not None:
            pulumi.set(__self__, "user_two_factor_method_remove", user_two_factor_method_remove)
        if user_update is not None:
            pulumi.set(__self__, "user_update", user_update)
        if user_update_complete is not None:
            pulumi.set(__self__, "user_update_complete", user_update_complete)

    @property
    @pulumi.getter(name="auditLogCreate")
    def audit_log_create(self) -> Optional[bool]:
        """
        When an audit log is created
        """
        return pulumi.get(self, "audit_log_create")

    @property
    @pulumi.getter(name="eventLogCreate")
    def event_log_create(self) -> Optional[bool]:
        """
        When an event log is created
        """
        return pulumi.get(self, "event_log_create")

    @property
    @pulumi.getter(name="jwtPublicKeyUpdate")
    def jwt_public_key_update(self) -> Optional[bool]:
        """
        When a JWT RSA Public / Private keypair may have been changed
        """
        return pulumi.get(self, "jwt_public_key_update")

    @property
    @pulumi.getter(name="jwtRefresh")
    def jwt_refresh(self) -> Optional[bool]:
        """
        When an access token is refreshed using a refresh token
        """
        return pulumi.get(self, "jwt_refresh")

    @property
    @pulumi.getter(name="jwtRefreshTokenRevoke")
    def jwt_refresh_token_revoke(self) -> Optional[bool]:
        """
        When a JWT Refresh Token is revoked
        """
        return pulumi.get(self, "jwt_refresh_token_revoke")

    @property
    @pulumi.getter(name="kickstartSuccess")
    def kickstart_success(self) -> Optional[bool]:
        """
        When kickstart has successfully completed
        """
        return pulumi.get(self, "kickstart_success")

    @property
    @pulumi.getter(name="userAction")
    def user_action(self) -> Optional[bool]:
        """
        When a user action is triggered
        """
        return pulumi.get(self, "user_action")

    @property
    @pulumi.getter(name="userBulkCreate")
    def user_bulk_create(self) -> Optional[bool]:
        """
        When multiple users are created in bulk (i.e. during an import)
        """
        return pulumi.get(self, "user_bulk_create")

    @property
    @pulumi.getter(name="userCreate")
    def user_create(self) -> Optional[bool]:
        """
        When a user is created
        """
        return pulumi.get(self, "user_create")

    @property
    @pulumi.getter(name="userCreateComplete")
    def user_create_complete(self) -> Optional[bool]:
        """
        When a user create transaction has completed
        """
        return pulumi.get(self, "user_create_complete")

    @property
    @pulumi.getter(name="userDeactivate")
    def user_deactivate(self) -> Optional[bool]:
        """
        When a user is deactivated
        """
        return pulumi.get(self, "user_deactivate")

    @property
    @pulumi.getter(name="userDelete")
    def user_delete(self) -> Optional[bool]:
        """
        When a user is deleted
        """
        return pulumi.get(self, "user_delete")

    @property
    @pulumi.getter(name="userDeleteComplete")
    def user_delete_complete(self) -> Optional[bool]:
        """
        When a user delete transaction has completed
        """
        return pulumi.get(self, "user_delete_complete")

    @property
    @pulumi.getter(name="userEmailUpdate")
    def user_email_update(self) -> Optional[bool]:
        """
        When a user updates their email address
        """
        return pulumi.get(self, "user_email_update")

    @property
    @pulumi.getter(name="userEmailVerified")
    def user_email_verified(self) -> Optional[bool]:
        """
        When a user verifies their email address
        """
        return pulumi.get(self, "user_email_verified")

    @property
    @pulumi.getter(name="userIdentityProviderLink")
    def user_identity_provider_link(self) -> Optional[bool]:
        """
        When a user is linked to an identity provider
        """
        return pulumi.get(self, "user_identity_provider_link")

    @property
    @pulumi.getter(name="userIdentityProviderUnlink")
    def user_identity_provider_unlink(self) -> Optional[bool]:
        """
        When a link to an identity provider is removed
        """
        return pulumi.get(self, "user_identity_provider_unlink")

    @property
    @pulumi.getter(name="userLoginFailed")
    def user_login_failed(self) -> Optional[bool]:
        """
        When a user fails a login request
        """
        return pulumi.get(self, "user_login_failed")

    @property
    @pulumi.getter(name="userLoginIdDuplicateCreate")
    def user_login_id_duplicate_create(self) -> Optional[bool]:
        """
        When a request to create a user with a login Id (email or username) which is already in use has been received
        """
        return pulumi.get(self, "user_login_id_duplicate_create")

    @property
    @pulumi.getter(name="userLoginIdDuplicateUpdate")
    def user_login_id_duplicate_update(self) -> Optional[bool]:
        """
        When a request to update a user and change their login Id (email or username) to one that is already in use has been received
        """
        return pulumi.get(self, "user_login_id_duplicate_update")

    @property
    @pulumi.getter(name="userLoginNewDevice")
    def user_login_new_device(self) -> Optional[bool]:
        """
        When a user begins a login request with a new device
        """
        return pulumi.get(self, "user_login_new_device")

    @property
    @pulumi.getter(name="userLoginSuccess")
    def user_login_success(self) -> Optional[bool]:
        """
        When a user completes a login request
        """
        return pulumi.get(self, "user_login_success")

    @property
    @pulumi.getter(name="userLoginSuspicious")
    def user_login_suspicious(self) -> Optional[bool]:
        """
        When a user logs in and is considered to be a potential threat
        """
        return pulumi.get(self, "user_login_suspicious")

    @property
    @pulumi.getter(name="userPasswordBreach")
    def user_password_breach(self) -> Optional[bool]:
        """
        When Reactor detects a user is using a potentially breached password (requires an activated license)
        """
        return pulumi.get(self, "user_password_breach")

    @property
    @pulumi.getter(name="userPasswordResetSend")
    def user_password_reset_send(self) -> Optional[bool]:
        """
        When a forgot password email has been sent to a user
        """
        return pulumi.get(self, "user_password_reset_send")

    @property
    @pulumi.getter(name="userPasswordResetStart")
    def user_password_reset_start(self) -> Optional[bool]:
        """
        When the process to reset a user password has started
        """
        return pulumi.get(self, "user_password_reset_start")

    @property
    @pulumi.getter(name="userPasswordResetSuccess")
    def user_password_reset_success(self) -> Optional[bool]:
        """
        When a user has successfully reset their password
        """
        return pulumi.get(self, "user_password_reset_success")

    @property
    @pulumi.getter(name="userPasswordUpdate")
    def user_password_update(self) -> Optional[bool]:
        """
        When a user has updated their password
        """
        return pulumi.get(self, "user_password_update")

    @property
    @pulumi.getter(name="userReactivate")
    def user_reactivate(self) -> Optional[bool]:
        """
        When a user is reactivated
        """
        return pulumi.get(self, "user_reactivate")

    @property
    @pulumi.getter(name="userRegistrationCreate")
    def user_registration_create(self) -> Optional[bool]:
        """
        When a user registration is created
        """
        return pulumi.get(self, "user_registration_create")

    @property
    @pulumi.getter(name="userRegistrationCreateComplete")
    def user_registration_create_complete(self) -> Optional[bool]:
        """
        When a user registration create transaction has completed
        """
        return pulumi.get(self, "user_registration_create_complete")

    @property
    @pulumi.getter(name="userRegistrationDelete")
    def user_registration_delete(self) -> Optional[bool]:
        """
        When a user registration is deleted
        """
        return pulumi.get(self, "user_registration_delete")

    @property
    @pulumi.getter(name="userRegistrationDeleteComplete")
    def user_registration_delete_complete(self) -> Optional[bool]:
        """
        When a user registration delete transaction has completed
        """
        return pulumi.get(self, "user_registration_delete_complete")

    @property
    @pulumi.getter(name="userRegistrationUpdate")
    def user_registration_update(self) -> Optional[bool]:
        """
        When a user registration is updated
        """
        return pulumi.get(self, "user_registration_update")

    @property
    @pulumi.getter(name="userRegistrationUpdateComplete")
    def user_registration_update_complete(self) -> Optional[bool]:
        """
        When a user registration update transaction has completed
        """
        return pulumi.get(self, "user_registration_update_complete")

    @property
    @pulumi.getter(name="userRegistrationVerified")
    def user_registration_verified(self) -> Optional[bool]:
        """
        When a user completes registration verification
        """
        return pulumi.get(self, "user_registration_verified")

    @property
    @pulumi.getter(name="userTwoFactorMethodAdd")
    def user_two_factor_method_add(self) -> Optional[bool]:
        """
        When a user has added a two-factor method
        """
        return pulumi.get(self, "user_two_factor_method_add")

    @property
    @pulumi.getter(name="userTwoFactorMethodRemove")
    def user_two_factor_method_remove(self) -> Optional[bool]:
        """
        When a user has removed a two-factor method
        """
        return pulumi.get(self, "user_two_factor_method_remove")

    @property
    @pulumi.getter(name="userUpdate")
    def user_update(self) -> Optional[bool]:
        """
        When a user is updated
        """
        return pulumi.get(self, "user_update")

    @property
    @pulumi.getter(name="userUpdateComplete")
    def user_update_complete(self) -> Optional[bool]:
        """
        When a user update transaction has completed
        """
        return pulumi.get(self, "user_update_complete")


@pulumi.output_type
class GetFormFieldValidatorResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 expression: Optional[str] = None):
        """
        :param bool enabled: Determines if user input should be validated.
        :param str expression: A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if user input should be validated.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A regular expression used to validate user input. Must be a valid regular expression pattern.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetFormStepResult(dict):
    def __init__(__self__, *,
                 fields: Sequence[str]):
        pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Sequence[str]:
        return pulumi.get(self, "fields")


