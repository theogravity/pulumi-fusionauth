// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fusionauth

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/theogravity/pulumi-fusionauth/sdk/v4/go/fusionauth/internal"
)

// ## # Reactor Resource
//
// The Reactor is FusionAuthâ€™s license system. Reactor is used to activate features based upon your licensing tier.
//
// [Reactor API](https://fusionauth.io/docs/v1/tech/apis/reactor)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/theogravity/pulumi-fusionauth/sdk/v4/go/fusionauth"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := fusionauth.NewFusionAuthReactor(ctx, "reactor", &fusionauth.FusionAuthReactorArgs{
//				License:   pulumi.String("abc"),
//				LicenseId: pulumi.String("xyz"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type FusionAuthReactor struct {
	pulumi.CustomResourceState

	// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
	License pulumi.StringPtrOutput `pulumi:"license"`
	// The license Id to activate.
	LicenseId pulumi.StringOutput `pulumi:"licenseId"`
}

// NewFusionAuthReactor registers a new resource with the given unique name, arguments, and options.
func NewFusionAuthReactor(ctx *pulumi.Context,
	name string, args *FusionAuthReactorArgs, opts ...pulumi.ResourceOption) (*FusionAuthReactor, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LicenseId == nil {
		return nil, errors.New("invalid value for required argument 'LicenseId'")
	}
	if args.License != nil {
		args.License = pulumi.ToSecret(args.License).(pulumi.StringPtrInput)
	}
	if args.LicenseId != nil {
		args.LicenseId = pulumi.ToSecret(args.LicenseId).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"license",
		"licenseId",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FusionAuthReactor
	err := ctx.RegisterResource("fusionauth:index/fusionAuthReactor:FusionAuthReactor", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFusionAuthReactor gets an existing FusionAuthReactor resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFusionAuthReactor(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FusionAuthReactorState, opts ...pulumi.ResourceOption) (*FusionAuthReactor, error) {
	var resource FusionAuthReactor
	err := ctx.ReadResource("fusionauth:index/fusionAuthReactor:FusionAuthReactor", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FusionAuthReactor resources.
type fusionAuthReactorState struct {
	// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
	License *string `pulumi:"license"`
	// The license Id to activate.
	LicenseId *string `pulumi:"licenseId"`
}

type FusionAuthReactorState struct {
	// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
	License pulumi.StringPtrInput
	// The license Id to activate.
	LicenseId pulumi.StringPtrInput
}

func (FusionAuthReactorState) ElementType() reflect.Type {
	return reflect.TypeOf((*fusionAuthReactorState)(nil)).Elem()
}

type fusionAuthReactorArgs struct {
	// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
	License *string `pulumi:"license"`
	// The license Id to activate.
	LicenseId string `pulumi:"licenseId"`
}

// The set of arguments for constructing a FusionAuthReactor resource.
type FusionAuthReactorArgs struct {
	// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
	License pulumi.StringPtrInput
	// The license Id to activate.
	LicenseId pulumi.StringInput
}

func (FusionAuthReactorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fusionAuthReactorArgs)(nil)).Elem()
}

type FusionAuthReactorInput interface {
	pulumi.Input

	ToFusionAuthReactorOutput() FusionAuthReactorOutput
	ToFusionAuthReactorOutputWithContext(ctx context.Context) FusionAuthReactorOutput
}

func (*FusionAuthReactor) ElementType() reflect.Type {
	return reflect.TypeOf((**FusionAuthReactor)(nil)).Elem()
}

func (i *FusionAuthReactor) ToFusionAuthReactorOutput() FusionAuthReactorOutput {
	return i.ToFusionAuthReactorOutputWithContext(context.Background())
}

func (i *FusionAuthReactor) ToFusionAuthReactorOutputWithContext(ctx context.Context) FusionAuthReactorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthReactorOutput)
}

// FusionAuthReactorArrayInput is an input type that accepts FusionAuthReactorArray and FusionAuthReactorArrayOutput values.
// You can construct a concrete instance of `FusionAuthReactorArrayInput` via:
//
//	FusionAuthReactorArray{ FusionAuthReactorArgs{...} }
type FusionAuthReactorArrayInput interface {
	pulumi.Input

	ToFusionAuthReactorArrayOutput() FusionAuthReactorArrayOutput
	ToFusionAuthReactorArrayOutputWithContext(context.Context) FusionAuthReactorArrayOutput
}

type FusionAuthReactorArray []FusionAuthReactorInput

func (FusionAuthReactorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FusionAuthReactor)(nil)).Elem()
}

func (i FusionAuthReactorArray) ToFusionAuthReactorArrayOutput() FusionAuthReactorArrayOutput {
	return i.ToFusionAuthReactorArrayOutputWithContext(context.Background())
}

func (i FusionAuthReactorArray) ToFusionAuthReactorArrayOutputWithContext(ctx context.Context) FusionAuthReactorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthReactorArrayOutput)
}

// FusionAuthReactorMapInput is an input type that accepts FusionAuthReactorMap and FusionAuthReactorMapOutput values.
// You can construct a concrete instance of `FusionAuthReactorMapInput` via:
//
//	FusionAuthReactorMap{ "key": FusionAuthReactorArgs{...} }
type FusionAuthReactorMapInput interface {
	pulumi.Input

	ToFusionAuthReactorMapOutput() FusionAuthReactorMapOutput
	ToFusionAuthReactorMapOutputWithContext(context.Context) FusionAuthReactorMapOutput
}

type FusionAuthReactorMap map[string]FusionAuthReactorInput

func (FusionAuthReactorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FusionAuthReactor)(nil)).Elem()
}

func (i FusionAuthReactorMap) ToFusionAuthReactorMapOutput() FusionAuthReactorMapOutput {
	return i.ToFusionAuthReactorMapOutputWithContext(context.Background())
}

func (i FusionAuthReactorMap) ToFusionAuthReactorMapOutputWithContext(ctx context.Context) FusionAuthReactorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthReactorMapOutput)
}

type FusionAuthReactorOutput struct{ *pulumi.OutputState }

func (FusionAuthReactorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FusionAuthReactor)(nil)).Elem()
}

func (o FusionAuthReactorOutput) ToFusionAuthReactorOutput() FusionAuthReactorOutput {
	return o
}

func (o FusionAuthReactorOutput) ToFusionAuthReactorOutputWithContext(ctx context.Context) FusionAuthReactorOutput {
	return o
}

// The Base64 encoded license value. This value is necessary in an air gapped configuration where outbound network access is not available.
func (o FusionAuthReactorOutput) License() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FusionAuthReactor) pulumi.StringPtrOutput { return v.License }).(pulumi.StringPtrOutput)
}

// The license Id to activate.
func (o FusionAuthReactorOutput) LicenseId() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthReactor) pulumi.StringOutput { return v.LicenseId }).(pulumi.StringOutput)
}

type FusionAuthReactorArrayOutput struct{ *pulumi.OutputState }

func (FusionAuthReactorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FusionAuthReactor)(nil)).Elem()
}

func (o FusionAuthReactorArrayOutput) ToFusionAuthReactorArrayOutput() FusionAuthReactorArrayOutput {
	return o
}

func (o FusionAuthReactorArrayOutput) ToFusionAuthReactorArrayOutputWithContext(ctx context.Context) FusionAuthReactorArrayOutput {
	return o
}

func (o FusionAuthReactorArrayOutput) Index(i pulumi.IntInput) FusionAuthReactorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FusionAuthReactor {
		return vs[0].([]*FusionAuthReactor)[vs[1].(int)]
	}).(FusionAuthReactorOutput)
}

type FusionAuthReactorMapOutput struct{ *pulumi.OutputState }

func (FusionAuthReactorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FusionAuthReactor)(nil)).Elem()
}

func (o FusionAuthReactorMapOutput) ToFusionAuthReactorMapOutput() FusionAuthReactorMapOutput {
	return o
}

func (o FusionAuthReactorMapOutput) ToFusionAuthReactorMapOutputWithContext(ctx context.Context) FusionAuthReactorMapOutput {
	return o
}

func (o FusionAuthReactorMapOutput) MapIndex(k pulumi.StringInput) FusionAuthReactorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FusionAuthReactor {
		return vs[0].(map[string]*FusionAuthReactor)[vs[1].(string)]
	}).(FusionAuthReactorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthReactorInput)(nil)).Elem(), &FusionAuthReactor{})
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthReactorArrayInput)(nil)).Elem(), FusionAuthReactorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthReactorMapInput)(nil)).Elem(), FusionAuthReactorMap{})
	pulumi.RegisterOutputType(FusionAuthReactorOutput{})
	pulumi.RegisterOutputType(FusionAuthReactorArrayOutput{})
	pulumi.RegisterOutputType(FusionAuthReactorMapOutput{})
}
