// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fusionauth

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/theogravity/pulumi-fusionauth/sdk/go/fusionauth/internal"
)

// ## # Entity Resource
//
// Entities are arbitrary objects which can be modeled in FusionAuth. Anything which is not a user but might need
// permissions managed by FusionAuth is a possible entity. Examples might include devices, cars, computers, customers,
// companies, etc.
//
// FusionAuthâ€™s Entity Management has the following major concepts:
//
//   - Entity Types categorize Entities. An Entity Type could be `Device`, `API` or `Company`.
//   - Permissions are defined on an Entity Type. These are arbitrary strings which can fit the business domain. A Permission
//     could be `read`, `write`, or `file-lawsuit`.
//   - Entities are instances of a single type. An Entity could be a `nest device`, an `Email API` or `Raviga`.
//   - Entities can have Grants. Grants are relationships between a target Entity and one of two other types: a recipient
//     Entity or a User. Grants can have zero or more Permissions associated with them.
//
// You can use the Client Credentials grant to see if an Entity has permission to access another Entity.
//
// [Entity API](https://fusionauth.io/docs/v1/tech/apis/entity-management/entities)
type FusionAuthEntity struct {
	pulumi.CustomResourceState

	// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
	// be used. Must be a UUID.
	ClientId pulumi.StringOutput `pulumi:"clientId"`
	// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
	// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
	// and update you can provide a value and it will be stored.
	ClientSecret pulumi.StringOutput `pulumi:"clientSecret"`
	// An object that can hold any information about the Entity that should be persisted. Please review
	// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
	Data pulumi.StringPtrOutput `pulumi:"data"`
	// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
	EntityId pulumi.StringOutput `pulumi:"entityId"`
	// The ID of the Entity Type. Types are consulted for permission checks.
	//
	// For more information see:
	// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
	EntityTypeId pulumi.StringOutput `pulumi:"entityTypeId"`
	// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
	Name pulumi.StringOutput `pulumi:"name"`
	// The unique ID of the tenant used to scope this API request.
	TenantId pulumi.StringPtrOutput `pulumi:"tenantId"`
}

// NewFusionAuthEntity registers a new resource with the given unique name, arguments, and options.
func NewFusionAuthEntity(ctx *pulumi.Context,
	name string, args *FusionAuthEntityArgs, opts ...pulumi.ResourceOption) (*FusionAuthEntity, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntityTypeId == nil {
		return nil, errors.New("invalid value for required argument 'EntityTypeId'")
	}
	if args.ClientSecret != nil {
		args.ClientSecret = pulumi.ToSecret(args.ClientSecret).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"clientSecret",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FusionAuthEntity
	err := ctx.RegisterResource("fusionauth:index/fusionAuthEntity:FusionAuthEntity", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFusionAuthEntity gets an existing FusionAuthEntity resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFusionAuthEntity(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FusionAuthEntityState, opts ...pulumi.ResourceOption) (*FusionAuthEntity, error) {
	var resource FusionAuthEntity
	err := ctx.ReadResource("fusionauth:index/fusionAuthEntity:FusionAuthEntity", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FusionAuthEntity resources.
type fusionAuthEntityState struct {
	// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
	// be used. Must be a UUID.
	ClientId *string `pulumi:"clientId"`
	// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
	// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
	// and update you can provide a value and it will be stored.
	ClientSecret *string `pulumi:"clientSecret"`
	// An object that can hold any information about the Entity that should be persisted. Please review
	// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
	Data *string `pulumi:"data"`
	// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
	EntityId *string `pulumi:"entityId"`
	// The ID of the Entity Type. Types are consulted for permission checks.
	//
	// For more information see:
	// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
	EntityTypeId *string `pulumi:"entityTypeId"`
	// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
	Name *string `pulumi:"name"`
	// The unique ID of the tenant used to scope this API request.
	TenantId *string `pulumi:"tenantId"`
}

type FusionAuthEntityState struct {
	// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
	// be used. Must be a UUID.
	ClientId pulumi.StringPtrInput
	// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
	// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
	// and update you can provide a value and it will be stored.
	ClientSecret pulumi.StringPtrInput
	// An object that can hold any information about the Entity that should be persisted. Please review
	// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
	Data pulumi.StringPtrInput
	// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
	EntityId pulumi.StringPtrInput
	// The ID of the Entity Type. Types are consulted for permission checks.
	//
	// For more information see:
	// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
	EntityTypeId pulumi.StringPtrInput
	// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
	Name pulumi.StringPtrInput
	// The unique ID of the tenant used to scope this API request.
	TenantId pulumi.StringPtrInput
}

func (FusionAuthEntityState) ElementType() reflect.Type {
	return reflect.TypeOf((*fusionAuthEntityState)(nil)).Elem()
}

type fusionAuthEntityArgs struct {
	// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
	// be used. Must be a UUID.
	ClientId *string `pulumi:"clientId"`
	// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
	// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
	// and update you can provide a value and it will be stored.
	ClientSecret *string `pulumi:"clientSecret"`
	// An object that can hold any information about the Entity that should be persisted. Please review
	// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
	Data *string `pulumi:"data"`
	// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
	EntityId *string `pulumi:"entityId"`
	// The ID of the Entity Type. Types are consulted for permission checks.
	//
	// For more information see:
	// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
	EntityTypeId string `pulumi:"entityTypeId"`
	// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
	Name *string `pulumi:"name"`
	// The unique ID of the tenant used to scope this API request.
	TenantId *string `pulumi:"tenantId"`
}

// The set of arguments for constructing a FusionAuthEntity resource.
type FusionAuthEntityArgs struct {
	// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
	// be used. Must be a UUID.
	ClientId pulumi.StringPtrInput
	// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
	// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
	// and update you can provide a value and it will be stored.
	ClientSecret pulumi.StringPtrInput
	// An object that can hold any information about the Entity that should be persisted. Please review
	// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
	Data pulumi.StringPtrInput
	// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
	EntityId pulumi.StringPtrInput
	// The ID of the Entity Type. Types are consulted for permission checks.
	//
	// For more information see:
	// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
	EntityTypeId pulumi.StringInput
	// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
	Name pulumi.StringPtrInput
	// The unique ID of the tenant used to scope this API request.
	TenantId pulumi.StringPtrInput
}

func (FusionAuthEntityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fusionAuthEntityArgs)(nil)).Elem()
}

type FusionAuthEntityInput interface {
	pulumi.Input

	ToFusionAuthEntityOutput() FusionAuthEntityOutput
	ToFusionAuthEntityOutputWithContext(ctx context.Context) FusionAuthEntityOutput
}

func (*FusionAuthEntity) ElementType() reflect.Type {
	return reflect.TypeOf((**FusionAuthEntity)(nil)).Elem()
}

func (i *FusionAuthEntity) ToFusionAuthEntityOutput() FusionAuthEntityOutput {
	return i.ToFusionAuthEntityOutputWithContext(context.Background())
}

func (i *FusionAuthEntity) ToFusionAuthEntityOutputWithContext(ctx context.Context) FusionAuthEntityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthEntityOutput)
}

// FusionAuthEntityArrayInput is an input type that accepts FusionAuthEntityArray and FusionAuthEntityArrayOutput values.
// You can construct a concrete instance of `FusionAuthEntityArrayInput` via:
//
//	FusionAuthEntityArray{ FusionAuthEntityArgs{...} }
type FusionAuthEntityArrayInput interface {
	pulumi.Input

	ToFusionAuthEntityArrayOutput() FusionAuthEntityArrayOutput
	ToFusionAuthEntityArrayOutputWithContext(context.Context) FusionAuthEntityArrayOutput
}

type FusionAuthEntityArray []FusionAuthEntityInput

func (FusionAuthEntityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FusionAuthEntity)(nil)).Elem()
}

func (i FusionAuthEntityArray) ToFusionAuthEntityArrayOutput() FusionAuthEntityArrayOutput {
	return i.ToFusionAuthEntityArrayOutputWithContext(context.Background())
}

func (i FusionAuthEntityArray) ToFusionAuthEntityArrayOutputWithContext(ctx context.Context) FusionAuthEntityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthEntityArrayOutput)
}

// FusionAuthEntityMapInput is an input type that accepts FusionAuthEntityMap and FusionAuthEntityMapOutput values.
// You can construct a concrete instance of `FusionAuthEntityMapInput` via:
//
//	FusionAuthEntityMap{ "key": FusionAuthEntityArgs{...} }
type FusionAuthEntityMapInput interface {
	pulumi.Input

	ToFusionAuthEntityMapOutput() FusionAuthEntityMapOutput
	ToFusionAuthEntityMapOutputWithContext(context.Context) FusionAuthEntityMapOutput
}

type FusionAuthEntityMap map[string]FusionAuthEntityInput

func (FusionAuthEntityMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FusionAuthEntity)(nil)).Elem()
}

func (i FusionAuthEntityMap) ToFusionAuthEntityMapOutput() FusionAuthEntityMapOutput {
	return i.ToFusionAuthEntityMapOutputWithContext(context.Background())
}

func (i FusionAuthEntityMap) ToFusionAuthEntityMapOutputWithContext(ctx context.Context) FusionAuthEntityMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FusionAuthEntityMapOutput)
}

type FusionAuthEntityOutput struct{ *pulumi.OutputState }

func (FusionAuthEntityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FusionAuthEntity)(nil)).Elem()
}

func (o FusionAuthEntityOutput) ToFusionAuthEntityOutput() FusionAuthEntityOutput {
	return o
}

func (o FusionAuthEntityOutput) ToFusionAuthEntityOutputWithContext(ctx context.Context) FusionAuthEntityOutput {
	return o
}

// The OAuth 2.0 client ID. If you leave this blank on create, the value of the Entity ID will
// be used. Must be a UUID.
func (o FusionAuthEntityOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringOutput { return v.ClientId }).(pulumi.StringOutput)
}

// The OAuth 2.0 client secret. If you leave this blank on create, a secure secret will be
// generated for you. If you leave this blank during an update, the previous value will be maintained. For both create
// and update you can provide a value and it will be stored.
func (o FusionAuthEntityOutput) ClientSecret() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringOutput { return v.ClientSecret }).(pulumi.StringOutput)
}

// An object that can hold any information about the Entity that should be persisted. Please review
// the limits on data field types as you plan for and build your custom data schema. Must be a JSON serialised string.
func (o FusionAuthEntityOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringPtrOutput { return v.Data }).(pulumi.StringPtrOutput)
}

// The ID to use for the new Entity. If not specified a secure random UUID will be generated.
func (o FusionAuthEntityOutput) EntityId() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringOutput { return v.EntityId }).(pulumi.StringOutput)
}

// The ID of the Entity Type. Types are consulted for permission checks.
//
// For more information see:
// [FusionAuth Entity Management API Overview](https://fusionauth.io/docs/v1/tech/apis/entity-management/)
func (o FusionAuthEntityOutput) EntityTypeId() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringOutput { return v.EntityTypeId }).(pulumi.StringOutput)
}

// A descriptive name for the Entity (i.e. "Raviga" or "Email Service").
func (o FusionAuthEntityOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The unique ID of the tenant used to scope this API request.
func (o FusionAuthEntityOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FusionAuthEntity) pulumi.StringPtrOutput { return v.TenantId }).(pulumi.StringPtrOutput)
}

type FusionAuthEntityArrayOutput struct{ *pulumi.OutputState }

func (FusionAuthEntityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FusionAuthEntity)(nil)).Elem()
}

func (o FusionAuthEntityArrayOutput) ToFusionAuthEntityArrayOutput() FusionAuthEntityArrayOutput {
	return o
}

func (o FusionAuthEntityArrayOutput) ToFusionAuthEntityArrayOutputWithContext(ctx context.Context) FusionAuthEntityArrayOutput {
	return o
}

func (o FusionAuthEntityArrayOutput) Index(i pulumi.IntInput) FusionAuthEntityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FusionAuthEntity {
		return vs[0].([]*FusionAuthEntity)[vs[1].(int)]
	}).(FusionAuthEntityOutput)
}

type FusionAuthEntityMapOutput struct{ *pulumi.OutputState }

func (FusionAuthEntityMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FusionAuthEntity)(nil)).Elem()
}

func (o FusionAuthEntityMapOutput) ToFusionAuthEntityMapOutput() FusionAuthEntityMapOutput {
	return o
}

func (o FusionAuthEntityMapOutput) ToFusionAuthEntityMapOutputWithContext(ctx context.Context) FusionAuthEntityMapOutput {
	return o
}

func (o FusionAuthEntityMapOutput) MapIndex(k pulumi.StringInput) FusionAuthEntityOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FusionAuthEntity {
		return vs[0].(map[string]*FusionAuthEntity)[vs[1].(string)]
	}).(FusionAuthEntityOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthEntityInput)(nil)).Elem(), &FusionAuthEntity{})
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthEntityArrayInput)(nil)).Elem(), FusionAuthEntityArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FusionAuthEntityMapInput)(nil)).Elem(), FusionAuthEntityMap{})
	pulumi.RegisterOutputType(FusionAuthEntityOutput{})
	pulumi.RegisterOutputType(FusionAuthEntityArrayOutput{})
	pulumi.RegisterOutputType(FusionAuthEntityMapOutput{})
}
